<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JS | duwhywu的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="js中的对象、类与面向对象编程小结对象在代码执行过程中的任何时候都可以被创建和增强，具有极大的动态性，并不是严格定义的实体。下面的模式适用于创建对象。 工厂模式就是一个简单的函数，这个函数可以创建对象，为它添加属性和方法，然后返回这个对象。这个模式在构造函数模式出现后就很少用了。 使用构造函数模式可以自定义引用类型，可以使用new 关键字像创建内置类型实例一样创建自定义类型的实例。不过，构造函">
<meta property="og:type" content="article">
<meta property="og:title" content="JS">
<meta property="og:url" content="https://duwhywu.github.io/2024/10/30/js/index.html">
<meta property="og:site_name" content="duwhywu的个人博客">
<meta property="og:description" content="js中的对象、类与面向对象编程小结对象在代码执行过程中的任何时候都可以被创建和增强，具有极大的动态性，并不是严格定义的实体。下面的模式适用于创建对象。 工厂模式就是一个简单的函数，这个函数可以创建对象，为它添加属性和方法，然后返回这个对象。这个模式在构造函数模式出现后就很少用了。 使用构造函数模式可以自定义引用类型，可以使用new 关键字像创建内置类型实例一样创建自定义类型的实例。不过，构造函">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241023150407470.png">
<meta property="og:image" content="c:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241028103634325.png">
<meta property="og:image" content="c:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241028104106884.png">
<meta property="article:published_time" content="2024-10-30T04:35:17.000Z">
<meta property="article:modified_time" content="2024-10-30T04:39:14.534Z">
<meta property="article:author" content="duwhywu">
<meta property="article:tag" content="来自 -- JavaScript高级程序设计（第4版）">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241023150407470.png">
  
    <link rel="alternate" href="/atom.xml" title="duwhywu的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">duwhywu的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">duwhywu的个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://duwhywu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-js" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/30/js/" class="article-date">
  <time class="dt-published" datetime="2024-10-30T04:35:17.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JS
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="js中的对象、类与面向对象编程"><a href="#js中的对象、类与面向对象编程" class="headerlink" title="js中的对象、类与面向对象编程"></a>js中的对象、类与面向对象编程</h1><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对象在代码执行过程中的任何时候都可以被创建和增强，具有极大的动态性，并不是严格定义的实体。下面的模式适用于创建对象。<br> 工厂模式就是一个简单的函数，这个函数可以创建对象，为它添加属性和方法，然后返回这个对象。这个模式在构造函数模式出现后就很少用了。<br> 使用构造函数模式可以自定义引用类型，可以使用new 关键字像创建内置类型实例一样创建自定义类型的实例。不过，构造函数模式也有不足，主要是其成员无法重用，包括函数。考虑到函数本身是松散的、弱类型的，没有理由让函数不能在多个对象实例间共享。<br> 原型模式解决了成员共享的问题，只要是添加到构造函数prototype 上的属性和方法就可以共享。而组合构造函数和原型模式通过构造函数定义实例属性，通过原型定义共享的属性和方法。<br>JavaScript 的继承主要通过原型链来实现。原型链涉及把构造函数的原型赋值为另一个类型的实例。<br>这样一来，子类就可以访问父类的所有属性和方法，就像基于类的继承那样。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。盗用构造函数模式通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）。目前最流行的继承模式是组合继承，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。<br>除上述模式之外，还有以下几种继承模式。<br> 原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。这种操作的结果之后还可以再进一步增强。<br> 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。这个模式也被用在组合继承中，用于避免重复调用父类构造函数导致的浪费。<br> 寄生组合继承被认为是实现基于类型继承的最有效方式。<br>ECMAScript 6 新增的类很大程度上是基于既有原型机制的语法糖。类的语法让开发者可以优雅地定义向后兼容的类，既可以继承内置类型，也可以继承自定义类型。类有效地跨越了对象实例、对象原型和对象类之间的鸿沟。</p>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>讲讲属性：</p>
<p>属性分两种：<strong>数据属性</strong>和<strong>访问器属性</strong>。</p>
<h3 id="数据属性-Object-defineProperty"><a href="#数据属性-Object-defineProperty" class="headerlink" title="数据属性(Object.defineProperty())"></a><strong>数据属性</strong>(Object.defineProperty())</h3><p>（它包含的是一个数据值的位置，在这可以对数据值进行读写）</p>
<p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有4<br>个特性描述它们的行为。<br> [[<strong>Configurable</strong>]]：表示属性是否可以通过delete 删除并重新定义，是否可以修改它的特<br>性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特<br>性都是true，如前面的例子所示。<br> [[<strong>Enumerable</strong>]]：表示属性是否可以通过for-in 循环返回。默认情况下，所有直接定义在对<br>象上的属性的这个特性都是true，如前面的例子所示。<br> [[<strong>Writable</strong>]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的<br>这个特性都是true，如前面的例子所示。<br> [[<strong>Value</strong>]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为undefined。</p>
<p>这时，我们要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3 个参数：<br>要给其<strong>添加属性的对象</strong>、<strong>属性的名称</strong>和<strong>一个描述符对象</strong>。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable 和value，跟相关特性的名称一一对应。根据要修改<br>的特性，可以设置其中一个或多个值。<strong>比如</strong>：<br>let person &#x3D; {};<br><strong>Object.defineProperty</strong>(person, “name”, {<br>    writable: false,<br>    value: “Nicholas”<br>});<br>console.log(person.name); &#x2F;&#x2F; “Nicholas”<br>person.name &#x3D; “Greg”;<br>console.log(person.name); &#x2F;&#x2F; “Nicholas”<br>这个例子创建了一个名为name 的属性并给它赋予了一个只读的值”Nicholas”。<strong>这个属性的值就不能再修改了</strong>，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。</p>
<h3 id="访问器属性-Object-defineProperty"><a href="#访问器属性-Object-defineProperty" class="headerlink" title="访问器属性(Object.defineProperty())"></a><strong>访问器属性</strong>(Object.defineProperty())</h3><p>（这个属性不包含数据值，包含的是一对<strong>get</strong>和<strong>set</strong>方法，在读写访问器属性时，就是通过这两个方法来进行操作处理的。）</p>
<p>访问器属性不包含数据值。相反，它们<strong>包含一个获取（getter）函数</strong>和<strong>一个设置（setter）函数</strong>，不过<strong>这两个函数不是必需的</strong>。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效<br>的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访<br>问器属性有4 个特性描述它们的行为。<br> [[<strong>Configurable</strong>]]：表示属性是否可以通过delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是true。<br> [[<strong>Enumerable</strong>]]：表示属性是否可以通过for-in 循环返回。默认情况下，所有直接定义在对<br>象上的属性的这个特性都是true。<br> [[<strong>Get</strong>]]：获取函数，在读取属性时调用。默认值为undefined。<br> [[<strong>Set</strong>]]：设置函数，在写入属性时调用。默认值为undefined。<br>访问器属性是不能直接定义的，必须使用Object.defineProperty()。下面是一个例子：</p>
<p>&#x2F;&#x2F; 定义一个对象，包含伪私有成员year和公共成员edition</p>
<p>let book &#x3D; {};</p>
<p>Object.defineProperties(book, {<br>    years: {<br>        value: 2017,<br>        writable: true &#x2F;&#x2F; 允许内部修改<br>    },<br>    edition: {<br>        value: 1,<br>        writable: true &#x2F;&#x2F; 允许内部修改<br>    },<br>    year: {<br>        get() {<br>            return this.years;<br>        },<br>        set(newValue) {<br>            if (newValue &gt; this.years) {<br>                const editionsIncrease &#x3D; newValue - this.years;<br>                this.years &#x3D; newValue;<br>                this.edition +&#x3D; editionsIncrease;<br>            }<br>        }<br>    }<br>});</p>
<p>console.log(book); &#x2F;&#x2F; 输出: { years: 2017, edition: 1 }<br>book.year &#x3D; 2018;<br>console.log(book); &#x2F;&#x2F; 输出: { years: 2018, edition: 2 }</p>
<p>在这个例子中，对象book 有两个默认属性：year_和edition。year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问。另一个属性year 被定义为一个访问器属性，其中获取函数简单地返回year_的值，而设置函数会做一些计算以决定正确的版本（edition）。因此，把year 属性修改为2018 会导致year_变成2018，edition 变成2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。</p>
<h3 id="定义多个属性-Object-defineProperties"><a href="#定义多个属性-Object-defineProperties" class="headerlink" title="定义多个属性(Object.defineProperties())"></a>定义多个属性(Object.defineProperties())</h3><p>在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript 提供了<strong>Object.defineProperties()<strong>方法。这个方法可</strong>以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象</strong>，其属性与要添加或修改的属性一一对应。比如：</p>
<p>let book &#x3D; {};<br>Object.defineProperties(book, {<br>    years: {<br>        value: 2017<br>    },<br>    edition: {<br>        value: 1<br>    },<br>    year: {<br>        get() {<br>            return this.years;<br>        },</p>
<p>​		set(newValue) {<br>​			if (newValue &gt; 2017) {<br>​				this.years &#x3D; newValue;<br>​				this.edition +&#x3D; newValue - 2017;<br>​			}<br>​		}<br>​	}<br>});</p>
<p>这段代码在book 对象上定义了两个数据属性years和edition，还有一个访问器属性year。最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的<strong>configurable、enumerable 和writable 特性值都是false</strong>。</p>
<h3 id="读取属性的特性-Object-getOwnPropertyDescriptor"><a href="#读取属性的特性-Object-getOwnPropertyDescriptor" class="headerlink" title="读取属性的特性(Object.getOwnPropertyDescriptor())"></a>读取属性的特性(Object.getOwnPropertyDescriptor())</h3><p>使用<strong>Object.getOwnPropertyDescriptor()<strong>方法可以取得指定属性的属性描述符。这个方法接收两个参数：</strong>属性所在的对象</strong>和<strong>要取得其描述符的属性名</strong>。<strong>返回值是一个对象</strong>，对于访问器属性包含configurable、enumerable、get 和set 属性，对于数据属性包含configurable、enumerable、writable 和value 属性。比如：</p>
<p>let book &#x3D; {};<br>Object.defineProperties(book, {<br>    years: {<br>        value: 2017<br>    },<br>    edition: {<br>        value: 1<br>    },<br>    year: {<br>        get: function () {<br>            return this.years;<br>        },<br>        set: function (newValue) {<br>            if (newValue &gt; 2017) {<br>                this.years &#x3D; newValue;<br>                this.edition +&#x3D; newValue - 2017;<br>            }<br>        }<br>    }<br>});<br>let descriptor &#x3D; Object.getOwnPropertyDescriptor(book, “years”);<br>console.log(descriptor.value); &#x2F;&#x2F; 2017<br>console.log(descriptor.configurable); &#x2F;&#x2F; false<br>console.log(typeof descriptor.get); &#x2F;&#x2F; “undefined”</p>
<p>let descriptor2 &#x3D; Object.getOwnPropertyDescriptor(book, “year”);<br>console.log(descriptor2.value); &#x2F;&#x2F; undefined<br>console.log(descriptor2.enumerable); &#x2F;&#x2F; false<br>console.log(typeof descriptor2.get); &#x2F;&#x2F; “function”</p>
<p>对于数据属性years，value 等于原来的值，configurable 是false，get 是undefined。对于访问器属性year，value 是undefined，enumerable 是false，get 是一个指向获取函数的指针。</p>
<h3 id="合并对象-Object-assign"><a href="#合并对象-Object-assign" class="headerlink" title="合并对象(Object.assign())"></a>合并对象(Object.assign())</h3><p>就是把源对象所有的本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（mixin）。合并对象有**Object.assign()**方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回true）和自有（Object.hasOwnProperty()返回true）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值。</p>
<p>（解释一下：通过调用hasOwnProperty()能够清楚地看到访问的是实例属性还是原型属性。调用person1.hasOwnProperty(“name”)只在重写person1 上name 属性的情况下才返回true，表明此时name 是一个实例属性，不是原型属性。如下图：<img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241023150407470.png" alt="image-20241023150407470">）</p>
<p>let dest, src, result;<br>&#x2F;**</p>
<p>简单复制<br><em>&#x2F;<br>dest &#x3D; {};<br>src &#x3D; { id: ‘src’ };<br>result &#x3D; Object.assign(dest, src);<br>&#x2F;&#x2F; Object.assign 修改目标对象<br>&#x2F;&#x2F; 也会返回修改后的目标对象<br>console.log(dest &#x3D;&#x3D;&#x3D; result); &#x2F;&#x2F; true<br>console.log(dest !&#x3D;&#x3D; src); &#x2F;&#x2F; true<br>console.log(result); &#x2F;&#x2F; { id: src }<br>console.log(dest); &#x2F;&#x2F; { id: src }<br>&#x2F;</em>*</p>
<p>多个源对象<br><em>&#x2F;<br>dest &#x3D; {};<br>result &#x3D; Object.assign(dest, { a: ‘foo’ }, { b: ‘bar’ });<br>console.log(result); &#x2F;&#x2F; { a: foo, b: bar }<br>&#x2F;</em>*</p>
<p>获取函数与设置函数<br>*&#x2F;<br>dest &#x3D; {<br>  set a(val) {<br>      console.log(<code>Invoked dest setter with param $&#123;val&#125;</code>);<br>  }<br>};<br>src &#x3D; {<br>  get a() {<br>      console.log(‘Invoked src getter’);<br>      return ‘foo’;<br>  }<br>};<br>Object.assign(dest, src);<br>&#x2F;&#x2F; 调用src 的获取方法<br>&#x2F;&#x2F; 调用dest 的设置方法并传入参数”foo”<br>&#x2F;&#x2F; 因为这里的设置函数不执行赋值操作<br>&#x2F;&#x2F; 所以实际上并没有把值转移过来<br>console.log(dest); &#x2F;&#x2F; { set a(val) {…} }</p>
<h3 id="对象标识及相等判定-Object-is"><a href="#对象标识及相等判定-Object-is" class="headerlink" title="对象标识及相等判定(Object.is())"></a>对象标识及相等判定(Object.is())</h3><p>在ECMAScript 6 之前，有些特殊情况即使是&#x3D;&#x3D;&#x3D;操作符也无能为力：</p>
<p>&#x2F;&#x2F; 这些情况在不同JavaScript 引擎中表现不同，但仍被认为相等<br>console.log(+0 &#x3D;&#x3D;&#x3D; -0); &#x2F;&#x2F; true<br>console.log(+0 &#x3D;&#x3D;&#x3D; 0); &#x2F;&#x2F; true<br>console.log(-0 &#x3D;&#x3D;&#x3D; 0); &#x2F;&#x2F; true<br>&#x2F;&#x2F; 要确定NaN 的相等性，必须使用极为讨厌的isNaN()<br>console.log(NaN &#x3D;&#x3D;&#x3D; NaN); &#x2F;&#x2F; false<br>console.log(isNaN(NaN)); &#x2F;&#x2F; true</p>
<p>为改善这类情况，ECMAScript 6 规范新增了Object.is()，这个方法与&#x3D;&#x3D;&#x3D;很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：</p>
<p>&#x2F;&#x2F; 正确的0、-0、+0 相等&#x2F;不等判定<br>console.log(Object.is(+0, -0)); &#x2F;&#x2F; false<br>console.log(Object.is(+0, 0)); &#x2F;&#x2F; true<br>console.log(Object.is(-0, 0)); &#x2F;&#x2F; false<br>&#x2F;&#x2F; 正确的NaN 相等判定<br>console.log(Object.is(NaN, NaN)); &#x2F;&#x2F; true<br>要检查超过两个值，递归地利用相等性传递即可：<br>function recursivelyCheckEqual(x, …rest) {<br>    return Object.is(x, rest[0]) &amp;&amp;<br>        (rest.length &lt; 2 || recursivelyCheckEqual(…rest));<br>}</p>
<h3 id="解构赋值（略）"><a href="#解构赋值（略）" class="headerlink" title="解构赋值（略）"></a>解构赋值（略）</h3><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。</p>
<p>例：<br>function createPerson(name, age, job) {<br>    let o &#x3D; new Object();<br>    o.name &#x3D; name;<br>    o.age &#x3D; age;<br>    o.job &#x3D; job;<br>    o.sayName &#x3D; function() {<br>        console.log(this.name);<br>    };<br>    return o;<br>}<br>let person1 &#x3D; createPerson(“Nicholas”, 29, “Software Engineer”);<br>let person2 &#x3D; createPerson(“Greg”, 27, “Doctor”);</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>前面的例子使用构造函数模式可以这样写：<br>function Person(name, age, job){<br>    this.name &#x3D; name;<br>    this.age &#x3D; age;<br>    this.job &#x3D; job;<br>    this.sayName &#x3D; function() {<br>        console.log(this.name);<br>    };<br>}<br>let person1 &#x3D; <strong>new</strong> Person(“Nicholas”, 29, “Software Engineer”);<br>let person2 &#x3D; <strong>new</strong> Person(“Greg”, 27, “Doctor”);<br>person1.sayName(); &#x2F;&#x2F; Nicholas<br>person2.sayName(); &#x2F;&#x2F; Greg</p>
<p>要创建Person 的实例，应使用new 操作符。以这种方式调用构造函数会执行如下操作。<br>(1) 在内存中创建一个新对象。<br>(2) 这个新对象内部的[[<strong>Prototype</strong>]]特性被赋值为构造函数的<strong>prototype</strong> 属性。<br>(3) 构造函数内部的<strong>this</strong> <strong>被赋值为这个新对象</strong>（即this 指向新对象）。<br>(4) 执行构造函数内部的代码（给新对象添加属性）。<br>(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p>
<p>person1 和person2 分别保存着Person 的不同实例。这两个对象都有一个<br>constructor 属性指向Person，如下所示：<br>console.log(person1.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F; true<br>console.log(person2.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F; true</p>
<p><strong>constructor</strong> 本来是用于标识对象类型的。不过，一般认为<strong>instanceof 操作符是确定对象类型更可靠的方式。</strong>前面例子中的每个对象都是Object 的实例，同时也是Person 的实例，如下面调用instanceof 操作符的结果所示：<br>console.log(person1 instanceof Object); &#x2F;&#x2F; true<br>console.log(person1 instanceof Person); &#x2F;&#x2F; true<br>console.log(person2 instanceof Object); &#x2F;&#x2F; true<br>console.log(person2 instanceof Person); &#x2F;&#x2F; true</p>
<p>如果不想传参数，那么构造函数后面的括号可加可不加。只要有new 操作符，就可以调用相应的构造函数</p>
<p><strong>构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new 操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数</strong></p>
<h3 id="原型模式（Object-getPrototypeOf-，Object-setPrototypeOf，Object-create-）"><a href="#原型模式（Object-getPrototypeOf-，Object-setPrototypeOf，Object-create-）" class="headerlink" title="原型模式（Object.getPrototypeOf()，Object.setPrototypeOf，Object.create()）"></a>原型模式（Object.getPrototypeOf()，Object.setPrototypeOf，Object.create()）</h3><p>每个函数都会创建一个<strong>prototype 属性，</strong>这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型，如下所示：</p>
<p>function Person() {  }<br>Person.prototype.name &#x3D; “Nicholas”;<br>Person.prototype.age &#x3D; 29;<br>Person.prototype.job &#x3D; “Software Engineer”;<br>Person.prototype.sayName &#x3D; function() {<br>    console.log(this.name);<br>};<br>let person1 &#x3D; new Person();<br>person1.sayName(); &#x2F;&#x2F; “Nicholas”<br>let person2 &#x3D; new Person();<br>person2.sayName(); &#x2F;&#x2F; “Nicholas”<br>console.log(person1.sayName &#x3D;&#x3D; person2.sayName); &#x2F;&#x2F; true</p>
<p>ECMAScript 的Object 类型有一个方法叫Object.getPrototypeOf()，返回参数的内部特性<br>[[Prototype]]的值。例如：<br>console.log(Object.getPrototypeOf(person1) &#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true<br>console.log(Object.getPrototypeOf(person1).name); &#x2F;&#x2F; “Nicholas”<br>第一行代码简单确认了Object.getPrototypeOf()返回的对象就是传入对象的原型对象。第二行代码则取得了原型对象上name 属性的值，即”Nicholas”。使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在通过原型实现继承时显得尤为重要。</p>
<p>Object 类型还有一个setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系：<br>let biped &#x3D; {<br>    numLegs: 2<br>};<br>let person &#x3D; {<br>    name: ‘Matt’<br>};<br>Object.setPrototypeOf(person, biped);<br>console.log(person.name); &#x2F;&#x2F; Matt<br>console.log(person.numLegs); &#x2F;&#x2F; 2<br>console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; biped); &#x2F;&#x2F; true</p>
<p><strong><u>Object.setPrototypeOf()可能会严重影响代码性能</u></strong></p>
<p>为避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过**Object.create()**来创建一个新对象，同时为其指定原型。</p>
<h4 id="For-in"><a href="#For-in" class="headerlink" title="For-in"></a>For-in</h4><p>在for-in 循环中使用in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（[[Enumerable]]特性被设置为false）属性的实例属性也会在for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。<br>要获得对象上所有可枚举的实例属性，可以使用Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。比如：<br>function Person() {}<br>Person.prototype.name &#x3D; “Nicholas”;<br>Person.prototype.age &#x3D; 29;<br>Person.prototype.job &#x3D; “Software Engineer”;<br>Person.prototype.sayName &#x3D; function() {<br>    console.log(this.name);<br>};<br>let keys &#x3D; Object.keys(Person.prototype);<br>console.log(keys); &#x2F;&#x2F; “name,age,job,sayName”<br>let p1 &#x3D; new Person();<br>p1.name &#x3D; “Rob”;<br>p1.age &#x3D; 31;<br>let p1keys &#x3D; Object.keys(p1);<br>console.log(p1keys); &#x2F;&#x2F; “[name,age]”</p>
<p>这里，<strong>keys 变量保存的数组中包含”name”、”age”、”job”和”sayName”。</strong>这是正常情况下通过for-in 返回的顺序。而在Person 的实例上调用时，<strong>Object.keys()返回的数组中只包含”name”和”age”两个属性。</strong>如果想列出所有实例属性，无论是否可以枚举，都可以使用**Object.getOwnPropertyNames()**：</p>
<p>let keys &#x3D; Object.getOwnPropertyNames(Person.prototype);<br>console.log(keys); &#x2F;&#x2F; “[constructor,name,age,job,sayName]”</p>
<h3 id="对象迭代-Object-values-Object-entries"><a href="#对象迭代-Object-values-Object-entries" class="headerlink" title="对象迭代(Object.values(),Object.entries())"></a>对象迭代(Object.values(),Object.entries())</h3><p>这两个静态方法Object.values()和Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键&#x2F;值对的数组。<br>下面的示例展示了这两个方法：<br>const o &#x3D; {<br>    foo: ‘bar’,<br>    baz: 1,<br>    qux: {}<br>};<br>console.log(Object.values(o)); &#x2F;&#x2F; [“bar”, 1, {}]<br>console.log(Object.entries((o)));&#x2F;&#x2F; [[“foo”, “bar”], [“baz”, 1], [“qux”, {}]]<br><strong>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制, 符号属性会被忽略</strong></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>实现继承是ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有<br>一个属性指回构造函数，而实例有一个内部指针指向原型，<strong>如下</strong>：</p>
<p>在 JavaScript 中，每个构造函数都有一个 <code>prototype</code> 属性，这个属性是一个对象，称为“原型对象”。原型对象中有一个特殊的属性 <code>constructor</code>，它指回构造函数本身。同时，每个通过构造函数创建的实例对象都有一个内部属性（通常表示为 <code>[[Prototype]]</code>），这个内部属性指向构造函数的原型对象。</p>
<p>假设我们有一个构造函数 <code>Person</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个构造函数中，<code>Person.prototype</code> 是一个对象，它有一个 <code>constructor</code> 属性，指向 <code>Person</code> 构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>

<p>当我们使用 <code>new</code> 关键字创建 <code>Person</code> 的实例时，JavaScript 会执行以下步骤：</p>
<ol>
<li>创建一个新对象。</li>
<li>将新对象的 <code>[[Prototype]]</code> 内部属性设置为 <code>Person.prototype</code>。</li>
<li>执行构造函数，将 <code>this</code> 绑定到新对象。</li>
<li>返回新对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>在 <code>person1</code> 这个实例对象中，有一个内部指针 <code>[[Prototype]]</code> 指向 <code>Person.prototype</code>。虽然这个内部指针在 JavaScript 中不能直接访问，但可以通过 <code>Object.getPrototypeOf</code> 方法来查看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>

<p>通过原型链，实例对象可以访问原型对象上的属性和方法。例如，如果我们在 <code>Person.prototype</code> 上定义一个方法 <code>sayHello</code>，那么所有 <code>Person</code> 的实例都可以访问这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I am <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is Alice and I am 30 years old.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>构造函数</strong>：<code>Person</code>。</li>
<li><strong>原型对象</strong>：<code>Person.prototype</code>。</li>
<li><strong>原型对象的 <code>constructor</code> 属性</strong>：<code>Person.prototype.constructor</code> 指回 <code>Person</code>。</li>
<li><strong>实例对象</strong>：<code>person1</code>。</li>
<li><strong>实例对象的内部指针</strong>：<code>person1</code> 的 <code>[[Prototype]]</code> 指向 <code>Person.prototype</code>。</li>
</ul>
<p>通过这种方式，JavaScript 实现了基于原型的继承机制。每个实例对象都可以访问其构造函数原型对象上的属性和方法，从而实现了代码的复用和继承。</p>
<h3 id="盗用构造函数-继承"><a href="#盗用构造函数-继承" class="headerlink" title="盗用构造函数(继承)"></a>盗用构造函数(继承)</h3><p>基本思路：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和call()方法以新创建的对象为上下文执行构造函数。</p>
<p>function SuperType() {<br>    this.colors &#x3D; [“red”, “blue”, “green”];<br>}<br>function SubType() {<br>    <strong>&#x2F;&#x2F; 继承SuperType</strong><br>    <strong>SuperType.call(this);</strong><br>}<br>let instance1 &#x3D; new SubType();<br>instance1.colors.push(“black”);<br>console.log(instance1.colors); &#x2F;&#x2F; “red,blue,green,black”<br>let instance2 &#x3D; new SubType();<br>console.log(instance2.colors); &#x2F;&#x2F; “red,blue,green”</p>
<p>示例中加粗的代码展示了盗用构造函数的调用。通过使用call()（或apply()）方法，SuperType构造函数在为SubType 的实例创建的新对象的上下文中执行了。这相当于新的SubType 对象上运行了SuperType()函数中的所有初始化代码。结果就是每个实例都会有自己的colors 属性。</p>
<p>相比于使用原型链，盗用构造函数的<strong>一个优点就是可以在子类构造函数中向父类构造函数传参</strong>。来看下面的例子：<br>function SuperType(name){<br>    this.name &#x3D; name;<br>}<br>function SubType() {<br>    &#x2F;&#x2F; 继承SuperType 并传参<br>    SuperType.call(this, “Nicholas”);<br>    &#x2F;&#x2F; 实例属性<br>    this.age &#x3D; 29;<br>}<br>let instance &#x3D; new SubType();<br>console.log(instance.name); &#x2F;&#x2F; “Nicholas”;<br>console.log(instance.age); &#x2F;&#x2F; 29<br>在这个例子中，SuperType 构造函数接收一个参数name，然后将它赋值给一个属性。在SubType构造函数中调用SuperType 构造函数时传入这个参数，实际上会在SubType 的实例上定义name 属性。为确保SuperType 构造函数不会覆盖SubType 定义的属性，可以在调用父类构造函数之后再给子类实例添加额外的属性。</p>
<p>主要缺点，也是使用构造函数模式自定义类型的问题：<strong>必须在构造函数中定义方法，因此函数不能重用</strong>。此外，<strong>子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式</strong>。由于存在这些问题，盗用构造函数基本上也不能单独使用。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承（有时候也叫伪经典继承）<strong>综合了原型链和盗用构造函数</strong>，将两者的优点集中了起来。基本的思路是使用<strong>原型链继承原型上的属性和方法</strong>，而通过<strong>盗用构造函数继承实例属性</strong>。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。例如：</p>
<p>function SuperType(name){<br>    this.name &#x3D; name;<br>    this.colors &#x3D; [“red”, “blue”, “green”];<br>}<br>SuperType.prototype.sayName &#x3D; function() {<br>    console.log(this.name);<br>};<br>function SubType(name, age){<br>    &#x2F;&#x2F; 继承属性<br>    <strong>SuperType.call(this, name);</strong><br>    this.age &#x3D; age;<br>}<br>&#x2F;&#x2F; 继承方法<br><strong>SubType.prototype &#x3D; new SuperType();</strong><br>SubType.prototype.sayAge &#x3D; function() {<br>    console.log(this.age);<br>};<br>let instance1 &#x3D; new SubType(“Nicholas”, 29);<br>instance1.colors.push(“black”);<br>console.log(instance1.colors); &#x2F;&#x2F; “red,blue,green,black”<br>instance1.sayName(); &#x2F;&#x2F; “Nicholas”;<br>instance1.sayAge(); &#x2F;&#x2F; 29<br>let instance2 &#x3D; new SubType(“Greg”, 27);<br>console.log(instance2.colors); &#x2F;&#x2F; “red,blue,green”<br>instance2.sayName(); &#x2F;&#x2F; “Greg”;<br>instance2.sayAge(); &#x2F;&#x2F; 27</p>
<p>组合继承弥补了原型链和盗用构造函数的不足，是JavaScript 中使用最多的继承模式。而且组合继承也保留了instanceof 操作符和isPrototypeOf()方法识别合成对象的能力。</p>
<h3 id="原型式继承（-Object-create-）"><a href="#原型式继承（-Object-create-）" class="headerlink" title="原型式继承（**Object.create()**）"></a>原型式继承（**Object.create()**）</h3><p>一种不涉及严格意义上构造函数的继承方法，例如：</p>
<p>function object(o) {<br>    function F() {}<br>    F.prototype &#x3D; o;<br>    return new F();<br>}<br>这个object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制。来看下面的例子：</p>
<p>let person &#x3D; {<br>    name: “Nicholas”,<br>    friends: [“Shelby”, “Court”, “Van”]<br>};<br>let anotherPerson &#x3D; object(person);<br>anotherPerson.name &#x3D; “Greg”;<br>anotherPerson.friends.push(“Rob”);<br>let yetAnotherPerson &#x3D; object(person);<br>yetAnotherPerson.name &#x3D; “Linda”;<br>yetAnotherPerson.friends.push(“Barbie”);<br>console.log(person.friends); &#x2F;&#x2F; “Shelby,Court,Van,Rob,Barbie”</p>
<p>原型式继承适用于这种情况：<strong>有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给object()，然后再对返回的对象进行适当修改。</strong></p>
<p>在这个例子中，person 对象定义了另一个对象也应该共享的信息，把它传给object()之后会返回一个新对象。这个新对象的原型是person，意味着它的原型上既有原始值属性又有引用值属性。这也意味着person.friends 不仅是person 的属性，也会跟anotherPerson 和yetAnotherPerson 共享。这里实际上克隆了两个person。</p>
<p>ECMAScript 5 通过增加**Object.create()**方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。Object.create()的第二个参数与Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），是Crockford 首倡的一种模式。<strong>寄生式继承背后的思路类似于寄生构造函数和工厂模式</strong>：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：</p>
<p>function createAnother(original){<br>    let clone &#x3D; object(original); &#x2F;&#x2F; 通过调用函数创建一个新对象<br>    clone.sayHi &#x3D; function() { &#x2F;&#x2F; 以某种方式增强这个对象<br>        console.log(“hi”);<br>    };<br>    return clone; &#x2F;&#x2F; 返回这个对象<br>}</p>
<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。再来看一看这个组合继承的例子：</p>
<p>function SuperType(name) {<br>    this.name &#x3D; name;<br>    this.colors &#x3D; [“red”, “blue”, “green”];<br>}<br>SuperType.prototype.sayName &#x3D; function() {<br>    console.log(this.name);<br>};<br>function SubType(name, age){<br>    SuperType.call(this, name); &#x2F;&#x2F; 第二次调用SuperType()<br>    this.age &#x3D; age;<br>}<br>SubType.prototype &#x3D; new SuperType(); &#x2F;&#x2F; 第一次调用SuperType()<br>SubType.prototype.constructor &#x3D; SubType;<br>SubType.prototype.sayAge &#x3D; function() {<br>    console.log(this.age);<br>};</p>
<p>代码中加粗的部分是调用SuperType 构造函数的地方。在上面的代码执行后，SubType.prototype上会有两个属性：name 和colors。它们都是SuperType 的实例属性，但现在成为了SubType 的原型属性。在调用SubType 构造函数时，也会调用SuperType 构造函数，这一次会在新对象上创建实例属性name 和colors。这两个实例属性会遮蔽原型上同名的属性。</p>
<h2 id="类-class（该处略写）"><a href="#类-class（该处略写）" class="headerlink" title="类 class（该处略写）"></a>类 class（该处略写）</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>与函数类型相似，定义类也有两种主要方式：<strong>类声明</strong>和<strong>类表达式</strong>。这<strong>两种方式都使用class 关键字加大括号</strong>：</p>
<p>&#x2F;&#x2F; 类声明<br>class Person {}<br>&#x2F;&#x2F; 类表达式<br>const Animal &#x3D; class {};</p>
<p>类的构成<br>类可以包含<strong>构造函数方法</strong>、<strong>实例方法</strong>、<strong>获取函数</strong>、<strong>设置函数</strong>和<strong>静态类方法</strong>，但这些都<strong>不是</strong>必需的。<strong>空的类定义照样有效</strong>。默认情况下，类定义中的代码都在严格模式下执行。</p>
<p>&#x2F;&#x2F; 空类定义，有效<br>class Foo {}<br>&#x2F;&#x2F; 有构造函数的类，有效<br>class Bar {<br>    constructor() {}<br>}<br>&#x2F;&#x2F; 有获取函数的类，有效<br>class Baz {<br>    get myBaz() {}<br>}<br>&#x2F;&#x2F; 有静态方法的类，有效<br>class Qux {<br>    static myQux() {}<br>}</p>
<h3 id="类构造函数（constructor）"><a href="#类构造函数（constructor）" class="headerlink" title="类构造函数（constructor）"></a>类构造函数（constructor）</h3><p><strong>constructor 关键字</strong>用于在类定义块内部创建类的构造函数。方法名constructor 会告诉解释器在使用new 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p>
<p>1.实例化<br>使用new 操作符实例化Person 的操作等于使用new 调用其构造函数。唯一可感知的不同之处就是，JavaScript 解释器知道使用new 和类意味着应该使用constructor 函数进行实例化。</p>
<p><strong>使用new 调用类的构造函数会执行如下操作。</strong><br>(1) 在内存中创建一个新对象。<br>(2) 这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype 属性。<br>(3) 构造函数内部的this 被赋值为这个新对象（即this 指向新对象）。<br>(4) 执行构造函数内部的代码（给新对象添加属性）。<br>(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p>
<p>例子：<br>class Animal {}<br>class Person {<br>    constructor() {<br>        console.log(‘person ctor’);<br>    }<br>}<br>class Vegetable {<br>    constructor() {<br>        this.color &#x3D; ‘orange’;<br>    }<br>}<br>let a &#x3D; new Animal();<br>let p &#x3D; new Person(); &#x2F;&#x2F; person ctor<br>let v &#x3D; new Vegetable();<br>console.log(v.color); &#x2F;&#x2F; orange</p>
<p>2.把类当成特殊函数<br>ECMAScript 中没有正式的类这个类型。从各方面来看，ECMAScript <strong>类就是一种特殊函数</strong>。声明一个类之后，通过typeof 操作符检测类标识符，表明它是一个函数：</p>
<p>class Person {}<br>console.log(Person); &#x2F;&#x2F; class Person {}<br>console.log(typeof Person); &#x2F;&#x2F; function</p>
<p>类标识符<strong>有prototype 属性</strong>，而<strong>这个原型也有一个constructor 属性指向类自身。</strong>与普通构造函数一样，可以使用<strong>instanceof 操作符检查构造函数原型是否存在于实例的原型链中</strong>。</p>
<h3 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h3><p>类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p>
<h3 id="继承（extends，super-）"><a href="#继承（extends，super-）" class="headerlink" title="继承（extends，super()）"></a>继承（extends，super()）</h3><p>本章前面花了大量篇幅讨论如何使用ES5 的机制实现继承。ECMAScript 6 新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p>
<p>ES6 类支持单继承。使用extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）：</p>
<p>class Vehicle {}<br>&#x2F;&#x2F; 继承类<br>class Bus extends Vehicle {}<br>let b &#x3D; new Bus();<br>console.log(b instanceof Bus); &#x2F;&#x2F; true<br>console.log(b instanceof Vehicle); &#x2F;&#x2F; true<br>function Person() {}<br>&#x2F;&#x2F; 继承普通构造函数<br>class <strong>Engineer</strong> extends Person {}<br><strong>let e &#x3D; new Engineer();</strong><br>console.log(e instanceof Engineer); &#x2F;&#x2F; true<br>console.log(e instanceof Person); &#x2F;&#x2F; true</p>
<p><strong>extends</strong> 关键字也可以在类表达式中使用，因此let Bar &#x3D; class extends Foo {}<br>是有效的语法。</p>
<p>构造函数、HomeObject 和super()</p>
<p>派生类的方法可以通过super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super 可以调用父类构造函数。<br>class Vehicle {<br>    constructor() {<br>        this.hasEngine &#x3D; true;<br>    }<br>}<br>class Bus extends Vehicle {<br>    constructor() {<br>        <strong>&#x2F;&#x2F; 不要在调用super()之前引用this，否则会抛出ReferenceError</strong><br>        <strong>super(); &#x2F;&#x2F; 相当于super.constructor()</strong><br>        console.log(this instanceof Vehicle);   &#x2F;&#x2F; true<br>        console.log(this);   &#x2F;&#x2F; Bus { hasEngine: true }<br>    }<br>}<br>new Bus();</p>
<p>在静态方法中可以通过super 调用继承的类上定义的静态方法：<br>class Vehicle {<br>    static identify() {<br>        console.log(‘vehicle’);<br>    }<br>}<br>class Bus extends Vehicle {<br>    static identify() {<br>        super.identify();<br>    }<br>}<br>Bus.identify(); &#x2F;&#x2F; vehicle</p>
<p>ES6 给类构造函数和静态方法添加了内部特性**[[HomeObject]]，这个特性是一个**<br><strong>指针，指向定义该方法的对象。</strong>这个指针是自动赋值的，而且只能在JavaScript 引擎内部访问。super 始终会定义为[[HomeObject]]的原型。</p>
<p>在使用super 时要注意几个问题：<br> super 只能在派生类构造函数和静态方法中使用。<br> 不能单独引用super 关键字，要么用它调用构造函数，要么用它引用静态方法。<br> 调用super()会调用父类构造函数，并将返回的实例赋值给this。<br> super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。<br> 如果没有定义类构造函数，在实例化派生类时会调用super()，而且会传入所有传给派生类的参数。<br> 在类构造函数中，不能在调用super()之前引用this。<br> 如果在派生类中显式定义了构造函数，则要么必须在其中调用super()，要么必须在其中返回一个对象。</p>
<p>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然ECMAScript 没有专门支持这种类的语法 ，但通过<strong>new.target</strong> 也很容易实现。new.target 保存通过new 关键字调用的类或函数。通过在实例化时检测new.target 是不是抽象基类，可以阻止对抽象基类的实例化：（这部分略写）</p>
<p>&#x2F;&#x2F; 抽象基类<br>class Vehicle {<br>    constructor() {<br>        console.log(new.target);<br>        if (new.target &#x3D;&#x3D;&#x3D; Vehicle) {<br>            throw new Error(‘Vehicle cannot be directly instantiated’);<br>        }<br>    }<br>}<br>&#x2F;&#x2F; 派生类<br>class Bus extends Vehicle {}<br>new Bus(); &#x2F;&#x2F; class Bus {}<br>new Vehicle(); &#x2F;&#x2F; class Vehicle {}<br>&#x2F;&#x2F; Error: Vehicle cannot be directly instantiated</p>
<h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>代理是ECMAScript 6 新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的JavaScript 元编程及抽象的新天地。</p>
<p>从宏观上看，代理是真实JavaScript 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是<strong>遵从捕获器不变式。</strong></p>
<p>与代理如影随形的反射API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射API看作一套基本操作，这些操作是绝大部分JavaScript 对象API 的基础。</p>
<p>代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。</p>
<p>ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，<strong>可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。</strong></p>
<h2 id="Proxy的基本概念"><a href="#Proxy的基本概念" class="headerlink" title="Proxy的基本概念"></a>Proxy的基本概念</h2><p>来自知乎：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/674933571">JavaScript之Proxy详解 - 知乎</a></p>
<h2 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h2><p>代理是目标对象的抽象。从很多方面看，<strong>代理类似C++指针</strong>，因为它<strong>可以</strong><br><strong>用作目标对象的替身，但又完全独立于目标对象</strong>。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。<br>(但是实际上：ECMAScript 代理与C++指针有重大区别)</p>
<h3 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h3><p>代理是使用<strong>Proxy 构造函数</strong>创建的。这个构造函数接收<strong>两个参数：目标对象和处理程序对象</strong>。缺少其中任何一个参数都会抛出TypeError。</p>
<p>如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。<br>const target &#x3D; {<br>    id: ‘target’<br>};<br>const handler &#x3D; {};<br><strong>const proxy &#x3D; new Proxy(target, handler);</strong></p>
<p><strong>&#x2F;&#x2F; id 属性会访问同一个值</strong><br>console.log(target.id); &#x2F;&#x2F; target<br>console.log(proxy.id); &#x2F;&#x2F; target</p>
<p><strong>&#x2F;&#x2F; 给目标属性赋值会反映在两个对象上</strong><br><strong>&#x2F;&#x2F; 因为两个对象访问的是同一个值</strong><br>target.id &#x3D; ‘foo’;<br>console.log(target.id); &#x2F;&#x2F; foo<br>console.log(proxy.id); &#x2F;&#x2F; foo</p>
<p><strong>&#x2F;&#x2F; 给代理属性赋值会反映在两个对象上</strong><br><strong>&#x2F;&#x2F; 因为这个赋值会转移到目标对象</strong><br>proxy.id &#x3D; ‘bar’;<br>console.log(target.id); &#x2F;&#x2F; bar<br>console.log(proxy.id); &#x2F;&#x2F; bar</p>
<p><strong>&#x2F;&#x2F; hasOwnProperty()方法在两个地方</strong><br><strong>&#x2F;&#x2F; 都会应用到目标对象</strong><br>console.log(target.hasOwnProperty(‘id’)); &#x2F;&#x2F; true<br>console.log(proxy.hasOwnProperty(‘id’)); &#x2F;&#x2F; true</p>
<p><strong>&#x2F;&#x2F; Proxy.prototype 是undefined</strong><br><strong>&#x2F;&#x2F; 因此不能使用instanceof 操作符</strong><br>console.log(target instanceof Proxy); &#x2F;&#x2F; TypeError: Function has non-object prototype ‘undefined’ in instanceof check<br>console.log(proxy instanceof Proxy); &#x2F;&#x2F; TypeError: Function has non-object prototype ‘undefined’ in instanceof check</p>
<p><strong>&#x2F;&#x2F; 严格相等可以用来区分代理和目标</strong><br>console.log(target &#x3D;&#x3D;&#x3D; proxy); &#x2F;&#x2F; false</p>
<h3 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h3><p>使用代理的<strong>主要目的是可以定义捕获器（trap）</strong>。<strong>捕获器就是在处理程序对象中定义的“基本操作的拦截器”。</strong>每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。<strong>每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</strong></p>
<p>例如，可以<strong>定义一个get()捕获器</strong>，在ECMAScript 操作以某种形式调用get()时触发。下面的例子定义了一个get()捕获器：<br>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    &#x2F;&#x2F; 捕获器在处理程序对象中以方法名为键<br>    <strong>get() {</strong><br>        <strong>return ‘handler override’;</strong><br>    <strong>}</strong><br>};<br>const proxy &#x3D; new Proxy(target, handler);</p>
<p>这样，当通过代理对象执行get()操作时，就会触发定义的get()捕获器。get()不是<br>ECMAScript 对象可以调用的方法。这个操作在JavaScript 代码中可以通过多种形式触发并被get()捕获器拦截到。proxy[property]、proxy.property 或Object.create(proxy)[property]等操作都会触发基本的get()操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发get()捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。</p>
<h3 id="捕获器参数和反射API（捕获器-get-反射API-Reflect）"><a href="#捕获器参数和反射API（捕获器-get-反射API-Reflect）" class="headerlink" title="捕获器参数和反射API（捕获器:get(),反射API:Reflect）"></a>捕获器参数和反射API（捕获器:get(),反射API:Reflect）</h3><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到<strong>目标对象</strong>、<strong>要查询的属性</strong>和<strong>代理对象</strong>三个参数。</p>
<p>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    get(trapTarget, property, receiver) {<br>        console.log(trapTarget &#x3D;&#x3D;&#x3D; target);<br>        console.log(property);<br>        console.log(receiver &#x3D;&#x3D;&#x3D; proxy);<br>    }<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>proxy.foo;<br>&#x2F;&#x2F; true<br>&#x2F;&#x2F; foo<br>&#x2F;&#x2F; true</p>
<p><strong>有了这些参数，就可以重建被捕获方法的原始行为：</strong></p>
<p>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    get(trapTarget, property, receiver) {<br>        return trapTarget[property];<br>    }<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>console.log(proxy.foo); &#x2F;&#x2F; bar<br>console.log(target.foo); &#x2F;&#x2F; bar</p>
<p>处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。使用反射API 也可以像下面这样定义出空代理对象：</p>
<p>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    get() {<br>        <strong>return Reflect.get(…arguments);</strong><br>    }<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>console.log(proxy.foo); &#x2F;&#x2F; bar<br>console.log(target.foo); &#x2F;&#x2F; bar</p>
<p>甚至还可以写得更简洁一些：<br>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    get: Reflect.get<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>console.log(proxy.foo); &#x2F;&#x2F; bar<br>console.log(target.foo); &#x2F;&#x2F; bar</p>
<p>事实上，<strong>如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射API 的空代理，那么甚至不需要定义处理程序对象</strong>：</p>
<p>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const proxy &#x3D; new Proxy(target, Reflect);<br>console.log(proxy.foo); &#x2F;&#x2F; bar<br>console.log(target.foo); &#x2F;&#x2F; bar</p>
<p>反射API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。</p>
<h3 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h3><p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。<br>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出TypeError：</p>
<p>const target &#x3D; {};<br>Object.defineProperty(target, ‘foo’, {<br>    configurable: false,<br>    writable: false,<br>    value: ‘bar’<br>});<br>const handler &#x3D; {<br>    get() {<br>        return ‘qux’;<br>    }<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>console.log(proxy.foo);<br>&#x2F;&#x2F; TypeError</p>
<h3 id="可撤销代理（revocable-方法）"><a href="#可撤销代理（revocable-方法）" class="headerlink" title="可撤销代理（revocable()方法）"></a>可撤销代理（revocable()方法）</h3><p>有时候可能需要中断代理对象与目标对象之间的联系。Proxy 暴露了<strong>revocable()方法</strong>，这个方法支持<strong>撤销代理对象与目标对象的关联</strong>。撤销代理的<br>操作是<strong>不可逆</strong>的。而且，<strong>撤销函数（revoke()）是幂等的</strong>，调用多少次的结果都一样。撤销代理之后再调用代理会抛出TypeError。</p>
<p><strong>撤销函数和代理对象是在实例化时同时生成</strong>的：<br>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    get() {<br>        return ‘intercepted’;<br>    }<br>};<br>const { proxy, revoke } &#x3D; Proxy.revocable(target, handler);<br>console.log(proxy.foo); &#x2F;&#x2F; intercepted<br>console.log(target.foo); &#x2F;&#x2F; bar<br>revoke();<br>console.log(proxy.foo); &#x2F;&#x2F; TypeError</p>
<h3 id="实用反射API"><a href="#实用反射API" class="headerlink" title="实用反射API"></a>实用反射API</h3><p>某些情况下应该优先使用反射API。</p>
<h5 id="1-反射API-与对象API"><a href="#1-反射API-与对象API" class="headerlink" title="1  反射API 与对象API"></a>1  反射API 与对象API</h5><p>在使用反射API 时，要记住：<br>(1) 反射API 并不限于捕获处理程序；<br>(2) 大多数反射API 方法在Object 类型上有对应的方法。<br>通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。</p>
<h5 id="2-状态标记"><a href="#2-状态标记" class="headerlink" title="2  状态标记"></a>2  状态标记</h5><p>很多反射方法返回称作“<strong>状态标记</strong>”的布尔值，表示意图执行的操作是否成功。有时候，<strong>状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射API 方法更有用</strong>。例如，可以使用反射API 对下面的代码进行重构：</p>
<p>&#x2F;&#x2F; 初始代码<br>const o &#x3D; {};<br>try {<br>    Object.defineProperty(o, ‘foo’, ‘bar’);<br>    console.log(‘success’);<br>} catch(e) {<br>    console.log(‘failure’);<br>}</p>
<p>在定义新属性时如果发生问题，Reflect.defineProperty()会返回false，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：<br>&#x2F;&#x2F; 重构后的代码<br>const o &#x3D; {};<br>if(Reflect.defineProperty(o, ‘foo’, {value: ‘bar’})) {<br>    console.log(‘success’);<br>} else {<br>    console.log(‘failure’);<br>}</p>
<p>以下反射方法都会提供状态标记：<br><strong> Reflect.defineProperty()</strong><br><strong> Reflect.preventExtensions()</strong><br><strong> Reflect.setPrototypeOf()</strong><br><strong> Reflect.set()</strong><br><strong> Reflect.deleteProperty()</strong></p>
<h5 id="3-用一等函数替代操作符"><a href="#3-用一等函数替代操作符" class="headerlink" title="3  用一等函数替代操作符"></a>3  用一等函数替代操作符</h5><p>以下反射方法提供只有<strong>通过操作符才能完成</strong>的操作。<br><strong> Reflect.get()：可以替代对象属性访问操作符。</strong><br><strong> Reflect.set()：可以替代&#x3D;赋值操作符。</strong><br><strong> Reflect.has()：可以替代in 操作符或with()。</strong><br><strong> Reflect.deleteProperty()：可以替代delete 操作符。</strong><br><strong> Reflect.construct()：可以替代new 操作符。</strong></p>
<h5 id="4-安全地应用函数"><a href="#4-安全地应用函数" class="headerlink" title="4  安全地应用函数"></a>4  安全地应用函数</h5><p>在通过apply 方法调用函数时，被调用的函数可能也定义了自己的apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在Function 原型上的apply 方法：</p>
<p><strong>Function.prototype.apply.call(myFunc, thisVal, argumentList);</strong></p>
<p>可怕的代码完全可以<strong>使用Reflect.apply 来避免</strong>：<br><strong>Reflect.apply(myFunc, thisVal, argumentsList);</strong></p>
<h3 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h3><p>代理可以拦截反射API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：</p>
<p>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const firstProxy &#x3D; new Proxy(<strong>target</strong>, {<br>    get() {<br>        console.log(‘first proxy’);<br>        <strong>return Reflect.get(…arguments);</strong><br>    }<br>});<br>const secondProxy &#x3D; new Proxy(<strong>firstProxy</strong>, {<br>    get() {<br>        console.log(‘second proxy’);<br>        <strong>return Reflect.get(…arguments);</strong><br>    }<br>});<br>console.log(secondProxy.foo);<br>&#x2F;&#x2F; second proxy<br>&#x2F;&#x2F; first proxy<br>&#x2F;&#x2F; bar</p>
<h3 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h3><p>代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的ECMAScript机制很好地协同。</p>
<p>1  代理中的this<br>代理潜在的一个问题来源是this 值。我们知道，方法中的this 通常指向调用这个方法的对象。</p>
<p>2  代理与内部槽位<br>代理与内置引用类型（比如Array）的实例通常可以很好地协同，但有些ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。</p>
<h3 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h3><p>代理可以捕获13 种不同的基本操作。只要在代理上调用，所有捕获器都会拦截它们对应的反射API 操作。</p>
<table>
<thead>
<tr>
<th align="left">方法名称</th>
<th>作用</th>
<th align="left">反射API方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">get()</td>
<td>获取属性值的操作中被调用</td>
<td align="left">Reflect.get()</td>
</tr>
<tr>
<td align="left">set()</td>
<td>设置属性值的操作中被调用</td>
<td align="left">Reflect.set()</td>
</tr>
<tr>
<td align="left">has()</td>
<td>在in 操作符中被调用</td>
<td align="left">Reflect.has()</td>
</tr>
<tr>
<td align="left">defineProperty()</td>
<td>在Object.defineProperty()中被调用</td>
<td align="left">Reflect.defineProperty()</td>
</tr>
<tr>
<td align="left">getOwnPropertyDescriptor()</td>
<td>在Object.getOwnPropertyDescriptor()中被调用</td>
<td align="left">Reflect.getOwnPropertyDescriptor()</td>
</tr>
<tr>
<td align="left">deleteProperty()</td>
<td>在delete 操作符中被调用</td>
<td align="left">Reflect.deleteProperty()</td>
</tr>
<tr>
<td align="left">ownKeys()</td>
<td>在Object.keys()及类似方法中被调用</td>
<td align="left">Reflect.ownKeys()</td>
</tr>
<tr>
<td align="left">getPrototypeOf()</td>
<td>在Object.getPrototypeOf()中被调用</td>
<td align="left">Reflect.getPrototypeOf()</td>
</tr>
<tr>
<td align="left">setPrototypeOf()</td>
<td>在Object.setPrototypeOf()中被调用</td>
<td align="left">Reflect.setPrototypeOf()</td>
</tr>
<tr>
<td align="left">isExtensible()</td>
<td>在Object.isExtensible()中被调用</td>
<td align="left">Reflect.isExtensible()</td>
</tr>
<tr>
<td align="left">preventExtensions()</td>
<td>在Object.preventExtensions()中被调用</td>
<td align="left">Reflect.preventExtensions()</td>
</tr>
<tr>
<td align="left">apply()</td>
<td>调用函数时中被调用</td>
<td align="left">Reflect.apply()</td>
</tr>
<tr>
<td align="left">construct()</td>
<td>new 操作符中被调用</td>
<td align="left">Reflect.construct()</td>
</tr>
</tbody></table>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>使用代理可以在代码中实现一些有用的编程模式。</p>
<table>
<thead>
<tr>
<th align="left">代理模式名称</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">跟踪属性访问</td>
<td align="left">知道对象属性什么时候被访问、被查询</td>
</tr>
<tr>
<td align="left">隐藏属性</td>
<td align="left">隐藏目标对象上的属性</td>
</tr>
<tr>
<td align="left">属性验证</td>
<td align="left">赋值操作都会触发set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值</td>
</tr>
<tr>
<td align="left">函数与构造函数参数验证</td>
<td align="left">可以让函数只接收某种类型的值</td>
</tr>
<tr>
<td align="left">数据绑定与可观察对象</td>
<td align="left">通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。</td>
</tr>
</tbody></table>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是JavaScript 编程中最有用也最通用的工具。ECMAScript 6 新增了更加强大的语法特性，从而让开发者可以更有效地使用函数。<br> 函数表达式与函数声明是不一样的。函数声明要求写出函数名称，而函数表达式并不需要。没有名称的函数表达式也被称为匿名函数。<br> ES6 新增了类似于函数表达式的箭头函数语法，但两者也有一些重要区别。<br> JavaScript 中函数定义与调用时的参数极其灵活。arguments 对象，以及ES6 新增的扩展操作符，可以实现函数定义和调用的完全动态化。<br> 函数内部也暴露了很多对象和引用，涵盖了函数被谁调用、使用什么调用，以及调用时传入了什么参数等信息。<br> JavaScript 引擎可以优化符合尾调用条件的函数，以节省栈空间。<br> 闭包的作用域链中包含自己的一个变量对象，然后是包含函数的变量对象，直到全局上下文的变量对象。<br> 通常，函数作用域及其中的所有变量在函数执行完毕后都会被销毁。<br> 闭包在被函数返回之后，其作用域会一直保存在内存中，直到闭包被销毁。<br> 函数可以在创建之后立即调用，执行其中代码之后却不留下对函数的引用。<br> 立即调用的函数表达式如果不在包含作用域中将返回值赋给一个变量，则其包含的所有变量都会被销毁。<br> 虽然JavaScript 没有私有对象属性的概念，但可以使用闭包实现公共方法，访问位于包含作用域中定义的变量。<br> 可以访问私有变量的公共方法叫作特权方法。<br> 特权方法可以使用构造函数或原型模式通过自定义类型中实现，也可以使用模块模式或模块增强模式在单例对象上实现。</p>
<h2 id="10-9-函数内部（arguments-callee，this，caller-new-target）"><a href="#10-9-函数内部（arguments-callee，this，caller-new-target）" class="headerlink" title="10.9 函数内部（arguments,callee，this，caller,new.target）"></a>10.9 函数内部（arguments,callee，this，caller,new.target）</h2><p>在ECMAScript 5 中，函数内部存在两个特殊的对象：<strong>arguments</strong> 和<strong>this</strong>。ECMAScript 6 又新增了new.target 属性。</p>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>它是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但arguments 对象其实还有一个<strong>callee</strong> 属性，是一个指向arguments 对象所在函数的指针。</p>
<p>来看下面这个经典的阶乘函数：<br>function factorial(num) {<br>    if (num &lt;&#x3D; 1) {<br>        return 1;<br>    } else {<br>        return num * factorial(num - 1);<br>    }<br>}<br>阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是factorial，从而导致了紧密耦合。使用arguments.callee 就可以让函数逻辑与函数名解耦：<br>function factorial(num) {<br>    if (num &lt;&#x3D; 1) {<br>        return 1;<br>    } else {<br>        return num * arguments.callee(num - 1);<br>    }<br>}</p>
<p>这个重写之后的factorial()函数已经用arguments.callee 代替了之前硬编码的factorial。<br>这意味着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况：</p>
<p>let trueFactorial &#x3D; factorial;<br>factorial &#x3D; function() {<br>    return 0;<br>};<br>console.log(trueFactorial(5)); &#x2F;&#x2F; 120<br>console.log(factorial(5)); &#x2F;&#x2F; 0</p>
<p>这里，trueFactorial 变量被赋值为factorial，实际上把同一个函数的指针又保存到了另一个位置。然后，factorial 函数又被重写为一个返回0 的函数。如果像factorial()最初的版本那样不使用arguments.callee，那么像上面这样调用trueFactorial()就会返回0。不过，通过将函数与名称解耦，trueFactorial()就可以正确计算阶乘，而factorial()则只能返回0。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>另一个特殊的对象是this，它在标准函数和箭头函数中有不同的行为。</p>
<ol>
<li>在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为this 值（在网页的全局上下文中调用函数时，this 指向windows）。</li>
<li><strong>在箭头函数中，this 引用的是定义箭头函数的上下文。</strong></li>
</ol>
<h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><p>这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为null。</p>
<h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6 新增了<strong>检测函数是否使用new 关键字调用的new.target 属性</strong>。如果<strong>函数是正常调用的，则new.target 的值是undefined</strong>；<strong>如果是使用new 关键字调用的，则new.target 将引用被调用的构造函数</strong>。</p>
<h2 id="函数属性与方法（length，prototype，apply-，call-，bind-）"><a href="#函数属性与方法（length，prototype，apply-，call-，bind-）" class="headerlink" title="函数属性与方法（length，prototype，apply()，call()，bind()）"></a>函数属性与方法（length，prototype，apply()，call()，bind()）</h2><p>前面提到过，ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：length和prototype。其中，length 属性保存函数定义的命名参数的个数。例如：</p>
<p>function sayName(name) {<br>    console.log(name);<br>}<br>function sum(num1, num2) {<br>    return num1 + num2;<br>}<br>function sayHi() {<br>    console.log(“hi”);<br>}<br>console.log(sayName.length); &#x2F;&#x2F; 1<br>console.log(sum.length); &#x2F;&#x2F; 2<br>console.log(sayHi.length); &#x2F;&#x2F; 0</p>
<p>prototype 是<strong>保存引用类型所有实例方法的地方</strong>，这意味着toString()、valueOf()等方法实际上都保存在prototype 上，进而由所有实例共享。这个属性在自定义类型时特别重要。在ECMAScript 5中，<strong>prototype 属性是不可枚举的</strong>，<strong>因此使用for-in 循环不会返回这个属性</strong>。</p>
<p>函数还有3个方法：<strong>apply()和call()<strong>。这两个方法都会以指定的this 值来调用函数，即会设置调用函数时函数体内this 对象的值。还有</strong>bind()方法</strong>会创建一个新的函数实例，其this 值会被绑定到传给bind()的对象。</p>
<h1 id="期约与异步函数"><a href="#期约与异步函数" class="headerlink" title="期约与异步函数"></a>期约与异步函数</h1><p>期以来，掌握单线程JavaScript 运行时的异步行为一直都是个艰巨的任务。随着ES6 新增了期约和ES8 新增了<strong>异步函数</strong>，ECMAScript 的异步编程特性有了长足的进步。通过<strong>期约</strong>和<strong>async&#x2F;await</strong>，不仅可以实现之前难以实现或不可能实现的任务，而且也能写出更清晰、简洁，并且容易理解、调试的代码。</p>
<p>期约的主要功能是为异步代码提供了清晰的抽象。可以用期约表示异步执行的代码块，也可以用期约表示异步计算的值。在需要串行异步代码时，期约的价值最为突出。作为可塑性极强的一种结构，期约可以被序列化、连锁使用、复合、扩展和重组。</p>
<p>异步函数是将期约应用于JavaScript 函数的结果。<strong>异步函数可以暂停执行，而不阻塞主线程</strong>。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。异步函数可以说是现代JavaScript 工具箱中最重要的工具之一。</p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。</p>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p><strong>同步行为</strong>对应内存中<strong>顺序执行</strong>的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。</p>
<p><strong>异步行为</strong>类似于<strong>系统中断</strong>，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。</p>
<h3 id="以往的异步编程模式"><a href="#以往的异步编程模式" class="headerlink" title="以往的异步编程模式"></a>以往的异步编程模式</h3><p>早期的JavaScript 中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。</p>
<p>随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。嵌套回调的代码维护起来就是噩梦。</p>
<h2 id="期约（promise）"><a href="#期约（promise）" class="headerlink" title="期约（promise）"></a>期约（promise）</h2><h3 id="期约基础"><a href="#期约基础" class="headerlink" title="期约基础"></a>期约基础</h3><p>ECMAScript 6 新增的引用类型Promise，可以通过new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数，下面的例子使用了一个空函数对象来应付一下解释器：</p>
<p>let p &#x3D; new Promise(() &#x3D;&gt; {});<br>setTimeout(console.log, 0, p); &#x2F;&#x2F; Promise <pending></p>
<p>之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出SyntaxError。</p>
<p>期约是一个有状态的对象，可能处于如下3 种状态之一：</p>
<ol>
<li>待定（pending）</li>
<li>兑现（fulfilled，有时候也称为“解决”，resolved）</li>
<li>拒绝（rejected）</li>
</ol>
<p>期约的状态是<strong>私有</strong>的，不能直接通过JavaScript 检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也<strong>不能被外部JavaScript 代码修改</strong>。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。</p>
<p>由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：<strong>初始化期约的异步行为</strong>和<strong>控制状态的最终转换</strong>。</p>
<h4 id="解决值、拒绝理由及期约用例"><a href="#解决值、拒绝理由及期约用例" class="headerlink" title="解决值、拒绝理由及期约用例"></a>解决值、拒绝理由及期约用例</h4><table>
<thead>
<tr>
<th>方法</th>
<th>接受参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>new Promise((resolve, reject)&#x3D;&gt;{函数})</td>
<td>(resolve, reject)</td>
<td>创建一个期约</td>
</tr>
<tr>
<td>Promise.resolve()</td>
<td>任意：解决resolve期约的原因</td>
<td>可以实例化一个解决的期约。</td>
</tr>
<tr>
<td>Promise.reject()</td>
<td>任意：解决reject期约的原因</td>
<td>实例化一个拒绝的期约并抛出一个异步错误</td>
</tr>
</tbody></table>
<h4 id="期约的实例方法"><a href="#期约的实例方法" class="headerlink" title="期约的实例方法"></a>期约的实例方法</h4><p>每个期约实例的方法<strong>（then()、catch()和finally()）</strong>都会返回一个<strong>新的期约对象</strong>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>接受参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Promise.prototype.then()</td>
<td>onResolved 和onRejected 处理程序</td>
<td>为期约实例添加处理程序</td>
</tr>
<tr>
<td>Promise.prototype.catch()</td>
<td>onRejected 处理程序</td>
<td>用于给期约添加拒绝处理程序</td>
</tr>
<tr>
<td>Promise.prototype.finally()</td>
<td>onFinally处理程序</td>
<td>用于给期约添加onFinally 处理程序</td>
</tr>
</tbody></table>
<h4 id="Promise-类的静态方法"><a href="#Promise-类的静态方法" class="headerlink" title="Promise 类的静态方法"></a>Promise 类的静态方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>接受参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Promise.all()</td>
<td>接收一个可迭代对象，返回一个新期约</td>
<td>在一组期约全部解决之后再解决</td>
</tr>
<tr>
<td>Promise.race()</td>
<td>接收一个可迭代对象，返回一个新期约</td>
<td>一组集合中最先解决或拒绝的期约的镜像</td>
</tr>
</tbody></table>
<h2 id="异步函数（async-await）"><a href="#异步函数（async-await）" class="headerlink" title="异步函数（async&#x2F;await）"></a>异步函数（async&#x2F;await）</h2><p>这个特性从行为和语法上都增强了JavaScript，让以同步方式写的代码能够异步执行。（我认为这相当于promise的语法糖）</p>
<p>&#x2F;&#x2F; 返回一个原始值<br>async function foo() {<br>    return ‘foo’;<br>}<br>foo().then(console.log);</p>
<p>异步函数<strong>（async）</strong>如果使用return 关键字返回了值（如果没有return 则会返回undefined），这个值会被Promise.resolve()包装成一个期约对象。</p>
<p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使<strong>await关键字</strong>可以暂停异步函数代码的执行，等待期约解决。</p>
<p>let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; setTimeout(resolve, 1000, 3));<br>p.then((x) &#x3D;&gt; console.log(x)); &#x2F;&#x2F; 3<br><strong>使用async&#x2F;await 可以写成这样：</strong><br>async function foo() {<br>    let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; setTimeout(resolve, 1000, 3));<br>    console.log(await p);<br>}<br>foo();<br>&#x2F;&#x2F; 3</p>
<p><strong>await 关键字</strong>会<strong>暂停执行异步函数后面的代码</strong>，让出JavaScript 运行时的执行线程。这个行为与生成器函数中的<strong>yield 关键字</strong>是一样的。await 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。</p>
<p><strong>await 关键字必须在异步函数中使用</strong></p>
<h3 id="异步函数策略"><a href="#异步函数策略" class="headerlink" title="异步函数策略"></a>异步函数策略</h3><ol>
<li><p>实现sleep()</p>
</li>
<li><p>利用平行执行</p>
</li>
<li><p>串行执行期约</p>
</li>
<li><p>栈追踪与内存管理</p>
</li>
</ol>
<h1 id="第12-章-BOM"><a href="#第12-章-BOM" class="headerlink" title="第12 章  BOM"></a>第12 章  BOM</h1><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>浏览器对象模型（BOM，Browser Object Model）是以<strong>window 对象为基础的，这个对象代表了浏览器窗口和页面可见的区域</strong>。<strong>window 对象也被复用为ECMAScript 的Global 对象</strong>，因此所有全局变量和函数都是它的属性，而且所有原生类型的构造函数和普通函数也都从一开始就存在于这个对象之上。本章讨论了BOM 的以下内容。<br> 要引用其他window 对象，可以使用几个不同的窗口指针。<br> 通过<strong>location 对象</strong>可以以编程方式操纵浏览器的导航系统。通过设置这个对象上的属性，可<br>以改变浏览器URL 中的某一部分或全部。<br> 使用<strong>replace()方法</strong>可以替换浏览器历史记录中当前显示的页面，并导航到新URL。<br> <strong>navigator 对象</strong>提供关于浏览器的信息。提供的信息类型取决于浏览器，不过有些属性如userAgent 是所有浏览器都支持的。<br>BOM 中的另外两个对象也提供了一些功能。screen 对象中保存着客户端显示器的信息。这些信息通常用于评估浏览网站的设备信息。history 对象提供了操纵浏览器历史记录的能力，开发者可以确定历史记录中包含多少个条目，并以编程方式实现在历史记录中导航，而且也可以修改历史记录。</p>
<h2 id="12-1-window-对象"><a href="#12-1-window-对象" class="headerlink" title="12.1 window 对象"></a>12.1 window 对象</h2><p>BOM 的核心是window 对象，表示浏览器的实例。window 对象在浏览器中有两重身份，一个是<br>ECMAScript 中的Global 对象，另一个就是浏览器窗口的JavaScript 接口</p>
<p>网页中定义的<strong>所有对象、变量和函数</strong>都以window 作为其Global 对象，都可以访问其上定义的<strong>parseInt()等全局方法</strong>。</p>
<h3 id="12-1-1-Global-作用域"><a href="#12-1-1-Global-作用域" class="headerlink" title="12.1.1 Global 作用域"></a>12.1.1 Global 作用域</h3><p>因为window 对象被复用为ECMAScript 的Global 对象，所以<strong>通过<u>var 声明</u>的所有全局变量和函数都会变成window 对象的属性和方法</strong>。</p>
<h3 id="12-1-2-窗口关系"><a href="#12-1-2-窗口关系" class="headerlink" title="12.1.2 窗口关系"></a>12.1.2 窗口关系</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>window.top</td>
<td>始终指向最上层（最外层）窗口，即浏览器窗口本身</td>
</tr>
<tr>
<td>window.parent</td>
<td>而parent 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则parent 等于top（都等于window）</td>
</tr>
<tr>
<td>window.self</td>
<td>它是终极window 属性，始终会指向window。self 和window 就是同一个对象。之所以还要暴露self，就是为了和top、parent 保持一致</td>
</tr>
</tbody></table>
<p>这些属性都是window 对象的属性，因此访问window.parent、window.top 和window.self<br>都可以。这意味着可以把访问多个窗口的window 对象串联起来，比如window.parent.parent。</p>
<h3 id="12-1-3-窗口位置与像素比"><a href="#12-1-3-窗口位置与像素比" class="headerlink" title="12.1.3 窗口位置与像素比"></a>12.1.3 窗口位置与像素比</h3><p>window 对象的位置可以通过不同的属性和方法来确定</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>window.screenLeft</td>
<td>表示窗口相对于屏幕左侧的位置，返回值的单位是CSS 像素。</td>
</tr>
<tr>
<td>window.screenTop</td>
<td>表示窗口相对于屏幕顶部的位置，返回值的单位是CSS 像素。</td>
</tr>
<tr>
<td>window.moveTo()</td>
<td>移动窗口，接收两个参数，接收要移动到的新位置的<strong>绝对坐标x 和y</strong></td>
</tr>
<tr>
<td>window.moveBy()</td>
<td>移动窗口，接收两个参数，接收<strong>相对当前位置</strong>在<strong>两个方向上移动的像素数</strong></td>
</tr>
</tbody></table>
<h3 id="12-1-4-窗口大小"><a href="#12-1-4-窗口大小" class="headerlink" title="12.1.4 窗口大小"></a>12.1.4 窗口大小</h3><p>不同浏览器中确定浏览器窗口大小没有想象中那么容易。所有现代浏览器都支持<strong>4 个属性</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>window.innerWidth</td>
<td>返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）</td>
</tr>
<tr>
<td>window.innerHeight</td>
<td>返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）</td>
</tr>
<tr>
<td>window.outerWidth</td>
<td>返回浏览器窗口自身的大小（不管是在最外层window 上使用，还是在窗格中使用）</td>
</tr>
<tr>
<td>window.outerHeight</td>
<td>返回浏览器窗口自身的大小（不管是在最外层window 上使用，还是在窗格中使用）</td>
</tr>
<tr>
<td>document.documentElement.clientWidth</td>
<td>返回页面视口的宽度</td>
</tr>
<tr>
<td>document.documentElement.clientHeight</td>
<td>返回页面视口的高度</td>
</tr>
<tr>
<td>resizeTo()</td>
<td>接收两个参数，resizeTo()接收新的宽度和高度值</td>
</tr>
<tr>
<td>resizeBy()</td>
<td>接收两个参数，resizeBy()接收宽度和高度各要缩放多少</td>
</tr>
</tbody></table>
<p>与移动窗口的方法一样，缩放窗口的方法(resizeTo(),resizeBy())可能会被浏览器禁用，而且在某些浏览器中默认是禁用的。同样，缩放窗口的方法<strong>只能应用到最上层的window 对象</strong>。</p>
<h3 id="12-1-5-视口位置"><a href="#12-1-5-视口位置" class="headerlink" title="12.1.5 视口位置"></a>12.1.5 视口位置</h3><p>度量文档相对于视口滚动距离的属性有两对，返回相等的值:可以使用scroll()、scrollTo()和scrollBy()方法滚动页面。这3 个方法都接收表示相对视口距离的x 和y 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>window.pageXoffset&#x2F;window.scrollX</td>
<td>度量文档相对于视口滚动距离的属性</td>
</tr>
<tr>
<td>window.pageYoffset&#x2F;window.scrollY</td>
<td>度量文档相对于视口滚动距离的属性</td>
</tr>
</tbody></table>
<h3 id="12-1-6-导航与打开新窗口"><a href="#12-1-6-导航与打开新窗口" class="headerlink" title="12.1.6 导航与打开新窗口"></a>12.1.6 导航与打开新窗口</h3><p>**window.open()**方法可以用于导航到指定URL，也可以用于打开新浏览器窗口。这个方法接收4<br>个参数：要加载的URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页<br>面的布尔值。通常，调用这个方法时只传前3 个参数，最后一个参数只有在不打开新窗口时才会使用。</p>
<h3 id="12-1-7-定时器"><a href="#12-1-7-定时器" class="headerlink" title="12.1.7 定时器"></a>12.1.7 定时器</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout()</td>
<td>指定在一定时间后执行某些代码</td>
</tr>
<tr>
<td>setInterval()</td>
<td>指定每隔一段时间执行某些代码</td>
</tr>
</tbody></table>
<h3 id="12-1-8-系统对话框"><a href="#12-1-8-系统对话框" class="headerlink" title="12.1.8 系统对话框"></a>12.1.8 系统对话框</h3><p>使用alert()、confirm()和prompt()方法，可以让浏览器调用系统对话框向用户显示消息</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>alert()</td>
<td>传入的字符串会显示在一个系统对话框中</td>
</tr>
<tr>
<td>confirm()</td>
<td>确认框，通过调用confirm()来显示。确认框跟警告框类似，都会向用户显示消息。比alert()多一个OK 和Cancel 按钮</td>
</tr>
<tr>
<td>prompt()</td>
<td>提示框，提示框的用途是提示用户输入消息。除了OK 和Cancel 按钮，提示框还会显示一个文本框，让用户输入内容</td>
</tr>
</tbody></table>
<h2 id="12-2-location-对象"><a href="#12-2-location-对象" class="headerlink" title="12.2 location 对象"></a>12.2 location 对象</h2><p>location 是最有用的BOM 对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。它<strong>既是window 的属性， 也是document 的属性</strong>。也就是说，<strong>window.location 和document.location 指向同一个对象</strong></p>
<p>假设浏览器当前加载的URL 是<a target="_blank" rel="noopener" href="http://foouser:barpassword@www.wrox.com/WileyCDA/?q=">http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=</a><br>javascript#contents，location 对象的内容如下表所示。</p>
<p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241028103634325.png" alt="image-20241028103634325"></p>
<h2 id="12-4-screen-对象"><a href="#12-4-screen-对象" class="headerlink" title="12.4 screen 对象"></a>12.4 screen 对象</h2><p>window 的另一个属性screen 对象，是为数不多的几个在编程中很少用的JavaScript 对象。这个对<br>象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像<br>素高度。每个浏览器都会在screen 对象上暴露不同的属性。下表总结了这些属性。</p>
<p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241028104106884.png" alt="image-20241028104106884"></p>
<h2 id="12-5-history-对象"><a href="#12-5-history-对象" class="headerlink" title="12.5 history 对象"></a>12.5 history 对象</h2><p>history 对象表示当前窗口首次使用以来用户的导航历史记录。因为history 是window 的属性，<br>所以每个window 都有自己的history 对象。出于安全考虑，这个对象<strong>不会暴露用户访问过的URL</strong>，<br>但可以通过它在不知道实际URL 的情况下前进和后退。</p>
<h3 id="12-5-1-导航"><a href="#12-5-1-导航" class="headerlink" title="12.5.1 导航"></a>12.5.1 导航</h3><p><strong>go()方法</strong>可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法<strong>只接收一个参数</strong>，<br><strong>这个参数可以是一个整数，表示前进或后退多少步。</strong></p>
<p>go()有两个简写方法：back()和forward()。顾名思义，这两个方法模拟了浏览器的后退按钮和<br>前进按钮。</p>
<p>history 对象还有一个<strong>length 属性</strong>，表示历史记录中有多个条目。这个属性反映了历史记录的数<br>量，包括可以前进和后退的页面。对于窗口或标签页中加载的第一个页面，history.length 等于1。<br>通过以下方法测试这个值，可以确定用户浏览器的起点是不是你的页面。</p>
<h3 id="12-5-2-历史状态管理（略）"><a href="#12-5-2-历史状态管理（略）" class="headerlink" title="12.5.2 历史状态管理（略）"></a>12.5.2 历史状态管理（略）</h3><h1 id="第13-章-客户端检测"><a href="#第13-章-客户端检测" class="headerlink" title="第13 章  客户端检测"></a>第13 章  客户端检测</h1><p>而现实当中，浏览器之间的差异和莫名其妙的行为，让客户端检测变成一种补救措施，而且也成为了开发策略的重要一环。</p>
<h2 id="13-1-能力检测"><a href="#13-1-能力检测" class="headerlink" title="13.1 能力检测"></a>13.1 能力检测</h2><p><strong>能力检测（又称特性检测）</strong>即在JavaScript 运行时中使用一套简单的检测逻辑，测试浏览器是否支持某种特性。这种方式不要求事先知道特定浏览器的信息，只需检测自己关心的能力是否存在即可。</p>
<h3 id="13-1-1-安全能力检测"><a href="#13-1-1-安全能力检测" class="headerlink" title="13.1.1 安全能力检测"></a>13.1.1 安全能力检测</h3><p>能力检测最有效的场景是检测能力是否存在的同时，验证其是否能够展现出预期的行为。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://duwhywu.github.io/2024/10/30/js/" data-id="cm31ed4ag0003ag4g36zaewsg" data-title="JS" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%A5%E8%87%AA-JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89/" rel="tag">来自 -- JavaScript高级程序设计（第4版）</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/10/31/mockjs/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          Mock.js
        
      </div>
    </a>
  
  
    <a href="/2024/10/30/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%A5%E8%87%AA-JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89/" rel="tag">来自 -- JavaScript高级程序设计（第4版）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%A5%E8%87%AACSDN-Mock-js-%E8%B6%85%E5%85%A8-%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93-%E4%BF%9D%E5%A7%86%E7%BA%A7%E5%88%AB%E7%9A%84%E6%95%99%E7%A8%8B-mockjs-CSDN%E5%8D%9A%E5%AE%A2/" rel="tag">来自CSDN -- Mock.js 超全 超详细总结 保姆级别的教程_mockjs-CSDN博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%A5%E8%87%AA%EF%BC%9A-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E7%9F%A5%E4%B9%8E-https-zhuanlan-zhihu-com-p-68801601/" rel="tag">来自：[CSS基础知识整理 - 知乎](https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;68801601)</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%9D%A5%E8%87%AA-JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89/" style="font-size: 10px;">来自 -- JavaScript高级程序设计（第4版）</a> <a href="/tags/%E6%9D%A5%E8%87%AACSDN-Mock-js-%E8%B6%85%E5%85%A8-%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93-%E4%BF%9D%E5%A7%86%E7%BA%A7%E5%88%AB%E7%9A%84%E6%95%99%E7%A8%8B-mockjs-CSDN%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">来自CSDN -- Mock.js 超全 超详细总结 保姆级别的教程_mockjs-CSDN博客</a> <a href="/tags/%E6%9D%A5%E8%87%AA%EF%BC%9A-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E7%9F%A5%E4%B9%8E-https-zhuanlan-zhihu-com-p-68801601/" style="font-size: 10px;">来自：[CSS基础知识整理 - 知乎](https://zhuanlan.zhihu.com/p/68801601)</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/03/css/">CSS基础知识整理</a>
          </li>
        
          <li>
            <a href="/2024/10/31/mockjs/">Mock.js</a>
          </li>
        
          <li>
            <a href="/2024/10/30/js/">JS</a>
          </li>
        
          <li>
            <a href="/2024/10/30/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 duwhywu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>