<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React Hooks</title>
    <link href="/2024/11/18/react%E8%A1%A5%E5%85%85/"/>
    <url>/2024/11/18/react%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><h3 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h3><p>React Hooks 是 React 16.8 引入的一项重要特性，它使函数组件能够拥有类组件的一些特性，<strong>例如状态管理和生命周期方法的使用</strong>。</p><p>通过 Hooks，可以更加简洁和灵活地编写 React 组件。</p><h3 id="1-什么是-React-Hooks？"><a href="#1-什么是-React-Hooks？" class="headerlink" title="1 什么是 React Hooks？"></a>1 什么是 React Hooks？</h3><p>React Hooks 是一种函数式组件的增强机制，它允许你在不编写类组件的情况下使用 React 的特性。主要的 Hooks 包括 useState, useEffect, useContext, useReducer, useCallback, useMemo, useRef, 和 useImperativeHandle 等。这些 Hooks 提供了访问 React 特性的方式，使得你可以更好地组织和重用你的代码。</p><h3 id="2-主要的-React-Hooks"><a href="#2-主要的-React-Hooks" class="headerlink" title="2 主要的 React Hooks"></a>2 主要的 React Hooks</h3><table><thead><tr><th>hooks名称</th><th>作用</th><th>接受参数</th></tr></thead><tbody><tr><td><strong>useState</strong></td><td>函数组件中使用局部状态。它返回一个状态值和更新该状态值的函数</td><td></td></tr><tr><td><strong>useEffect</strong></td><td>在函数组件中执行副作用操作（如数据获取、订阅管理、DOM 操作等）。它在每次渲染后都会执行。（与类组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 生命周期类似。）</td><td></td></tr><tr><td><strong>useContext</strong></td><td>用于访问 React context 在组件树中传递的数据，而不必通过每个组件传递 props。</td><td></td></tr><tr><td><strong>useReducer</strong></td><td>用于更复杂的 state 逻辑，它接收一个 reducer 函数和初始状态，然后返回当前的状态和派发 action 的 dispatch 函数。</td><td></td></tr><tr><td><strong>useCallback</strong></td><td>返回一个 memoized 版本的回调函数，防止不必要的渲染。</td><td></td></tr><tr><td><strong>useMemo</strong></td><td>用于对计算结果进行记忆，避免在每次渲染时重复计算。（类似计算属性）</td><td></td></tr><tr><td><strong>useRef</strong></td><td>用于创建对 DOM 元素或值的引用，可以在渲染之间保持状态。</td><td></td></tr><tr><td><strong>useImperativeHandle</strong></td><td>用于使用 ref 时<strong>暴露</strong> DOM 元素的<strong>方法</strong>。</td><td></td></tr><tr><td><strong>useDebugValue</strong></td><td>用于在 React 开发者工具中显示自定义 hook 的标签。</td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2024/11/18/git/"/>
    <url>/2024/11/18/git/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http</title>
    <link href="/2024/11/17/http/"/>
    <url>/2024/11/17/http/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP-教程"><a href="#HTTP-教程" class="headerlink" title="HTTP 教程"></a><strong>HTTP 教程</strong></h1><p><a href="https://www.runoob.com/http/http-tutorial.html">https://www.runoob.com/http/http-tutorial.html</a></p><h2 id="HTTP-教程-1"><a href="#HTTP-教程-1" class="headerlink" title="HTTP 教程"></a>HTTP 教程</h2><p>HTTP 是一个基于 TCP&#x2F;IP 通信协议来传递数据的（HTML 文件、图片文件、查询结果等）。</p><p>HTTP 的请求-响应模型通常由以下 5 个步骤组成：<br>    1  建立连接：客户端与服务器之间建立连接。在传统的 HTTP 中，这是基于 TCP&#x2F;IP 协议的。最近的 HTTP&#x2F;2 和 HTTP&#x2F;3 则使用了更先进的传输层协议，例如基于 TCP 的二进制协议（HTTP&#x2F;2）或基于 UDP 的 QUIC 协议（HTTP&#x2F;3）。<br>    2  发送请求：客户端向服务器发送请求，请求中包含要访问的资源的 URL、请求方法（GET、POST、PUT、DELETE 等）、请求头（例如，Accept、User-Agent）以及可选的请求体（对于 POST 或 PUT 请求）。<br>    3  处理请求：服务器接收到请求后，根据请求中的信息找到相应的资源，执行相应的处理操作。这可能涉及从数据库中检索数据、生成动态内容或者简单地返回静态文件。<br>    4  发送响应：服务器将处理后的结果封装在响应中，并将其发送回客户端。响应包含状态码（用于指示请求的成功或失败）、响应头（例如，Content-Type、Content-Length）以及可选的响应体（例如，HTML 页面、图像数据）。<br>    5  关闭连接：在完成请求-响应周期后，客户端和服务器之间的连接可以被关闭，除非使用了持久连接（如 HTTP&#x2F;1.1 中的 keep-alive）。</p><p>HTTP 方法（5 个）<br>        GET：请求从服务器获取指定资源。这是最常用的方法，用于访问页面。<br>        POST：请求服务器接受并处理请求体中的数据，通常用于表单提交。<br>        PUT：请求服务器存储一个资源，并用请求体中的内容替换目标资源的所有内容。<br>        DELETE：请求服务器删除指定的资源。<br>        HEAD：与 GET 类似，但不获取资源的内容，只获取响应头信息。</p><p>HTTP 状态码<br>HTTP 状态码是服务器对客户端请求的响应。状态码分为五类：<br>        1xx（信息性状态码）：表示接收的请求正在处理。<br>        2xx（成功状态码）：表示请求正常处理完毕。<br>        3xx（重定向状态码）：需要后续操作才能完成这一请求。<br>        4xx（客户端错误状态码）：表示请求包含语法错误或无法完成。<br>        5xx（服务器错误状态码）：服务器在处理请求的过程中发生了错误。</p><p>HTTP 版本<br>HTTP 有多个版本，目前广泛使用的是 HTTP&#x2F;1.1 和 HTTP&#x2F;2，以及正在逐步推广的 HTTP&#x2F;3。<br>    HTTP&#x2F;1.1：支持持久连接，允许多个请求&#x2F;响应通过同一个 TCP 连接传输，减少了建立和关闭连接的消耗。<br>    HTTP&#x2F;2：基于二进制分帧，支持多路复用，允许同时通过单一的 HTTP&#x2F;2 连接发起多重的、独立的、双向的交流。<br>    HTTP&#x2F;3：基于 QUIC 协议，旨在减少网络延迟，提高传输速度和安全性。</p><h2 id="HTTP-HTTPS-简介"><a href="#HTTP-HTTPS-简介" class="headerlink" title="HTTP&#x2F;HTTPS 简介"></a>HTTP&#x2F;HTTPS 简介</h2><p><strong>HTTP（超文本传输协议，Hypertext Transfer Protocol）</strong>是一种用于从网络传输超文本到本地浏览器的传输协议。它定义了客户端与服务器之间请求和响应的格式。HTTP 工作在 <strong>TCP&#x2F;IP</strong> 模型之上，通常使用端口 <strong>80</strong>。</p><p><strong>HTTPS（超文本传输安全协议，Hypertext Transfer Protocol Secure）</strong>是 HTTP 的安全版本，<strong>它在 HTTP 下增加了 SSL&#x2F;TLS 协议</strong>，提供了数据加密、完整性校验和身份验证。HTTPS 通常使用端口 <strong>443</strong>。</p><p>HTTPS 经由 HTTP 进行通信，但利用 SSL&#x2F;TLS 来加密数据包，HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换资料的隐私与完整性。</p><h3 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h3><p>HTTP 协议工作于客户端-服务端架构上。</p><p>HTTP 工作过程通常如下：</p><ol><li><strong>客户端发起请求</strong>：用户通过客户端（如浏览器）输入 URL，客户端向服务器发起一个 HTTP 请求。</li><li><strong>服务器处理请求</strong>：服务器接收到请求后，根据请求的类型（如GET、POST等）和请求的资源，进行相应的处理。</li><li><strong>服务器返回响应</strong>：服务器将处理结果包装成HTTP响应消息，发送回客户端。</li><li><strong>客户端渲染页面</strong>：客户端接收到响应后，根据响应内容（如HTML、图片等）渲染页面，展示给用户。</li></ol><p>Web 服务器有：Nginx 服务器，Apache 服务器，IIS 服务器（Internet Information Services）等。</p><p>HTTP 默认端口号为 80，但是你也可以改为 8080 或者其他端口。</p><p><strong>HTTP 三点注意事项：</strong></p><ul><li>HTTP 是无连接：无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li><li>HTTP 是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送，客户端以及服务器指定使用适合的 MIME-type 内容类型。</li><li>HTTP 是无状态：HTTP 协议是无状态协议，无状态是指协议对于事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul><p>以下图表展示了 HTTP 协议通信流程：</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241017143343805.png" alt="image-20241017143343805"></p><h3 id="HTTPS-作用"><a href="#HTTPS-作用" class="headerlink" title="HTTPS 作用"></a>HTTPS 作用</h3><p>HTTPS 的主要作用是在不安全的网络上创建一个安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。</p><p>**HTTPS <strong>信任基于预先安装在操作系统中的证书颁发机构（CA）</strong>因此，与一个网站之间的 HTTPS 连线仅在这些情况下可被信任：</p><ul><li>浏览器正确地实现了 HTTPS 且操作系统中安装了正确且受信任的证书颁发机构；</li><li>证书颁发机构仅信任合法的网站；</li><li>被访问的网站提供了一个有效的证书，也就是说它是一个由操作系统信任的证书颁发机构签发的（大部分浏览器会对无效的证书发出警告）；</li><li>该证书正确地验证了被访问的网站（例如，访问 <a href="https://www.runoob.com/">https://www.runoob.com</a> 时收到了签发给 <a href="http://www.runoob.com/">www.runoob.com</a> 而不是其它域名的证书）；</li><li>此协议的加密层（SSL&#x2F;TLS）能够有效地提供认证和高强度的加密。</li></ul><h3 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h3><p>HTTPS通过使用SSL&#x2F;TLS协议，为数据传输提供了加密和完整性校验，从而保护了用户的隐私和数据安全。</p><p>主要区别如下：</p><ul><li><strong>加密</strong>：<ul><li><strong>HTTP</strong>：数据传输过程中不加密，容易被截获和篡改。</li><li><strong>HTTPS</strong>：使用SSL&#x2F;TLS协议对传输的数据进行加密，保护数据传输过程中的安全性。</li></ul></li><li><strong>端口</strong>：<ul><li><strong>HTTP</strong>：默认使用端口80。</li><li><strong>HTTPS</strong>：默认使用端口443。</li></ul></li><li><strong>安全性</strong>：<ul><li><strong>HTTP</strong>：不提供数据加密，安全性较低。</li><li><strong>HTTPS</strong>：提供数据加密和完整性校验，安全性较高。</li></ul></li><li><strong>证书</strong>：<ul><li><strong>HTTP</strong>：不需要证书。</li><li><strong>HTTPS</strong>：需要SSL证书来启用加密，并验证服务器的身份。</li></ul></li><li><strong>性能</strong>：<ul><li><strong>HTTP</strong>：由于不加密数据，性能略高于HTTPS。</li><li><strong>HTTPS</strong>：由于需要进行加密和解密，可能会有一定的性能开销。</li></ul></li><li>**搜索引擎优化(SEO)**：<ul><li><strong>HTTP</strong>：搜索引擎可能会对没有使用HTTPS的网站进行降权。</li><li><strong>HTTPS</strong>：搜索引擎倾向于优先索引和展示使用HTTPS的网站。</li></ul></li><li><strong>浏览器显示</strong>：<ul><li><strong>HTTP</strong>：在大多数现代浏览器中，HTTP网站通常显示为”不安全”。</li><li><strong>HTTPS</strong>：浏览器会显示一个锁形图标，表示网站是安全的。</li></ul></li><li><strong>成本</strong>：<ul><li><strong>HTTP</strong>：通常免费。</li><li><strong>HTTPS</strong>：需要购买SSL证书，可能会有一定的成本。</li></ul></li><li><strong>应用场景</strong>：<ul><li><strong>HTTP</strong>：适用于不需要传输敏感信息的网站，如新闻网站、博客等。</li><li><strong>HTTPS</strong>：适用于需要传输敏感信息的网站，如网上银行、在线购物、电子邮件等。</li></ul></li></ul><h2 id="HTTP-消息结构"><a href="#HTTP-消息结构" class="headerlink" title="HTTP 消息结构"></a>HTTP 消息结构</h2><p>HTTP 是基于客户端&#x2F;服务端（C&#x2F;S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求&#x2F;响应协议。</p><p>HTTP 消息是客户端和服务器之间通信的基础，它们由一系列的文本行组成，遵循特定的格式和结构。</p><p>HTTP消息分为两种类型：请求消息和响应消息。</p><p>一个 HTTP 客户端是一个应用程序（Web 浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个 HTTP 的请求的目的。</p><p>一个 HTTP 服务器 同样也是一个应用程序（通常是一个 Web 服务，如 Nginx、Apache 服务器或 IIS 服务器等），通过接收客户端的请求并向客户端发送 HTTP 响应数据。</p><h3 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241018101721625.png" alt="image-20241018101721625"></p><ul><li><p><strong>请求行</strong>（Request Line）：</p><ul><li><strong>方法</strong>：如 GET、POST、PUT、DELETE等，指定要执行的操作。</li><li><strong>请求 URI</strong>（统一资源标识符）：请求的资源路径，通常包括主机名、端口号（如果非默认）、路径和查询字符串。</li><li><strong>HTTP 版本</strong>：如 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li></ul><p>请求行的格式示例：<code>GET /index.html HTTP/1.1</code></p></li><li><p><strong>请求头</strong>（Request Headers）：</p><ul><li>包含了客户端环境信息、请求体的大小（如果有）、客户端支持的压缩类型等。</li><li>常见的请求头包括<code>Host</code>、<code>User-Agent</code>、<code>Accept</code>、<code>Accept-Encoding</code>、<code>Content-Length</code>等。</li></ul></li><li><p><strong>空行</strong>：</p><ul><li>请求头和请求体之间的分隔符，表示请求头的结束。</li></ul></li><li><p><strong>请求体</strong>（可选）：</p><ul><li>在某些类型的HTTP请求（如 POST 和 PUT）中，请求体包含要发送给服务器的数据。</li></ul></li></ul><h3 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h3><p>HTTP 响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241018101851098.png" alt="image-20241018101851098"></p><ul><li><p><strong>状态行</strong>（Status Line）：</p><ul><li><strong>HTTP 版本</strong>：与请求消息中的版本相匹配。</li><li><strong>状态码</strong>：三位数，表示请求的处理结果，如 200 表示成功，404 表示未找到资源。</li><li><strong>状态信息</strong>：状态码的简短描述。</li></ul><p>状态行的格式示例：<code>HTTP/1.1 200 OK</code></p></li><li><p><strong>响应头</strong>（Response Headers）：</p><ul><li>包含了服务器环境信息、响应体的大小、服务器支持的压缩类型等。</li><li>常见的响应头包括<code>Content-Type</code>、<code>Content-Length</code>、<code>Server</code>、<code>Set-Cookie</code>等。</li></ul></li><li><p><strong>空行</strong>：</p><ul><li>响应头和响应体之间的分隔符，表示响应头的结束。</li></ul></li><li><p><strong>响应体</strong>（可选）：</p><ul><li>包含服务器返回的数据，如请求的网页内容、图片、JSON数据等。</li></ul></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面实例是一点典型的使用 GET 来传递数据的实例：</p><p>客户端请求：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> /index.html HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: www.example.com<br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; Win64; x64; rv:<span class="hljs-number">91</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">91</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/webp,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">Accept</span>-Encoding: gzip, deflate<br><span class="hljs-attribute">Connection</span>: keep-alive<br></code></pre></td></tr></table></figure><p>服务端响应:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Wed, 18 Apr 2024 12:00:00 GMT<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache/2.4.1 (Unix)<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Wed, 18 Apr 2024 11:00:00 GMT<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>12345<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=UTF-8<br><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Example Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- The rest of the HTML content --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h2><table><thead><tr><th>1</th><th>GET</th><th>从服务器获取资源。用于请求数据而不对数据进行更改。例如，从服务器获取网页、图片等。</th></tr></thead><tbody><tr><td>2</td><td>POST</td><td>向服务器发送数据以创建新资源。常用于提交表单数据或上传文件。发送的数据包含在请求体中。</td></tr><tr><td>3</td><td>PUT</td><td>向服务器发送数据以更新现有资源。如果资源不存在，则创建新的资源。与 POST 不同，PUT 通常是幂等的，即多次执行相同的 PUT 请求不会产生不同的结果。</td></tr><tr><td>4</td><td>DELETE</td><td>从服务器删除指定的资源。请求中包含要删除的资源标识符。</td></tr><tr><td>5</td><td>PATCH</td><td>对资源进行部分修改。与 PUT 类似，但 PATCH 只更改部分数据而不是替换整个资源。</td></tr><tr><td>6</td><td>HEAD</td><td>类似于 GET，但服务器只返回响应的头部，不返回实际数据。用于检查资源的元数据（例如，检查资源是否存在，查看响应的头部信息）。</td></tr><tr><td>7</td><td>OPTIONS</td><td>返回服务器支持的 HTTP 方法。用于检查服务器支持哪些请求方法，通常用于跨域资源共享（CORS）的预检请求。</td></tr><tr><td>8</td><td>TRACE</td><td>回显服务器收到的请求，主要用于诊断。客户端可以查看请求在服务器中的处理路径。</td></tr><tr><td>9</td><td>CONNECT</td><td>建立一个到服务器的隧道，通常用于 HTTPS 连接。客户端可以通过该隧道发送加密的数据。</td></tr></tbody></table><h3 id="各个版本定义的请求方法"><a href="#各个版本定义的请求方法" class="headerlink" title="各个版本定义的请求方法"></a>各个版本定义的请求方法</h3><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>HTTP&#x2F;1.0 定义了以下三种请求方法：</p><ul><li><strong>GET</strong> - 请求指定的资源。</li><li><strong>POST</strong> - 提交数据以处理请求。</li><li><strong>HEAD</strong> - 请求资源的响应头信息。</li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>HTTP&#x2F;1.1 引入了更多的方法：</p><ul><li><strong>GET</strong> - 请求指定的资源。</li><li><strong>POST</strong> - 提交数据以处理请求。</li><li><strong>HEAD</strong> - 请求资源的响应头信息。</li><li><strong>PUT</strong> - 上传文件或者更新资源。</li><li><strong>DELETE</strong> - 删除指定的资源。</li><li><strong>OPTIONS</strong> - 请求获取服务器支持的请求方法。</li><li><strong>TRACE</strong> - 回显服务器收到的请求，主要用于诊断。</li><li><strong>CONNECT</strong> - 建立一个隧道用于代理服务器的通信，通常用于 HTTPS。</li></ul><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p>HTTP&#x2F;2 基本上沿用了 HTTP&#x2F;1.1 的方法，但对协议进行了优化，提高了传输效率和速度。</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><p>HTTP&#x2F;3 基于 QUIC 协议实现，继续使用 HTTP&#x2F;2 的方法。HTTP&#x2F;3 主要改进了传输层，使用 UDP 代替 TCP 以提高传输速度和可靠性。</p><h2 id="HTTP-响应头信息"><a href="#HTTP-响应头信息" class="headerlink" title="HTTP 响应头信息"></a>HTTP 响应头信息</h2><p>以下是一些常见的 HTTP 响应头信息：</p><table><thead><tr><th align="left">响应头信息（英文）</th><th align="left">响应头信息（中文）</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Date</td><td align="left">日期</td><td align="left">响应生成的日期和时间。例如：Wed, 18 Apr 2024 12:00:00 GMT</td></tr><tr><td align="left">Server</td><td align="left">服务器</td><td align="left">服务器软件的名称和版本。例如：Apache&#x2F;2.4.1 (Unix)</td></tr><tr><td align="left">Content-Type</td><td align="left">内容类型</td><td align="left">响应体的媒体类型（MIME类型），如<code>text/html; charset=UTF-8</code>, <code>application/json</code>等。</td></tr><tr><td align="left">Content-Length</td><td align="left">内容长度</td><td align="left">响应体的大小，单位是字节。例如：3145</td></tr><tr><td align="left">Content-Encoding</td><td align="left">内容编码</td><td align="left">响应体的压缩编码，如 <code>gzip</code>, <code>deflate</code>等。</td></tr><tr><td align="left">Content-Language</td><td align="left">内容语言</td><td align="left">响应体的语言。例如：zh-CN</td></tr><tr><td align="left">Content-Location</td><td align="left">内容位置</td><td align="left">响应体的 URI。例如：&#x2F;index.html</td></tr><tr><td align="left">Content-Range</td><td align="left">内容范围</td><td align="left">响应体的字节范围，用于分块传输。例如：bytes 0-999&#x2F;8000</td></tr><tr><td align="left">Cache-Control</td><td align="left">缓存控制</td><td align="left">控制响应的缓存行为, 如 no-cache 表示必须重新请求。</td></tr><tr><td align="left">Connection</td><td align="left">连接</td><td align="left">管理连接的选项，如<code>keep-alive</code>或<code>close</code>，keep-alive 表示连接不会在传输后关闭。</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置 Cookie</td><td align="left">设置客户端的 cookie。例如：sessionId&#x3D;abc123; Path&#x3D;&#x2F;; Secure</td></tr><tr><td align="left">Expires</td><td align="left">过期时间</td><td align="left">响应体的过期日期和时间。例如：Thu, 18 Apr 2024 12:00:00 GMT</td></tr><tr><td align="left">Last-Modified</td><td align="left">最后修改时间</td><td align="left">资源最后被修改的日期和时间。例如：Wed, 18 Apr 2024 11:00:00 GMT</td></tr><tr><td align="left">ETag</td><td align="left">实体标签</td><td align="left">资源的特定版本的标识符。例如：”33a64df551425fcc55e6”</td></tr><tr><td align="left">Location</td><td align="left">位置</td><td align="left">用于重定向的 URI。例如：&#x2F;newresource</td></tr><tr><td align="left">Pragma</td><td align="left">实现特定的指令</td><td align="left">包含实现特定的指令，如 <code>no-cache</code>。</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">认证信息</td><td align="left">认证信息，通常用于HTTP认证。例如：Basic realm&#x3D;”Access to the site”</td></tr><tr><td align="left">Accept-Ranges</td><td align="left">接受范围</td><td align="left">指定可接受的请求范围类型。例如：bytes</td></tr><tr><td align="left">Age</td><td align="left">经过时间</td><td align="left">响应生成后经过的秒数，从原始服务器生成到代理服务器。例如：24</td></tr><tr><td align="left">Allow</td><td align="left">允许方法</td><td align="left">列出资源允许的 HTTP 方法 。例如：GET, POST，HEAD等</td></tr><tr><td align="left">Vary</td><td align="left">变化</td><td align="left">告诉下游代理如何使用响应头信息来确定响应是否可以从缓存中获取。例如：Accept</td></tr><tr><td align="left">Strict-Transport-Security</td><td align="left">严格传输安全</td><td align="left">指示浏览器仅通过 HTTPS 与服务器通信。例如：max-age&#x3D;31536000; includeSubDomains</td></tr><tr><td align="left">X-Frame-Options</td><td align="left">框架选项</td><td align="left">控制页面是否允许在框架中显示，防止点击劫持攻击。例如：SAMEORIGIN</td></tr><tr><td align="left">X-Content-Type-Options</td><td align="left">内容类型选项</td><td align="left">指示浏览器不要尝试猜测资源的 MIME 类型。例如：nosniff</td></tr><tr><td align="left">X-XSS-Protection</td><td align="left">XSS保护</td><td align="left">控制浏览器的 XSS 过滤和阻断。例如：1; mode&#x3D;block</td></tr><tr><td align="left">Public-Key-Pins</td><td align="left">公钥固定</td><td align="left">HTTP 头信息，用于HTTP公共密钥固定（HPKP），一种安全机制，用于防止中间人攻击。例如：pin-sha256&#x3D;”base64+primarykey”; pin-sha256&#x3D;”base64+backupkey”; max-age&#x3D;expireTime</td></tr></tbody></table><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP 状态码的英文为 <strong>HTTP Status Code</strong>。</p><p>下面是常见的 HTTP 状态码：</p><ul><li><strong>1xx（信息性状态码）</strong>：表示接收的请求正在处理。</li><li><strong>2xx（成功状态码）</strong>：表示请求正常处理完毕。</li><li><strong>3xx（重定向状态码）</strong>：需要后续操作才能完成这一请求。</li><li><strong>4xx（客户端错误状态码）</strong>：表示请求包含语法错误或无法完成。</li><li><strong>5xx（服务器错误状态码）</strong>：服务器在处理请求的过程中发生了错误。</li></ul><h3 id="HTTP-content-type"><a href="#HTTP-content-type" class="headerlink" title="HTTP content-type"></a>HTTP content-type</h3><p>Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Flex补充</title>
    <link href="/2024/11/15/flex%E8%A1%A5%E5%85%85/"/>
    <url>/2024/11/15/flex%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h1><p>来自<a href="https://ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇 - 阮一峰的网络日志</a></p><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/">垂直居中</a>就不容易实现。</p><h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br></code></pre></td></tr></table></figure><p>行内元素也可以使用 Flex 布局。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>  <span class="hljs-attribute">display</span>: inline-flex;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>注意，<strong>设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效</strong>。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p><p>容器默认存在两根轴：<strong>水平的主轴（main axis）和垂直的交叉轴（cross axis）</strong>。</p><p><strong>主轴</strong>的<strong>开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；</strong></p><p><strong>交叉轴</strong>的<strong>开始位置叫做<code>cross start</code>，****结束位置叫做<code>cross end</code>。</strong></p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="三、容器的属性（6个）"><a href="#三、容器的属性（6个）" class="headerlink" title="三、容器的属性（6个）"></a>三、容器的属性（6个）</h2><table><thead><tr><th>属性</th><th>作用</th><th>写法（属性值）</th></tr></thead><tbody><tr><td>flex-direction</td><td>决定主轴的方向（即项目的排列方向）</td><td>row | row-reverse | column | column-reverse;</td></tr><tr><td>flex-wrap</td><td>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</td><td>nowrap | wrap | wrap-reverse</td></tr><tr><td>flex-flow</td><td>是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式</td><td>flex-direction |flex-wrap</td></tr><tr><td>justify-content</td><td>项目在主轴上的对齐方式。</td><td>flex-start | flex-end | center | space-between | space-around</td></tr><tr><td>align-items</td><td>在交叉轴上如何对齐。</td><td>flex-start | flex-end | center | baseline | stretch</td></tr><tr><td>align-content</td><td>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</td><td>flex-start | flex-end | center | space-between | space-around | stretch</td></tr></tbody></table><h2 id="四、项目的属性（6个）"><a href="#四、项目的属性（6个）" class="headerlink" title="四、项目的属性（6个）"></a>四、项目的属性（6个）</h2><table><thead><tr><th>属性</th><th>作用</th><th>写法（属性值）</th></tr></thead><tbody><tr><td>order</td><td>定义项目的排列顺序。数值越小，排列越靠前，默认为0。</td><td>Number值</td></tr><tr><td>flex-grow</td><td>定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</td><td>Number值</td></tr><tr><td>flex-shrink</td><td>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</td><td>Number值</td></tr><tr><td>flex-basis</td><td>定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</td><td>length值（如px后缀）</td></tr><tr><td>flex</td><td>是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</td><td>none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]</td></tr><tr><td>align-self</td><td>允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</td><td>auto | flex-start | flex-end | center | baseline | stretch; }</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础知识整理</title>
    <link href="/2024/11/14/css/"/>
    <url>/2024/11/14/css/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS基础知识整理"><a href="#CSS基础知识整理" class="headerlink" title="CSS基础知识整理"></a>CSS基础知识整理</h1><h5 id="来自：CSS基础知识整理-知乎"><a href="#来自：CSS基础知识整理-知乎" class="headerlink" title="来自：CSS基础知识整理 - 知乎"></a>来自：<a href="https://zhuanlan.zhihu.com/p/68801601">CSS基础知识整理 - 知乎</a></h5><h3 id="1-什么是CSS？"><a href="#1-什么是CSS？" class="headerlink" title="1 什么是CSS？"></a><strong>1 什么是CSS？</strong></h3><p>CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于<strong>设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式</strong>。（总结：设置样式用的）</p><h3 id="2-CSS语法"><a href="#2-CSS语法" class="headerlink" title="2 CSS语法"></a><strong>2 CSS语法</strong></h3><p>CSS基础语法<br>CSS规则由两个主要部分构成：<strong>选择器</strong>以及<strong>一条或多条声明</strong>。</p><h3 id="3-创建CSS"><a href="#3-创建CSS" class="headerlink" title="3 创建CSS"></a><strong>3 创建CSS</strong></h3><p>CSS 创建样式表分为<strong>三种</strong>情况：</p><p><strong>1  内部样式表</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;head&gt;<br>  &lt;style type=&quot;text/CSS&quot;&gt;<br>      选择器 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;<br>      div&#123;width:200px; height:200px; border:1px solid red;&#125;<br>  &lt;/style&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p><strong>2  行内式(内联样式)</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div style=&quot;width:200px;height:100px;border:1px solid black;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><strong>3  外部样式表(外链式)</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;head&gt;<br>  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot;&gt;<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p><strong>样式优先级：内联样式&gt;内部样式&gt;外部样式</strong>（我认为可以理解为越是靠近HTML元素，则优先级越高）</p><h3 id="4-id和class选择器"><a href="#4-id和class选择器" class="headerlink" title="4 id和class选择器"></a><strong>4 id和class选择器</strong></h3><p>ID选择器：HTML元素以 id 属性来设置 id 选择器，CSS 中 id 选择器<strong>以 “#” 来定义</strong>。注意： id 属性不能以数字开头。</p><p>class选择器：用于描述一组元素的样式，也叫做类选择器，可以在多个元素中使用，并且一个元素也可以指定多个类名。在 CSS 中，类选择器<strong>以一个点 “.” 号来定义</strong>。</p><p><strong>区别：</strong><br><strong>相同点</strong>：</p><ul><li>都可以应用于任何元素</li></ul><p><strong>不同点</strong>：</p><ul><li>ID 选择器<strong>只能在文档中使用一次</strong>，而类选择器<strong>可以使用多次</strong>。</li><li>可以使用类选择器词列表方法为一个元素同时设置多个样式(也就是一个元素可以制定多个类名)，而ID只能指定一个。</li></ul><h3 id="5-CSS元素选择器"><a href="#5-CSS元素选择器" class="headerlink" title="5 CSS元素选择器"></a><strong>5 CSS元素选择器</strong></h3><p>最常见的CSS选择器就是元素选择器，也就是标签选择器，也就是在HTML中元素的最基本的选择器。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">语法：<br>标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;  或者<br>元素名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;<br></code></pre></td></tr></table></figure><p>标签选择器<strong>最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式</strong>。</p><h1 id="CSS主要内容（重点⭐）"><a href="#CSS主要内容（重点⭐）" class="headerlink" title="CSS主要内容（重点⭐）"></a>CSS主要内容（重点⭐）</h1><h5 id=""><a href="#" class="headerlink" title="&lt;注意：接受值以一些特定的值来概括情况，如使用left概括right，top概括bottom，red概括所有颜色等&gt;"></a>&lt;注意：接受值以一些特定的值来概括情况，如使用left概括right，top概括bottom，red概括所有颜色等&gt;</h5><h3 id="6-CSS背景-background"><a href="#6-CSS背景-background" class="headerlink" title="6 CSS背景(background)"></a><strong>6 CSS背景(background)</strong></h3><p>background 属性用于定义 HTML 元素的背景， CSS 属性有<strong>五</strong>种：</p><table><thead><tr><th>属性</th><th>作用</th><th>接受值</th></tr></thead><tbody><tr><td>background-color</td><td>背景颜色</td><td>red&#x2F;rgb(0,0,0)</td></tr><tr><td>background-image</td><td>背景图像</td><td>url()</td></tr><tr><td>background-repeat</td><td>背景图像设置水平或垂直平铺或不平铺</td><td>no-repeat&#x2F;repeat&#x2F;repeat-x(y)&#x2F;inherit</td></tr><tr><td>background-position</td><td>背景图像设置定位</td><td>center&#x2F;left&#x2F;left top</td></tr><tr><td>background-attachment</td><td>背景图像设置固定或滚动</td><td>scroll&#x2F;fixed&#x2F;local</td></tr></tbody></table><p>背景属性<strong>简写</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">body&#123;<br>    background:green url(&#x27;images/fix.gif&#x27;) no-repeat fixed 12px 24px;<br>&#125;<br>当使用简写属性时，属性值的顺序依次为：<br>background-color --&gt; background-image --&gt; background-repeat --&gt; <br>background-attachment --&gt; background-position<br></code></pre></td></tr></table></figure><h3 id="7-CSS外观属性"><a href="#7-CSS外观属性" class="headerlink" title="7 CSS外观属性"></a><strong>7 CSS外观属性</strong></h3><p>CSS文本格式主要分为：<strong>文本颜色(color)、文本对齐方式、文本修饰、文本阴影、文本缩进、文本间距、字间距、文本空白处理、文本转换</strong>。</p><table><thead><tr><th>属性</th><th>作用</th><th>接受值</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td><td>red&#x2F;rgb(0,0,0)</td></tr><tr><td>text-align</td><td>文本对齐方式</td><td>left&#x2F;center&#x2F;justify&#x2F;inherit</td></tr><tr><td>text-decoration</td><td>文本修饰：用来设置或删除文本的修饰。主要是用来删除超链接的下划线，也可以使用其他值来设置文本的修饰</td><td>none&#x2F;underline&#x2F;overline&#x2F;line-through&#x2F;blink&#x2F;inherit</td></tr><tr><td>text-shadow</td><td>设置文本阴影</td><td><em>h-shadow v-shadow blur color</em></td></tr><tr><td>text-indent</td><td>文本缩进：用来指定文本的首行缩进，允许为负值，如果值是负数，第一行则向左缩进。</td><td>length&#x2F;%&#x2F;inherit</td></tr><tr><td>line-height</td><td>文本间距：行高，也就是文本行的高度</td><td>normal&#x2F;number&#x2F;length&#x2F;%&#x2F;inherit</td></tr><tr><td>letter-spacing &#x2F; word-spacing</td><td>这两个属性都可用来增加或减少文本间的空白，即字间距。不同的是：letter-spacing 属性<strong>设置字符间距</strong>，而 word-spacing 属性<strong>设置单词间距</strong>。</td><td>normal&#x2F;length&#x2F;inherit</td></tr><tr><td>white-space</td><td>文本空白处理：指定元素内的空白如何处理，默认值为 normal 空白，会被浏览器忽略。</td><td>normal&#x2F;pre&#x2F;nowrap&#x2F;pre-wrap&#x2F;pre-line&#x2F;inherit</td></tr><tr><td>text-transform</td><td>文本转换：是用来指定在一个文本中的大写和小写字母，可用于将所有字句变成大写或小写字母，或每个单词的首字母大写。</td><td>none&#x2F;capitalize&#x2F;uppercase&#x2F;lowercase&#x2F;inherit</td></tr></tbody></table><h3 id="8-CSS字体-font"><a href="#8-CSS字体-font" class="headerlink" title="8 CSS字体 (font)"></a><strong>8 CSS字体 (font)</strong></h3><p>font 属性可用于<strong>设置文本字体，定义样式，如加粗，大小等，属于复合属性</strong>，也叫做简写属性。</p><p>简写顺序：<br>font-style(字体样式) –&gt; font-variant(字体变形) –&gt; font-weight(字体加粗) –&gt; font-size(字体大小)&#x2F;line-height –&gt; font-family(设置文本字体)<br>注意，<strong>font-size</strong> 和 <strong>font-family</strong> 的值是必需的，否则无效。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>font-style</td><td>字体样式</td></tr><tr><td>font-variant</td><td>字体变形：该属性主要用于<strong>定义小型大写字母文本</strong>。</td></tr><tr><td>font-weight</td><td>字体粗细</td></tr><tr><td>font-size</td><td>字体大小</td></tr><tr><td>font-family</td><td>设置文本字体</td></tr></tbody></table><h3 id="9-CSS链接"><a href="#9-CSS链接" class="headerlink" title="9 CSS链接"></a><strong>9 CSS链接</strong></h3><p>链接的<strong>四种状态</strong>是：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>a:link</td><td>正常，<strong>未访问过</strong>的链接。</td></tr><tr><td>a:visited</td><td><strong>已访问过</strong>的链接。</td></tr><tr><td>a:hover</td><td>当鼠标<strong>滑动到链接上</strong>时。</td></tr><tr><td>a:active</td><td>链接<strong>被点击的那一刻</strong>。</td></tr></tbody></table><h3 id="11-CSS表格"><a href="#11-CSS表格" class="headerlink" title="11 CSS表格"></a><strong>11 CSS表格</strong></h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>border</td><td>表格边框</td></tr><tr><td>width &#x2F; height</td><td>表格宽度&#x2F;高度</td></tr><tr><td>text-align &#x2F; vertical-align</td><td>表格对齐</td></tr><tr><td>tr,td的padding设置</td><td>表格内边距</td></tr></tbody></table><h3 id="12-CSS-选择器"><a href="#12-CSS-选择器" class="headerlink" title="12 CSS 选择器"></a><strong>12 CSS 选择器</strong></h3><p><strong>1 分组和嵌套选择器</strong></p><ul><li>分组选择器</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">例如：h1&#123;color:gray;&#125;<br>      p&#123;color:gray;&#125;<br>可以写成：h1, p&#123;color:gray;&#125;<br></code></pre></td></tr></table></figure><ul><li>嵌套选择器，例如：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">.div1 p&#123;<br>     color:white;<br>&#125;<br>.div1 p a&#123;<br>     color:yellow;<br>     font-weight:bold;<br>&#125;<br>&lt;div class=&quot;div1&quot;&gt;<br>     &lt;p&gt;嵌套选择器<br>         &lt;a href=&quot;#&quot;&gt;深层嵌套选择器&lt;/a&gt;<br>     &lt;/p&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ul><li>通配符选择器（默认全部属性)</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">*&#123;<br>       padding:0;<br>       margin:0;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2 属性选择器</strong></p><ul><li>属性选择器：<strong>属性选择器使用[attr]</strong> ；例如：把<strong>所有带有 title 属性的元素的字体设置为红色</strong></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;head&gt;<br>    &lt;style&gt;<br>        [title]&#123;<br>            color:red;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;h1 标题不带有 title 属性&lt;/h1&gt;<br>    &lt;h2 title=&quot;标题&quot;&gt;h2 可以设置样式&lt;/h2&gt;<br>    &lt;a href=&quot;#&quot; title=&quot;链接&quot;&gt;超链接可以设置样式&lt;/a&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><ul><li>属性和值选择器：属性选择器使用**[attr&#x3D;value]**</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;head&gt;<br>    &lt;style&gt;<br>        [title=Hello]&#123;<br>            color:blue;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1 title=&quot;Hello world&quot;&gt;h1 标题 title=&quot;Hello world&quot;&lt;/h1&gt;<br>    &lt;h2 title=&quot;Hello&quot;&gt;h2 可以设置样式&lt;/h2&gt;<br>    &lt;a href=&quot;#&quot; title=&quot;Hello&quot;&gt;超链接可以设置样式&lt;/a&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><ul><li>属性和多个值的选择器：使用有两种情况：属性值用空格分隔使用：**[attr~&#x3D;value]<strong>；属性值用连字符分隔则使用：</strong>[attr|&#x3D;value]**<br>例如：把包含 title&#x3D;’Hello’ 的元素的字体设置为绿色，使用 ~ 分隔属性和值</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;head&gt;<br>    &lt;style&gt;<br>        [title~=Hello]&#123;<br>            color:green;<br>        &#125;<br>        [lang|=zh]&#123;<br>            color:gray;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1 title=&quot;world&quot;&gt;h1 标题 title=&quot;world&quot;&lt;/h1&gt;<br>    &lt;h2 title=&quot;Hello&quot;&gt;h2 可以设置样式&lt;/h2&gt;<br>    &lt;h3 title=&quot;Hello Web&quot;&gt;h3 可以设置样式&lt;/h2&gt;<br>    &lt;a href=&quot;#&quot; title=&quot;Hello world&quot;&gt;超链接可以设置样式&lt;/a&gt;<br>    &lt;a href=&quot;#&quot; lang=&quot;zh-TW&quot;&gt;超链接可以设置样式&lt;/a&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><ul><li>表单样式：属性选择器在为不带有 class 或 id 的表单设置样式时特别有用。例如：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;head&gt;<br>    &lt;style&gt;<br>        input[type=&quot;text&quot;]&#123;<br>            width:150px;<br>            display:block;<br>            margin-bottom:5px;<br>            background-color:yellow;<br>        &#125;<br>        input[type=&quot;button&quot;]&#123;<br>            width:120px;<br>            margin-top:5px;<br>            background-color:green;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;form name=&quot;input&quot; action=&quot;demo.php&quot; method=&quot;get&quot;&gt;<br>        用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; placeholder=&quot;请输入登录名&quot;&gt;<br>        昵　称：&lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;请输入角色名&quot;&gt;<br>        &lt;input type=&quot;button&quot; value=&quot;查询&quot;&gt;<br>    &lt;/form&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><strong>3 组合选择器</strong>：组合选择符是包括各种简单选择器的组合方式，组合选择符说明了两个选择器直接的关系。</p><ul><li>后代选则器:又称为包含选择器，<strong>以空格分隔</strong>，子元素选择器只能选择作为某元素子元素的元素。</li><li>子元素选择器:子元素选择器只能选择作为某元素子元素的元素，以 &gt; 分隔，子元素选择器只能选择作为某元素子元素的元素。</li><li>相邻兄弟选择器：可选择紧接在另一元素后的元素，且二者有相同父元素，<strong>以 + 分隔</strong>。</li><li>普通相邻兄弟选择器：选取所有指定元素的相邻兄弟元素，<strong>以 ~ 分隔</strong>。</li><li>选择器组合：<strong>多种选择器可以结合起来使用</strong>。</li></ul><h3 id="13-CSS伪类-不区分大小写"><a href="#13-CSS伪类-不区分大小写" class="headerlink" title="13 CSS伪类(不区分大小写)"></a><strong>13 CSS伪类(不区分大小写)</strong></h3><p>CSS 伪类是用来向一些选择器添加特殊的效果。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">语法：选择器:伪类&#123;attr:value;&#125;<br></code></pre></td></tr></table></figure><p>CSS 类也可以使用伪类：选择器.class:伪类{attr:value;}</p><p>(1)<strong>超链接伪类</strong>（CSS链接)</p><p>在浏览器中，链接的不同状态都可以以不同的方式显示：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>a:link{color:#FF0000;}</td><td>&#x2F;* 未访问的链接显示为红色 *&#x2F;</td></tr><tr><td>a:visited{color:#00FF00;}</td><td>&#x2F;* 已访问的链接显示为绿色 *&#x2F;</td></tr><tr><td>a:hover{color:#FF00FF;}</td><td>&#x2F;* 鼠标划过链接显示为紫红色 *&#x2F;</td></tr><tr><td>a:active{color:#0000FF;}</td><td>&#x2F;* 已选中的链接显示为蓝色 *&#x2F;</td></tr></tbody></table><p>注意： 在 CSS 定义中，<strong>a:hover 必须被置于 a:link 和 a:visited 之后，a:active 必须被置于 a:hover 之后，才是有效的。</strong></p><p>(2)伪类和 CSS 类(<strong>伪类可以与 CSS 类配合使用</strong>)</p><p>(3)CSS2 - :<strong>first - child</strong> 伪类</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;body&gt;<br>    &lt;p&gt;第一个 p 元素&lt;/p&gt;<br>    &lt;p&gt;第二个 p 元素&lt;/p&gt;<br>    &lt;p&gt;第三个 p 元素&lt;/p&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>选择作为<strong>任何元素的第一个子元素 p</strong>。选择器使用 p:first-child。<br>选择所有 <strong>p 元素中的第一个子元素 b</strong>。选择器使用 p&gt;b:first-child。<br><strong>选择所有作为第一个子元素 p 中的所有 b 元素</strong>。选择器使用 p:first-child b。<br>(4)CSS2 - :<strong>lang 伪类</strong><br>使用 :lang 伪类可以为不同的语言定义特殊的规则：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">html:lang(zh-CN)&#123;<br>    color:blue;<br>&#125;<br><br>:lang(en)&gt;p&#123;<br>    color:gray;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-CSS-伪元素"><a href="#14-CSS-伪元素" class="headerlink" title="14 CSS 伪元素"></a><strong>14 CSS 伪元素</strong></h3><p>CSS 伪元素是用来为一些选择器添加特殊的效果。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">语法：选择器:伪元素&#123;attr:value;&#125;<br></code></pre></td></tr></table></figure><p>(1)CSS2 - :before 伪元素</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">h1:before&#123;<br>     content:url(images/logo.gif);<br>&#125;<br></code></pre></td></tr></table></figure><p>(2)CSS2 - :after 伪元素</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">h1:after&#123;<br>     content:url(images/logo.gif);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>content 属性与 :before 及 :after 伪元素配合使用，来插入生成内容</strong>，该属性用于定义<strong>元素之前</strong>或<strong>之后</strong>放置的生成内容。</p><p><strong>content 的内容一般可以为四种</strong>：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>content:none</td><td>该值是默认值，不插入内容。</td></tr><tr><td>content:”string”</td><td>插入文本。</td></tr><tr><td>content:attr(属性)</td><td>插入标签属性值。</td></tr><tr><td>content:url(路径)</td><td>使用指定的绝对或相对地址插入一个外部资源，可以是图像，音频，视频或浏览器支持的其他任何资源。</td></tr></tbody></table><h3 id="15-块级元素和行内元素"><a href="#15-块级元素和行内元素" class="headerlink" title="15 块级元素和行内元素"></a><strong>15 块级元素和行内元素</strong></h3><p><strong>块级元素(block-level)<strong>：</strong>每个块元素通常都会独自占据一整行或多整行</strong>，<strong>可以</strong>对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。</p><p>常见的块元素有**<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li><strong>等，其中</strong><div>**标签是最典型的块元素。</p><p><strong>行内元素(inline-level)<strong>：</strong>不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构</strong>，一般<strong>不可以</strong>设置高度，宽度，对齐等属性，常用于控制页面中文本的样式。</p><p>常见的行内元素有<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>等，其中<span>标签最典型的行内元素。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意</strong>：</h4><ol><li><p>只有文字才能组成段落，因此p里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</p></li><li><p>链接里面不能再放链接。</p></li></ol><h3 id="16-行内块元素-inline-block"><a href="#16-行内块元素-inline-block" class="headerlink" title="16 行内块元素(inline-block)"></a><strong>16 行内块元素(inline-block)</strong></h3><p>在行内元素中有几个特殊的标签——<img />、<input />、<td>，可<strong>以对它们设置宽高和对齐属性</strong>，有些资料<strong>可能会称它们为行内块元素</strong>。<br>行内块元素的特点：</p><ul><li><strong>和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。</strong></li><li><strong>默认宽度就是它本身内容的宽度。</strong></li><li><strong>高度，行高、外边距以及内边距都可以控制。</strong></li></ul><h3 id="17-CSS-三大特性"><a href="#17-CSS-三大特性" class="headerlink" title="17 CSS 三大特性"></a><strong>17 CSS 三大特性</strong></h3><p><strong>层叠、继承、优先级</strong></p><h3 id="18-盒子模型（CSS重点⭐⭐⭐）"><a href="#18-盒子模型（CSS重点⭐⭐⭐）" class="headerlink" title="18 盒子模型（CSS重点⭐⭐⭐）"></a><strong>18 盒子模型（CSS重点⭐⭐⭐）</strong></h3><p><strong>CSS三大模块： 盒子模型 、浮动 、定位。</strong></p><p>盒子模型：就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的<strong>内容</strong>、<strong>内边距（padding）</strong>、<strong>边框（border）</strong>和<strong>外边距（margin）</strong>组成。（由外而内：MBPC）</p><p><strong>盒子边框（border）:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">语法：border : border-width || border-style || border-color <br>常用属性值：none：没有边框即忽略所有边框的宽度（默认值）、solid线(单实线)、dashed(虚线)、<br>dotted(点线)、double(双实线)<br></code></pre></td></tr></table></figure><h3 id="19-实现居中"><a href="#19-实现居中" class="headerlink" title="19 实现居中"></a><strong>19 实现居中</strong></h3><p><strong>1 外边距实现盒子居中</strong></p><p>满足两个条件：</p><ul><li>必须是<strong>块级</strong>元素。</li><li>盒子必须<strong>指定了宽度</strong>（width）<br>然后给元素<strong>左右的外边距都设置为auto</strong>。</li></ul><p><strong>2 文字盒子居中</strong></p><ul><li>文字水平居中是 text-align: center</li><li>盒子水平居中 左右margin 改为 auto</li></ul><h3 id="20-盒子模型布局稳定性"><a href="#20-盒子模型布局稳定性" class="headerlink" title="20 盒子模型布局稳定性"></a><strong>20 盒子模型布局稳定性</strong></h3><p>按照优先使用宽度 （width）、其次 使用内边距（padding）、再次 外边距（margin）。<br>width &gt; padding &gt; margin</p><p><strong>原因</strong>：</p><ul><li><strong>margin 会有外边距合并</strong> 还有 ie6下面margin 加倍的bug，所以最后使用。</li><li><strong>padding 会影响盒子大小</strong>， 需要进行加减计算（麻烦） 其次使用。</li><li><strong>width 没有问题</strong>，我们经常使用宽度剩余法 高度剩余法来做。</li></ul><h3 id="21-盒子阴影"><a href="#21-盒子阴影" class="headerlink" title="21 盒子阴影"></a><strong>21 盒子阴影</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">语法： box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色  内/外阴影；<br></code></pre></td></tr></table></figure><h2 id="CSS的定位机制有3种：普通流（标准流）、浮动和定位。"><a href="#CSS的定位机制有3种：普通流（标准流）、浮动和定位。" class="headerlink" title="CSS的定位机制有3种：普通流（标准流）、浮动和定位。"></a>CSS的定位机制<strong>有3种</strong>：普通流（标准流）、浮动和定位。</h2><h3 id="22-浮动-float"><a href="#22-浮动-float" class="headerlink" title="22 浮动(float)"></a><strong>22 浮动(float)</strong></h3><p><strong>浮动</strong>：是指设置了浮动属性的元素会<strong>脱离标准普通流的控制</strong>，移动到其<strong>父元素</strong>中<strong>指定位置</strong>的过程。<br><strong>语法</strong>：选择器{float:属性值;} 属性值可以是left，right，both，inherit (浮动方式继承父元素)，none。<br><strong>目的</strong>：为了让多个块级元素同一行上显示。</p><h3 id="23-定位-position"><a href="#23-定位-position" class="headerlink" title="23 定位(position)"></a><strong>23 定位(position)</strong></h3><p>position 属性值分为四种：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>static</td><td>自动定位（默认定位方式），所谓静态位置就是各个元素在HTML文档流中默认的位置。</td></tr><tr><td>relative</td><td>相对定位，相对定位是将元素相对于它在标准流中的位置进行定位</td></tr><tr><td>absolute</td><td>绝对定位，相对于其上一个已经定位的父元素进行定位</td></tr><tr><td>fixed</td><td>固定定位，相对于浏览器窗口进行定位。它的特点在于它的元素跟父亲没有任何关系，只认浏览器；完全脱标，不占有位置，不随着滚动条滚动。</td></tr><tr><td>sticky</td><td>粘滞定位，使用top、right、bottom、left设置一个过渡点，当<strong>超过这个过度点的时候</strong>，就会体现<strong>fixed</strong>固定在页面上。</td></tr></tbody></table><p><strong>叠放次序</strong>（z-index的特点：</p><ul><li><strong>z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上</strong>。</li><li>如果<strong>取值相同，则根据书写顺序，后来居上</strong>。</li><li>后面数字一定<strong>不能</strong>加单位。</li><li><strong>只有相对定位，绝对定位，固定定位有此属性</strong>，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性</li></ul><h3 id="24-布局display-主要flex⭐"><a href="#24-布局display-主要flex⭐" class="headerlink" title="24 布局display(主要flex⭐)"></a>24 布局display(主要flex⭐)</h3><h4 id="来自博客①：html-CSS-display-属性详解-小白的前端之路-SegmentFault-思否"><a href="#来自博客①：html-CSS-display-属性详解-小白的前端之路-SegmentFault-思否" class="headerlink" title="来自博客①：html - CSS display 属性详解 - 小白的前端之路 - SegmentFault 思否"></a>来自博客①：<a href="https://segmentfault.com/a/1190000009636727">html - CSS display 属性详解 - 小白的前端之路 - SegmentFault 思否</a></h4><h4 id="博客②：Flex-布局教程：语法篇-阮一峰的网络日志"><a href="#博客②：Flex-布局教程：语法篇-阮一峰的网络日志" class="headerlink" title="博客②：Flex 布局教程：语法篇 - 阮一峰的网络日志"></a>博客②：<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇 - 阮一峰的网络日志</a></h4><p>CSS display 属性设置元素是否被视为块级或行级盒子以及用于子元素的布局，例如<strong>流式布局</strong>、<strong>网格布局</strong>或<strong>弹性布局</strong>。</p><p>形式上，display 属性<strong>设置元素的内部和外部的显示类型</strong>。</p><table><thead><tr><th align="left">属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">none</td><td align="left">此元素不会被显示。</td></tr><tr><td align="left">block</td><td align="left">此元素将显示为<strong>块级</strong>元素，此元素前后会带有换行符。</td></tr><tr><td align="left">inline</td><td align="left">默认。此元素会被显示为<strong>内联元素，元素前后没有换行符</strong>。</td></tr><tr><td align="left">inline-block</td><td align="left"><strong>行内块元素。</strong>（CSS2.1 新增的值）</td></tr><tr><td align="left"><strong>flex</strong></td><td align="left"><strong>弹性布局属性</strong>⭐</td></tr></tbody></table><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>注意，<strong>设为<code>Flex</code>布局以后，子元素的<code>float、clear</code>和<code>vertical-align</code>属性将失效。</strong><br>主要属性有两大类：<strong>容器属性</strong>和<strong>项目的属性</strong></p><h4 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h4><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>flex-direction</td><td>决定主轴的方向（即项目的排列方向）</td></tr><tr><td>flex-wrap</td><td>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，<strong>如何换行</strong>。</td></tr><tr><td>flex-flow</td><td>是**<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式**，默认值为<code>row nowrap</code>。</td></tr><tr><td>justify-content</td><td>定义了项目在<strong>主轴上</strong>的对齐方式。</td></tr><tr><td>align-items</td><td>定义项目在<strong>交叉轴</strong>上如何对齐。</td></tr><tr><td>align-content</td><td>定义了<strong>多根轴线的对齐方式</strong>。如果项目只有一根轴线，该属性不起作用。</td></tr></tbody></table><h4 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h4><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>order</td><td>定义项目的排列顺序。数值越小，排列越靠前，默认为0。</td></tr><tr><td>flex-grow</td><td>定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</td></tr><tr><td>flex-shrink</td><td>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</td></tr><tr><td>flex-basis</td><td>定义了在<strong>分配多余空间之前，项目占据的主轴空间</strong>（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</td></tr><tr><td>flex</td><td><strong>是<code>flex-grow, flex-shrink 和 flex-basis</code>的简写</strong>，默认值为<code>0 1 auto</code>。后两个属性可选。</td></tr><tr><td>align-self</td><td>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</td></tr></tbody></table><h3 id="25-过渡"><a href="#25-过渡" class="headerlink" title="25 过渡"></a>25 过渡</h3><p>CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>transition</td><td>简写属性，用于在一个属性中设置四个过渡属性。</td></tr><tr><td>transition-property</td><td>规定应用过渡的 CSS 属性的名称。</td></tr><tr><td>transition-duration</td><td>定义过渡效果花费的时间。默认是 0。</td></tr><tr><td>transition-timing-function</td><td>规定过渡效果的时间曲线。默认是 “ease”。</td></tr><tr><td>transition-delay</td><td>规定过渡效果何时开始。默认是 0。</td></tr></tbody></table><h3 id="26-动画"><a href="#26-动画" class="headerlink" title="26 动画"></a>26 动画</h3><p>要创建 CSS3 动画，你需要了解 @keyframes 规则。@keyframes 规则是创建动画。</p><p>@keyframes 规则内指定一个 CSS 样式和动画将逐步从目前的样式更改为新的样式。</p><p>使用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">实例 - &quot;<span class="hljs-selector-tag">from</span>&quot; 和 &quot;<span class="hljs-selector-tag">to</span>&quot;<br><span class="hljs-keyword">@keyframes</span> myfirst<br>&#123; // 由红变黄<br>    <span class="hljs-selector-tag">from</span> &#123;<span class="hljs-attribute">background</span>: red;&#125;<br>    <span class="hljs-selector-tag">to</span> &#123;<span class="hljs-attribute">background</span>: yellow;&#125;<br>&#125;<br> <br><span class="hljs-keyword">@-webkit-keyframes</span> myfirst /* Safari 与 Chrome */<br>&#123;<br>    <span class="hljs-selector-tag">from</span> &#123;<span class="hljs-attribute">background</span>: red;&#125;<br>    <span class="hljs-selector-tag">to</span> &#123;<span class="hljs-attribute">background</span>: yellow;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css">实例 - <span class="hljs-number">0%</span> 和 <span class="hljs-number">100%</span><br><span class="hljs-keyword">@keyframes</span> myfirst<br>&#123;<br>    <span class="hljs-number">0%</span>   &#123;<span class="hljs-attribute">background</span>: red;&#125;<br>    <span class="hljs-number">25%</span>  &#123;<span class="hljs-attribute">background</span>: yellow;&#125;<br>    <span class="hljs-number">50%</span>  &#123;<span class="hljs-attribute">background</span>: blue;&#125;<br>    <span class="hljs-number">100%</span> &#123;<span class="hljs-attribute">background</span>: green;&#125;<br>&#125;<br> <br><span class="hljs-keyword">@-webkit-keyframes</span> myfirst /* Safari 与 Chrome */<br>&#123;<br>    <span class="hljs-number">0%</span>   &#123;<span class="hljs-attribute">background</span>: red;&#125;<br>    <span class="hljs-number">25%</span>  &#123;<span class="hljs-attribute">background</span>: yellow;&#125;<br>    <span class="hljs-number">50%</span>  &#123;<span class="hljs-attribute">background</span>: blue;&#125;<br>    <span class="hljs-number">100%</span> &#123;<span class="hljs-attribute">background</span>: green;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/cssref/css3-pr-animation-keyframes.html">@keyframes</a></td><td>规定动画。</td></tr><tr><td><a href="https://www.runoob.com/cssref/css3-pr-animation.html">animation</a></td><td>所有动画属性的简写属性。</td></tr><tr><td><a href="https://www.runoob.com/cssref/css3-pr-animation-name.html">animation-name</a></td><td>规定 @keyframes  动画的名称。</td></tr><tr><td><a href="https://www.runoob.com/cssref/css3-pr-animation-duration.html">animation-duration</a></td><td>规定动画完成一个周期所花费的秒或毫秒。默认是  0。</td></tr><tr><td><a href="https://www.runoob.com/cssref/css3-pr-animation-timing-function.html">animation-timing-function</a></td><td>规定动画的速度曲线。默认是  “ease”。</td></tr><tr><td><a href="https://www.runoob.com/cssref/css3-pr-animation-fill-mode.html">animation-fill-mode</a></td><td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。</td></tr><tr><td><a href="https://www.runoob.com/cssref/css3-pr-animation-delay.html">animation-delay</a></td><td>规定动画何时开始。默认是 0。</td></tr><tr><td><a href="https://www.runoob.com/cssref/css3-pr-animation-iteration-count.html">animation-iteration-count</a></td><td>规定动画被播放的次数。默认是 1。</td></tr><tr><td><a href="https://www.runoob.com/cssref/css3-pr-animation-direction.html">animation-direction</a></td><td>规定动画是否在下一周期逆向地播放。默认是  “normal”。</td></tr><tr><td><a href="https://www.runoob.com/cssref/css3-pr-animation-play-state.html">animation-play-state</a></td><td>规定动画是否正在运行或暂停。默认是  “running”。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>来自：[CSS基础知识整理 - 知乎](https://zhuanlan.zhihu.com/p/68801601)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Axios</title>
    <link href="/2024/11/12/axios/"/>
    <url>/2024/11/12/axios/</url>
    
    <content type="html"><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>主要内容来自于 axios 中文官网：<a href="https://www.axios-http.cn/docs/intro">起步 | Axios 中文文档 | Axios 中文网</a></p><p>Axios 是一个基于 <em><a href="https://javascript.info/promise-basics">promise</a></em> 网络请求库，作用于<a href="https://nodejs.org/"><code>node.js</code></a> 和浏览器中。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用 npm:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install axios<br></code></pre></td></tr></table></figure><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>发起一个 <strong><code>GET</code></strong> 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;axios&quot;</span>);<br><br><span class="hljs-comment">// 向给定ID的用户发起请求</span><br>axios<br>  .<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/user?ID=12345&quot;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// 处理成功情况</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 处理错误情况</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 总是会执行</span><br>  &#125;);<br><br><span class="hljs-comment">// 上述请求也可以按以下方式完成（可选）</span><br>axios<br>  .<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/user&quot;</span>, &#123;<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">ID</span>: <span class="hljs-number">12345</span>,<br>    &#125;,<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 总是会执行</span><br>  &#125;);<br><br><span class="hljs-comment">// 支持async/await用法</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/user?ID=12345&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p>发起一个 <code>POST</code> 请求，在<strong>url 后面多传递一个 post 的数据</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">axios<br>  .<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/user&quot;</span>, &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Fred&quot;</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Flintstone&quot;</span>,<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="Axios-API"><a href="#Axios-API" class="headerlink" title="Axios API"></a>Axios API</h3><p>可以向 <code>axios</code> 传递相关配置来创建请求</p><h5 id="axios-config"><a href="#axios-config" class="headerlink" title="axios(config)"></a>axios(config)<a href="https://www.axios-http.cn/docs/api_intro#axiosconfig"></a></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 发起一个post请求</span><br><span class="hljs-title function_">axios</span>(&#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;post&quot;</span>,<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/user/12345&quot;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Fred&quot;</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Flintstone&quot;</span>,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Axios-实例-⭐⭐⭐"><a href="#Axios-实例-⭐⭐⭐" class="headerlink" title="Axios 实例 ⭐⭐⭐"></a>Axios 实例 ⭐⭐⭐</h2><h4 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例<a href="https://www.axios-http.cn/docs/instance#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B"></a></h4><p>您可以使用自定义配置新建一个实例。</p><h5 id="axios-create-config"><a href="#axios-create-config" class="headerlink" title="axios.create([config])"></a>axios.create([config])<a href="https://www.axios-http.cn/docs/instance#axioscreateconfig"></a></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&quot;https://some-domain.com/api/&quot;</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>,<br>  <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&quot;X-Custom-Header&quot;</span>: <span class="hljs-string">&quot;foobar&quot;</span> &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>这些是创建请求时可以用的配置选项。<strong>只有 <code>url</code> 是必需的。如果没有指定 <code>method</code>，请求将默认使用 <code>GET</code> 方法。</strong><a href="https://www.axios-http.cn/docs/req_config">请求配置 | Axios 中文文档 | Axios 中文网</a></p><h2 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h2><p>一个请求的响应包含以下信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-comment">// `data` 由服务器提供的响应</span><br>  <span class="hljs-attr">data</span>: &#123;&#125;,<br><br>  <span class="hljs-comment">// `status` 来自服务器响应的 HTTP 状态码</span><br>  <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,<br><br>  <span class="hljs-comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span><br>  <span class="hljs-attr">statusText</span>: <span class="hljs-string">&#x27;OK&#x27;</span>,<br><br>  <span class="hljs-comment">// `headers` 是服务器响应头</span><br>  <span class="hljs-comment">// 所有的 header 名称都是小写，而且可以使用方括号语法访问</span><br>  <span class="hljs-comment">// 例如: `response.headers[&#x27;content-type&#x27;]`</span><br>  <span class="hljs-attr">headers</span>: &#123;&#125;,<br><br>  <span class="hljs-comment">// `config` 是 `axios` 请求的配置信息</span><br>  <span class="hljs-attr">config</span>: &#123;&#125;,<br><br>  <span class="hljs-comment">// `request` 是生成此响应的请求</span><br>  <span class="hljs-comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span><br>  <span class="hljs-comment">// 在浏览器中则是 XMLHttpRequest 实例</span><br>  <span class="hljs-attr">request</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当使用 <code>then</code> 时，将接收如下响应:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/user/12345&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">status</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">statusText</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">headers</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">config</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>当使用 <code>catch</code>，或者传递一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">rejection callback</a>作为 <code>then</code> 的第二个参数时，响应可以通过 <code>error</code> 对象被使用，正如在<a href="https://www.axios-http.cn/docs/handling_errors">错误处理</a>部分解释的那样。</p><h2 id="拦截器-⭐⭐⭐"><a href="#拦截器-⭐⭐⭐" class="headerlink" title="拦截器 ⭐⭐⭐"></a>拦截器 ⭐⭐⭐</h2><p>在<strong>请求或响应被 then 或 catch 处理前拦截</strong>它们，一般可以用来添加 token 等功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 添加请求拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// 在发送请求之前做些什么</span><br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 对请求错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><br><span class="hljs-comment">// 添加响应拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// 2xx 范围内的状态码都会触发该函数。</span><br>    <span class="hljs-comment">// 对响应数据做点什么</span><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 超出 2xx 范围的状态码都会触发该函数。</span><br>    <span class="hljs-comment">// 对响应错误做点什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>如果你稍后需要移除拦截器，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myInterceptor = axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">/*...*/</span><br>&#125;);<br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">eject</span>(myInterceptor);<br></code></pre></td></tr></table></figure><p>可以给自定义的 axios 实例添加拦截器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>();<br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">/*...*/</span><br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>token</title>
    <link href="/2024/11/11/%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/11/11/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="来源：Token-的作用及原理-token-作用及原理-CSDN-博客"><a href="#来源：Token-的作用及原理-token-作用及原理-CSDN-博客" class="headerlink" title="来源：Token 的作用及原理_token 作用及原理-CSDN 博客"></a>来源：<a href="https://blog.csdn.net/Huozhiwu_11/article/details/107230718">Token 的作用及原理_token 作用及原理-CSDN 博客</a></h4><h2 id="1、token-作用及原理"><a href="#1、token-作用及原理" class="headerlink" title="1、token 作用及原理"></a><strong>1、token 作用及原理</strong></h2><p>Token，即令牌，是服务器产生的，具有<strong>随机性和不可预测性</strong>，它主要有两个作用：</p><h4 id="（1）防止表单重复提交；"><a href="#（1）防止表单重复提交；" class="headerlink" title="（1）防止表单重复提交；"></a>（1）防止表单重复提交；</h4><p>使用 Token 防表单重复提交步骤：</p><p>① 在服务器端生成一个唯一的随机标识号，专业术语称为 Token(令牌)，同时在当前用户的 Session 域中保存这个 Token；</p><p>② 将 Token 发送到客户端的 Form 表单中，在 Form 表单中使用隐藏域来存储这个 Token，表单提交的时候连同这个 Token 一起提交到服务器端；</p><p>③ 在服务器端判断客户端提交上来的 Token 与服务器端生成的 Token 是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的 Session 域中存储的标识号。</p><h4 id="（2）用来作身份验证"><a href="#（2）用来作身份验证" class="headerlink" title="（2）用来作身份验证"></a>（2）用来作身份验证</h4><p>使用基于 Token 的身份验证流程如下：</p><p>① 用户首次登录，将输入的账号和密码提交给服务器；</p><p>② 服务器对输入内容进行校验，若账号和密码匹配则验证通过，登录成功，并生成一个 token 值，将其保存到数据库，并返回给客户端；</p><p>③ 客户端拿到返回的 token 值将其保存在本地（如 cookie&#x2F;localStorage），作为公共参数，以后每次请求服务器时都携带该 token（放在响应头里），提交给服务器进行校验；</p><p>④ 服务器接收到请求后，首先验证是否携带 token，若携带则取出请求头里的 token 值与数据库存储的 token 进行匹配校验，若 token 值相同则登录成功，且当前正处于登录状态，此时正常返回数据，让 app 显示数据；若不存在或两个值不一致，则说明原来的登录已经失效，此时返回错误状态码，提示用户跳转至登录界面重新登录；</p><p>⑤ 注意：用户<strong>每进行一次登录，登录成功后服务器都会更新一个 token 新值返回给客户端</strong>；</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241107144913277.png" alt="image-20241107144913277"></p><h2 id="2、如何保证-token-安全性"><a href="#2、如何保证-token-安全性" class="headerlink" title="2、如何保证 token 安全性"></a>2、如何保证 token 安全性</h2><p><strong>Token 授权机制：</strong><br>用户使用用户名密码登录后服务器给客户端返回一个 Token（通常是<a href="https://so.csdn.net/so/search?q=UUID&spm=1001.2101.3001.7020">UUID</a>），并将<strong>Token-UserId 以键值对的形式存放在缓存服务器</strong>中。服务端接收到请求后进行 Token 验证，如果 Token 不存在，说明请求无效。Token 是客户端访问服务端的凭证。</p><p><strong>时间戳超时机制：</strong><br>用户每次请求都带上当前时间的时间戳 timestamp，服务端接收到 timestamp 后跟当前时间进行比对，如果<strong>时间差大于一定时间（比如 5 分钟），则认为该请求失效</strong>。时间戳超时机制是防御 DOS 攻击的有效手段。</p><p><strong>签名机制：</strong><br>将 Token 和 时间戳 加上其他请求参数再用 MD5 或 SHA-1 算法（可根据情况加点盐）加密，加密后的数据就是本次请求的签名 sign，服务端接收到请求后以同样的算法得到签名，并跟当前的签名进行比对，如果不一样，说明参数被更改过，直接返回错误标识。签名机制保证了数据不会被篡改。</p><p><strong>拒绝重复调用（非必须）：</strong><br>客户端第一次访问时，将签名 sign 存放到缓存服务器中，超时时间设定为跟时间戳的超时时间一致，二者时间一致可以保证无论在 timestamp 限定时间内还是外 URL 都只能访问一次。如果有人使用同一个 URL 再次访问，如果发现缓存服务器中已经存在了本次签名，则拒绝服务。如果在缓存中的签名失效的情况下，有人使用同一个 URL 再次访问，则会被时间戳超时机制拦截。这就是为什么要求时间戳的超时时间要设定为跟时间戳的超时时间一致。拒绝重复调用机制确保 URL 被别人截获了也无法使用（如抓取数据）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pinia</title>
    <link href="/2024/11/10/pinia/"/>
    <url>/2024/11/10/pinia/</url>
    
    <content type="html"><![CDATA[<h1 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h1><p>教程来源：<a href="https://zhuanlan.zhihu.com/p/533233367">一文搞懂pinia状态管理（保姆级教程） - 知乎</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue项目</title>
    <link href="/2024/11/07/vue%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/11/07/vue%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue项目（jxp-blog"><a href="#Vue项目（jxp-blog" class="headerlink" title="Vue项目（jxp_blog)"></a>Vue项目（jxp_blog)</h1><p>App中设置路由出口：<br><strong>App.vue:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;router-view /&gt;<br>&lt;/template&gt;<br><br>&lt;style&gt;<br>* &#123;<br>  padding: 0;<br>  margin: 0;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>设置路由：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const routes = [<br>  &#123;<br>    <span class="hljs-type">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    component: HomeView,<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><p>在组件HomeView中<strong>设置总体页面布局</strong>（：总体设置两部分，上部分为路由部分，下部分为内容主体部分）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;common-layout&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Main</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Main.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Header</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Header.vue&#x27;</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="header部分：（设置动态路由）"><a href="#header部分：（设置动态路由）" class="headerlink" title="header部分：（设置动态路由）"></a>header部分：（设置动态路由）</h4><p>这里需要理解如何使用路由：使用<strong>useRoute</strong>获取<strong>当前路由信息</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">import</span> &#123; useRoute &#125; from <span class="hljs-string">&#x27;vue-router&#x27;</span><br>const route = useRoute()<br>const Test = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(route) <span class="hljs-comment">// 打印当前路由信息</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(route.fullPath) <span class="hljs-comment">// 打印完整的路径</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(route.name) <span class="hljs-comment">// 打印路由名称</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(route.params) <span class="hljs-comment">// 打印路由参数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用<strong>useRouter</strong>获取<strong>全部路由信息</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Test</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> allRoutes = router.<span class="hljs-title function_">getRoutes</span>() <span class="hljs-comment">// 获取所有路由信息</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allRoutes) <span class="hljs-comment">// 打印全部路由</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Header.vue<strong>设置动态路由和动态路由跳转</strong>： </p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;router&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;routerPush(item.path)&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in routes&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span></span><br><span class="language-xml">            </span><span class="hljs-template-variable">&#123;&#123; item.meta.title &#125;</span><span class="language-xml">&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; onMounted, ref &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; useRouter, useRoute &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> routes = <span class="hljs-title function_">ref</span>([])</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> </span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    routes.value = router.getRoutes()</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml"><span class="language-javascript">)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">routerPush</span> = (<span class="hljs-params">path</span>) =&gt; </span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    // console.log(path)</span><br><span class="hljs-template-variable">    router.push(path)</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="useRouter和useRoute有什么区别？"><a href="#useRouter和useRoute有什么区别？" class="headerlink" title="useRouter和useRoute有什么区别？"></a>useRouter和useRoute有什么区别？</h3><p><code>useRouter</code> 和 <code>useRoute</code> 是 Vue Router 组合式 API 中的两个不同功能的钩子，它们分别用于不同的目的：</p><h3 id="1-useRouter"><a href="#1-useRouter" class="headerlink" title="1. useRouter"></a>1. <code>useRouter</code></h3><ul><li><strong>功能</strong>：<code>useRouter</code> 用于访问和控制路由实例（<code>router</code> 对象），主要用于执行导航操作（例如 <code>push</code>、<code>replace</code>、<code>go</code> 等），控制路由跳转行为。</li><li><strong>用途</strong>：如果你的组件中需要编程式导航，比如在点击按钮后跳转到另一个页面，那么需要使用 <code>useRouter</code>。</li><li><strong>常见方法</strong>：<ul><li><code>router.push()</code>：跳转到指定路由。</li><li><code>router.replace()</code>：跳转到指定路由，但不会留下历史记录。</li><li><code>router.go()</code>：前进或后退指定步数。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();<br>router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/home&#x27;</span>); <span class="hljs-comment">// 跳转到 Home 页</span><br></code></pre></td></tr></table></figure><h3 id="2-useRoute"><a href="#2-useRoute" class="headerlink" title="2. useRoute"></a>2. <code>useRoute</code></h3><ul><li><strong>功能</strong>：<code>useRoute</code> 用于访问当前路由对象（<code>route</code> 对象），可以读取当前路由的信息（例如路径、参数、查询字符串等）。</li><li><strong>用途</strong>：如果你的组件需要知道当前的路由信息，比如根据参数或查询字符串来展示不同内容，那么使用 <code>useRoute</code>。</li><li><strong>常见属性</strong>：<ul><li><code>route.params</code>：获取路由参数（例如 <code>/user/:id</code> 中的 <code>id</code> 参数）。</li><li><code>route.query</code>：获取查询参数（例如 <code>/search?query=vue</code> 中的 <code>query</code> 参数）。</li><li><code>route.name</code>：获取当前路由的名称。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>); <span class="hljs-comment">// 获取当前路由的参数</span><br></code></pre></td></tr></table></figure><ul><li>**<code>useRouter</code>**：用于控制导航（跳转），类似于 <code>$router</code>。</li><li>**<code>useRoute</code>**：用于获取当前路由信息，类似于 <code>$route</code>。</li></ul><h2 id="Vue的自定义指令（自定义指令-Vue-js）"><a href="#Vue的自定义指令（自定义指令-Vue-js）" class="headerlink" title="Vue的自定义指令（自定义指令 | Vue.js）"></a>Vue的自定义指令（<a href="https://cn.vuejs.org/guide/reusability/custom-directives">自定义指令 | Vue.js</a>）</h2><p>除了 Vue 内置的一系列指令 (比如 <code>v-model</code> 或 <code>v-show</code>) 之外，Vue 还允许你注册自定义的指令 (Custom Directives)。</p><p>我们已经介绍了两种在 Vue 中重用代码的方式：<a href="https://cn.vuejs.org/guide/essentials/component-basics.html">组件</a>和<a href="https://cn.vuejs.org/guide/reusability/composables.html">组合式函数</a>。组件是主要的构建模块，而组合式函数则侧重于有状态的逻辑。另一方面，自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。</p><p>一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数。下面是一个自定义指令的例子，当一个 input 元素被 Vue 插入到 DOM 中后，它会被自动聚焦：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 在模板中启用 v-focus</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vFocus = &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">mounted</span>: <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el.<span class="hljs-title function_">focus</span>()</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将一个自定义指令全局注册到应用层级也是一种常见的做法：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> <span class="hljs-keyword">app</span> = createApp(&#123;&#125;)<br><br><span class="hljs-comment">// 使 v-focus 在所有组件中都可用</span><br><span class="hljs-keyword">app</span>.directive(&#x27;focus&#x27;, &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h3><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">const</span> <span class="hljs-variable">myDirective</span> <span class="hljs-operator">=</span> &#123;<br>  <span class="hljs-comment">// 在绑定元素的 attribute 前</span><br>  <span class="hljs-comment">// 或事件监听器应用前调用</span><br>  <span class="hljs-title function_">created</span>(<span class="hljs-params">el</span>, <span class="hljs-params">binding</span>, <span class="hljs-params">vnode</span>) &#123;<br>    <span class="hljs-comment">// 下面会介绍各个参数的细节</span><br>  &#125;,<br>  <span class="hljs-comment">// 在元素被插入到 DOM 前调用</span><br>  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el</span>, <span class="hljs-params">binding</span>, <span class="hljs-params">vnode</span>) &#123;&#125;,<br>  <span class="hljs-comment">// 在绑定元素的父组件</span><br>  <span class="hljs-comment">// 及他自己的所有子节点都挂载完成后调用</span><br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el</span>, <span class="hljs-params">binding</span>, <span class="hljs-params">vnode</span>) &#123;&#125;,<br>  <span class="hljs-comment">// 绑定元素的父组件更新前调用</span><br>  <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params">el</span>, <span class="hljs-params">binding</span>, <span class="hljs-params">vnode</span>, <span class="hljs-params">prevVnode</span>) &#123;&#125;,<br>  <span class="hljs-comment">// 在绑定元素的父组件</span><br>  <span class="hljs-comment">// 及他自己的所有子节点都更新后调用</span><br>  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el</span>, <span class="hljs-params">binding</span>, <span class="hljs-params">vnode</span>, <span class="hljs-params">prevVnode</span>) &#123;&#125;,<br>  <span class="hljs-comment">// 绑定元素的父组件卸载前调用</span><br>  <span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params">el</span>, <span class="hljs-params">binding</span>, <span class="hljs-params">vnode</span>) &#123;&#125;,<br>  <span class="hljs-comment">// 绑定元素的父组件卸载后调用</span><br>  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el</span>, <span class="hljs-params">binding</span>, <span class="hljs-params">vnode</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="钩子参数"><a href="#钩子参数" class="headerlink" title="钩子参数"></a>钩子参数</h3><p>指令的钩子会传递以下几种参数：</p><ul><li><code>el</code>：指令绑定到的元素。这可以用于直接操作 DOM。</li><li><code>binding</code>：一个对象，包含以下属性。<ul><li><code>value</code>：传递给指令的值。例如在 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，值是 <code>2</code>。</li><li><code>oldValue</code>：之前的值，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用。无论值是否更改，它都可用。</li><li><code>arg</code>：传递给指令的参数 (如果有的话)。例如在 <code>v-my-directive:foo</code> 中，参数是 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象 (如果有的话)。例如在 <code>v-my-directive.foo.bar</code> 中，修饰符对象是 <code>&#123; foo: true, bar: true &#125;</code>。</li><li><code>instance</code>：使用该指令的组件实例。</li><li><code>dir</code>：指令的定义对象。</li></ul></li><li><code>vnode</code>：代表绑定元素的底层 VNode。</li><li><code>prevVnode</code>：代表之前的渲染中指令所绑定元素的 VNode。仅在 <code>beforeUpdate</code> 和 <code>updated</code> 钩子中可用。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="/2024/11/06/vue%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/11/06/vue%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nodejs</title>
    <link href="/2024/11/05/nodejs/"/>
    <url>/2024/11/05/nodejs/</url>
    
    <content type="html"><![CDATA[<h1 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h1><h6 id="（来自菜鸟教程：Node-js-教程-菜鸟教程）"><a href="#（来自菜鸟教程：Node-js-教程-菜鸟教程）" class="headerlink" title="（来自菜鸟教程：Node.js 教程 | 菜鸟教程）"></a>（来自菜鸟教程：<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html">Node.js 教程 | 菜鸟教程</a>）</h6><h2 id="Node-js-创建第一个应用"><a href="#Node-js-创建第一个应用" class="headerlink" title="Node.js 创建第一个应用"></a>Node.js 创建第一个应用</h2><h4 id="Node-js-应用是由哪几部分组成的："><a href="#Node-js-应用是由哪几部分组成的：" class="headerlink" title="Node.js 应用是由哪几部分组成的："></a><strong>Node.js 应用是由哪几部分组成的：</strong></h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>require 指令</strong></td><td>使用 require 指令来加载和引入模块，引入的模块可以是内置模块，也可以是第三方模块或自定义模块。</td></tr><tr><td><strong>创建服务器</strong></td><td>服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</td></tr><tr><td><strong>接收请求与响应请求</strong></td><td>客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</td></tr></tbody></table><h4 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a><strong>创建 Node.js 应用</strong></h4><p><strong>步骤一、使用 require 指令来加载和引入模块</strong></p><p>语法格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;module-name&#x27;</span>);<br></code></pre></td></tr></table></figure><p>其中，module-name 可以是一个文件路径（相对或绝对路径），也可以是一个模块名称，如果是一个模块名称，Node.js 会自动从 node_modules 目录中查找该模块。</p><p>require 指令会返回被加载的模块的导出对象，可以通过该对象来访问模块中定义的属性和方法，如果模块中有多个导出对象，则可以使用解构赋值的方式来获取它们。</p><p>我们使用 <strong>require</strong> 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>步骤二、创建服务器</strong></p><p>接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过request, response 参数来接收和响应数据。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> http = require(<span class="hljs-string">&#x27;http&#x27;</span>);  <span class="hljs-comment">//Node.js 自带的 http 模块，并且把它赋值给 http 变量。</span><br><br>http.createServer(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) &#123;<br><span class="hljs-comment">// createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。</span><br>    <span class="hljs-comment">// 发送 HTTP 头部 </span><br>    <span class="hljs-comment">// HTTP 状态值: 200 : OK</span><br>    <span class="hljs-comment">// 内容类型: text/plain</span><br>    response.writeHead(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br><br>    <span class="hljs-comment">// 发送响应数据 &quot;Hello World&quot;</span><br>    response.end(<span class="hljs-string">&#x27;Hello World\n&#x27;</span>);<br>&#125;).listen(<span class="hljs-number">8888</span>);<br><br><span class="hljs-comment">// 终端打印如下信息</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Server running at http://127.0.0.1:8888/&#x27;</span>);<br></code></pre></td></tr></table></figure><p>以上代码我们完成了一个可以工作的 HTTP 服务器。</p><p>使用 <strong>node</strong> 命令执行以上的代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">node server.js<br><span class="hljs-built_in">Server</span> running at http:<span class="hljs-comment">//127.0.0.1:8888/</span><br></code></pre></td></tr></table></figure><p>接下来，打开浏览器访问 <a href="http://127.0.0.1:8888/%EF%BC%8C%E4%BD%A0%E4%BC%9A%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E5%86%99%E7%9D%80">http://127.0.0.1:8888/，你会看到一个写着</a> “Hello World”的网页。</p><h2 id="Node-js-REPL-交互式解释器，了解"><a href="#Node-js-REPL-交互式解释器，了解" class="headerlink" title="*Node.js REPL(交互式解释器，了解)*"></a>*<u><strong>Node.js REPL(交互式解释器，了解)</strong></u>*</h2><p>Node.js REPL(Read Eval Print Loop:交互式解释器) <strong>表示一个电脑的环境</strong>，类似 Windows 系统的终端或 Unix&#x2F;Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p><p>Node 自带了交互式解释器，可以执行下面命令：</p><table><thead><tr><th>读取</th><th><strong>读取用户输入，解析输入的 Javascript 数据结构并存储在内存中</strong></th></tr></thead><tbody><tr><td><strong>执行</strong></td><td><strong>执行输入的数据结构</strong></td></tr><tr><td><strong>打印</strong></td><td><strong>输出结果</strong></td></tr><tr><td><strong>循环</strong></td><td><strong>循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出</strong></td></tr></tbody></table><p>Node 的交互式解释器可以很好的调试 Javascript 代码，可以输入以下命令来启动 Node 的终端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd终端">$ node<br>&gt;<br></code></pre></td></tr></table></figure><p>可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。</p><h2 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a>Node.js 事件循环</h2><h4 id="事件驱动程序："><a href="#事件驱动程序：" class="headerlink" title="事件驱动程序："></a><strong>事件驱动程序：</strong></h4><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p><p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p><p>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241027160314799.png" alt="image-20241027160314799"></p><p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node">// 引入 events 模块<br>var events = require(&#x27;events&#x27;);<br>// 创建 eventEmitter 对象<br>var eventEmitter = new events.EventEmitter();<br></code></pre></td></tr></table></figure><p>以下程序绑定事件处理程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node">// 绑定事件及事件的处理程序<br>eventEmitter.on(&#x27;eventName&#x27;, eventHandler);<br></code></pre></td></tr></table></figure><p>可以通过程序触发事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node">// 触发事件<br>eventEmitter.emit(&#x27;eventName&#x27;);<br></code></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>创建 main.js 文件，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs node">// 引入 events 模块<br>var events = require(&#x27;events&#x27;);<br>// 创建 eventEmitter 对象<br>var eventEmitter = new events.EventEmitter();<br><br>// 创建事件处理程序<br>var connectHandler = function connected() &#123;<br>   console.log(&#x27;连接成功。&#x27;);<br><br>   // 触发 data_received 事件 <br>   eventEmitter.emit(&#x27;data_received&#x27;);<br>&#125;<br><br>// 绑定 connection 事件处理程序<br>eventEmitter.on(&#x27;connection&#x27;, connectHandler);<br><br>// 使用匿名函数绑定 data_received 事件<br>eventEmitter.on(&#x27;data_received&#x27;, function()&#123;<br>   console.log(&#x27;数据接收成功。&#x27;);<br>&#125;);<br><br>// 触发 connection 事件 <br>eventEmitter.emit(&#x27;connection&#x27;);<br><br>console.log(&quot;程序执行完毕。&quot;);<br></code></pre></td></tr></table></figure><p>执行以上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node">$ node main.js<br>连接成功。<br>数据接收成功。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><h4 id="Node-应用程序是如何工作的？"><a href="#Node-应用程序是如何工作的？" class="headerlink" title="Node 应用程序是如何工作的？"></a>Node 应用程序是如何工作的？</h4><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p><h2 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h2><p>Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。</p><p>Node.js 里面的<strong>许多对象都会分发事件</strong>：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 <strong>所有这些产生事件的对象都是 events.EventEmitter 的实例</strong>。</p><h4 id="EventEmitter-类（events-EventEmitter）"><a href="#EventEmitter-类（events-EventEmitter）" class="headerlink" title="EventEmitter 类（events.EventEmitter）"></a>EventEmitter 类（events.EventEmitter）</h4><p>events 模块只提供了一个对象： <strong>events.EventEmitter</strong>。EventEmitter 的核心就是事件触发与事件监听器功能的封装。可以通过require(“events”);来访问该模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node">// 引入 events 模块<br>var events = require(&#x27;events&#x27;);<br>// 创建 eventEmitter 对象<br>var eventEmitter = new events.EventEmitter();<br></code></pre></td></tr></table></figure><p>EventEmitter 对象<strong>如果在实例化时发生错误，会触发 error 事件</strong>。当<strong>添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs node">//event.js 文件<br>var EventEmitter = require(&#x27;events&#x27;).EventEmitter; <br>var event = new EventEmitter(); <br>event.on(&#x27;some_event&#x27;, function() &#123; <br>    console.log(&#x27;some_event 事件触发&#x27;); <br>&#125;); <br>setTimeout(function() &#123; <br>    event.emit(&#x27;some_event&#x27;); <br>&#125;, 1000); <br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p>运行这段代码，1 秒后控制台输出了 **’some_event 事件触发’**。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node">$ node event.js <br>some_event 事件触发<br></code></pre></td></tr></table></figure><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p><p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p><p>让我们以下面的例子解释这个过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs node">//event.js 文件<br>var events = require(&#x27;events&#x27;); <br>var emitter = new events.EventEmitter(); <br>emitter.on(&#x27;someEvent&#x27;, function(arg1, arg2) &#123; <br>    console.log(&#x27;listener1&#x27;, arg1, arg2); <br>&#125;); <br>emitter.on(&#x27;someEvent&#x27;, function(arg1, arg2) &#123; <br>    console.log(&#x27;listener2&#x27;, arg1, arg2); <br>&#125;); <br>emitter.emit(&#x27;someEvent&#x27;, &#x27;arg1 参数&#x27;, &#x27;arg2 参数&#x27;); <br></code></pre></td></tr></table></figure><p>执行以上代码，运行的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node">$ node event.js <br>listener1 arg1 参数 arg2 参数<br>listener2 arg1 参数 arg2 参数<br></code></pre></td></tr></table></figure><p>EventEmitter 提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p><h4 id="EventEmitter-的方法："><a href="#EventEmitter-的方法：" class="headerlink" title="EventEmitter 的方法："></a>EventEmitter 的方法：</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>addListener(event, listener)</strong></td><td>为指定事件<strong>添加一个监听器</strong>到监听器数组的尾部。</td></tr><tr><td><strong>on(event, listener)</strong></td><td>为指定事件<strong>注册一个监听器</strong>，接受一个字符串 event 和一个回调函数。</td></tr><tr><td><strong>once(event, listener)</strong></td><td>为指定事件注册一个<strong>单次监听器</strong>，即 监听器最多只会触发一次，触发后立刻解除该监听器。</td></tr><tr><td><strong>removeListener(event, listener)</strong></td><td><strong>移除指定事件的某个监听器</strong>，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。</td></tr><tr><td><strong>removeAllListeners([event])</strong></td><td><strong>移除所有事件的所有监听器</strong>， 如果指定事件，则移除指定事件的所有监听器。</td></tr><tr><td><strong>setMaxListeners(n)</strong></td><td>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数<strong>用于改变监听器的默认限制的数量</strong>。</td></tr><tr><td><strong>listeners(event)</strong></td><td><strong>返回指定事件的监听器数组</strong>。</td></tr><tr><td><strong>emit(event, [arg1], [arg2], […])</strong></td><td>按<strong>监听器的顺序执行执行每个监听器</strong>，如果事件有注册监听返回 true，否则返回 false。</td></tr></tbody></table><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>listenerCount(emitter, event)</strong></td><td>返回指定事件的监听器数量。</td></tr></tbody></table><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>newListener</strong></td><td><strong>event</strong> - 字符串，事件名称 <strong>listener</strong> - 处理事件函数：该事件在添加新监听器时被触发。</td></tr><tr><td><strong>removeListener</strong></td><td><strong>event</strong> - 字符串，事件名称 <strong>listener</strong> - 处理事件函数：从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td></tr></tbody></table><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs node">var events = require(&#x27;events&#x27;);<br>var eventEmitter = new events.EventEmitter();<br><br>// 监听器 #1<br>var listener1 = function listener1() &#123;<br>   console.log(&#x27;监听器 listener1 执行。&#x27;);<br>&#125;<br><br>// 监听器 #2<br>var listener2 = function listener2() &#123;<br>  console.log(&#x27;监听器 listener2 执行。&#x27;);<br>&#125;<br><br>// 绑定 connection 事件，处理函数为 listener1 <br>eventEmitter.addListener(&#x27;connection&#x27;, listener1);<br><br>// 绑定 connection 事件，处理函数为 listener2<br>eventEmitter.on(&#x27;connection&#x27;, listener2);<br><br>var eventListeners = eventEmitter.listenerCount(&#x27;connection&#x27;);<br>console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);<br><br>// 处理 connection 事件 <br>eventEmitter.emit(&#x27;connection&#x27;);<br><br>// 移除监绑定的 listener1 函数<br>eventEmitter.removeListener(&#x27;connection&#x27;, listener1);<br>console.log(&quot;listener1 不再受监听。&quot;);<br><br>// 触发连接事件<br>eventEmitter.emit(&#x27;connection&#x27;);<br><br>eventListeners = eventEmitter.listenerCount(&#x27;connection&#x27;);<br>console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);<br><br>console.log(&quot;程序执行完毕。&quot;);<br></code></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs node">$ node main.js<br>2 个监听器监听连接事件。<br>监听器 listener1 执行。<br>监听器 listener2 执行。<br>listener1 不再受监听。<br>监听器 listener2 执行。<br>1 个监听器监听连接事件。<br>程序执行完毕。<br></code></pre></td></tr></table></figure><h4 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h4><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p><p>当 error 被触发时，EventEmitter 规定如果没有响应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p><p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node">var events = require(&#x27;events&#x27;); <br>var emitter = new events.EventEmitter(); <br>emitter.emit(&#x27;error&#x27;); <br></code></pre></td></tr></table></figure><p>运行时会显示以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs node">node.js:201 <br>throw e; // process.nextTick error, or &#x27;error&#x27; event on first tick <br>^ <br>Error: Uncaught, unspecified &#x27;error&#x27; event. <br>at EventEmitter.emit (events.js:50:15) <br>at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9) <br>at Module._compile (module.js:441:26) <br>at Object..js (module.js:459:10) <br>at Module.load (module.js:348:31) <br>at Function._load (module.js:308:12) <br>at Array.0 (module.js:479:10) <br>at EventEmitter._tickCallback (node.js:192:40) <br></code></pre></td></tr></table></figure><p>大多数时候我们<strong>不会直接使用 EventEmitter，而是在对象中继承它</strong>。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p><h2 id="Node-js-Buffer-缓冲区"><a href="#Node-js-Buffer-缓冲区" class="headerlink" title="Node.js Buffer(缓冲区)"></a>Node.js Buffer(缓冲区)</h2><p>Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I&#x2F;O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p><h4 id="Buffer-与字符编码"><a href="#Buffer-与字符编码" class="headerlink" title="Buffer 与字符编码"></a>Buffer 与字符编码</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>threejs</title>
    <link href="/2024/11/05/threejs/"/>
    <url>/2024/11/05/threejs/</url>
    
    <content type="html"><![CDATA[<h1 id="threejs教程"><a href="#threejs教程" class="headerlink" title="threejs教程"></a>threejs教程</h1><p>来自：<a href="https://blog.csdn.net/weixin_42817995/article/details/118753443">Three.js 零基础保姆级教程_threejs菜鸟教程-CSDN博客</a></p><h2 id="1-threejs文件包"><a href="#1-threejs文件包" class="headerlink" title="1. threejs文件包"></a>1. threejs文件包</h2><p>地址：<a href="https://github.com/mrdoob/three.js/releases">Releases · mrdoob&#x2F;three.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">three.<span class="hljs-property">js</span>-文件包<br>└───build——three.<span class="hljs-property">js</span>相关库，可以引入你的.<span class="hljs-property">html</span>文件中。<br>    │<br>└───docs——<span class="hljs-title class_">Three</span>.<span class="hljs-property">js</span> <span class="hljs-variable constant_">API</span>文档文件<br>    │───index.<span class="hljs-property">html</span>——打开该文件，本地离线方式预览threejs文档<br>└───examples——大量的3D案例，是你平时开发参考学习的最佳资源<br>    │───jsm——threejs各种功能扩展库<br>└───src——<span class="hljs-title class_">Three</span>.<span class="hljs-property">js</span>引擎的源码，有兴趣可以阅读。<br>    │<br>└───editor——<span class="hljs-title class_">Three</span>.<span class="hljs-property">js</span>的可视化编辑器，可以编辑3D场景<br>    │───index.<span class="hljs-property">html</span>——打开应用程序  <br></code></pre></td></tr></table></figure><h2 id="2-学习环境-编辑器和静态服务器-略"><a href="#2-学习环境-编辑器和静态服务器-略" class="headerlink" title="2. 学习环境-编辑器和静态服务器(略)"></a>2. 学习环境-编辑器和静态服务器(略)</h2><h2 id="3-threejs怎么引入"><a href="#3-threejs怎么引入" class="headerlink" title="3. threejs怎么引入"></a>3. threejs怎么引入</h2><ol><li>开发环境：项目开发引入threejs，比如vue或react脚手架引入threejs。</li><li>学习环境：入门threejs阶段，.html文件中直接引入threejs</li></ol><h3 id="项目的开发环境引入threejs"><a href="#项目的开发环境引入threejs" class="headerlink" title="项目的开发环境引入threejs"></a><strong>项目的开发环境引入threejs</strong></h3><p>比如你采用的是<strong>Vue + threejs</strong>或<strong>React + threejs</strong>技术栈，这很简单，threejs就是一个js库，直接通过<strong>npm</strong>命令行安装就行，npm安装特定版本three.js(注意使用哪个版本，查文档就查对应版本)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 比如安装148版本</span><br>npm install three@<span class="hljs-number">0.148</span><span class="hljs-number">.0</span> --save<br></code></pre></td></tr></table></figure><p><strong>npm安装后，如何引入three.js</strong></p><p>执行<code>import * as THREE from &#39;three&#39;;</code>,ES6语法引入three.js核心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入three.js</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>npm安装后，如何引入three.js其他扩展库</strong></p><p>除了three.js核心库以外，在threejs文件包中<strong>examples&#x2F;jsm</strong>目录下，你还可以看到各种不同功能的扩展库。</p><p>一般来说，你项目用到那个扩展库，就引入那个，用不到就不需要引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入扩展库OrbitControls.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">OrbitControls</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/addons/controls/OrbitControls.js&#x27;</span>;<br><span class="hljs-comment">// 引入扩展库GLTFLoader.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">GLTFLoader</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/addons/loaders/GLTFLoader.js&#x27;</span>;<br><br><span class="hljs-comment">// 扩展库引入——旧版本，比如122, 新版本路径addons替换了examples/jsm</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">OrbitControls</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/examples/jsm/controls/OrbitControls</span><br></code></pre></td></tr></table></figure><h3 id="学习环境：-html文件中直接引入threejs"><a href="#学习环境：-html文件中直接引入threejs" class="headerlink" title="学习环境：.html文件中直接引入threejs"></a><strong>学习环境：.html文件中直接引入threejs</strong></h3><p>学习使用的环境，只要创建一个.html文件，编写threejs代码，最后通过<strong>本地静态服务</strong>打开.html文件就行。</p><p><strong>script标签方式引入three.js</strong></p><p>你可以像平时开发web前端项目一样，通过script标签把three.js当做一个js库引入你的项目。</p><p>three.js库可以在threejs官方文件包下面的<strong>build</strong>目录获取到。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./build/three.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>//随便输入一个API，测试下是否已经正常引入three.js<br>console.log(THREE.Scene); <br></code></pre></td></tr></table></figure><p><strong>ES6 import方式引入</strong></p><p>给script标签设置<code>type=&quot;module&quot;</code>,也可以在.html文件中使用<code>import</code>方式引入three.js。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 现在浏览器支持ES6语法，自然包括import方式引入js文件</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./build/three.module.js&#x27;</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong><a href="http://www.webgl3d.cn/pages/cd35b2/#type-importmap-%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84">#</a>type&#x3D;”importmap”配置路径</strong></p><p>学习环境中，.html文件引入three.js，最好的方式就是参考threejs官方案例，通过配置<code>&lt;script type=&quot;importmap&quot;&gt;</code>,实现学习环境.html文件和vue或reaact脚手架开发环境一样的写法。这样你实际项目的开发环境复制课程源码，不用改变threejs引入代码。</p><p>下面配置的<code>type=&quot;importmap&quot;</code>代码具体写法不用掌握记忆，复制粘贴后，能修改目录就行，你可以去电子书课件或者课件源码中复制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 具体路径配置，你根据自己文件目录设置，我的是课件中源码形式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;importmap&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript"><span class="hljs-string">&quot;imports&quot;</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-string">&quot;three&quot;</span>: <span class="hljs-string">&quot;../../../three.js/build/three.module.js&quot;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 配置type=&quot;importmap&quot;,.html文件也能和项目开发环境一样方式引入threejs --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 浏览器控制台测试，是否引入成功</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">Scene</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong><a href="http://www.webgl3d.cn/pages/cd35b2/#type-importmap-%E9%85%8D%E7%BD%AE-%E6%89%A9%E5%B1%95%E5%BA%93%E5%BC%95%E5%85%A5">#</a>type&#x3D;”importmap”配置——扩展库引入</strong></p><p>通过配置<code>&lt;script type=&quot;importmap&quot;&gt;</code>，让学习环境.html文件，也能和vue或react开发环境中一样方式方式引入threejs扩展库。</p><p>配置<code>addons/</code>等价于<code>examples/jsm/</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;importmap&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript"><span class="hljs-string">&quot;imports&quot;</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-string">&quot;three&quot;</span>: <span class="hljs-string">&quot;./three.js/build/three.module.js&quot;</span>,</span><br><span class="language-javascript">            <span class="hljs-string">&quot;three/addons/&quot;</span>: <span class="hljs-string">&quot;./three.js/examples/jsm/&quot;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// three/addons/路径之后对应的是three.js官方文件包`/examples/jsm/`中的js库</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 扩展库OrbitControls.js</span></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">OrbitControls</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/addons/controls/OrbitControls.js&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 扩展库GLTFLoader.js</span></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">GLTFLoader</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/addons/loaders/GLTFLoader.js&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">OrbitControls</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">GLTFLoader</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-第一个3D案例—创建3D场景"><a href="#4-第一个3D案例—创建3D场景" class="headerlink" title="4. 第一个3D案例—创建3D场景"></a>4. 第一个3D案例—创建3D场景</h2><p>入门Three.js的第一步，就是认识<strong>场景Scene</strong>、<strong>相机Camera</strong>、<strong>渲染器Renderer</strong>三个基本概念。</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E5%9C%BA%E6%99%AF%E7%9B%B8%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%99%A8.png" alt="img"></p><p><strong>三维场景<code>Scene</code></strong></p><p>你可以把三维场景<strong>Scene</strong>对象理解为虚拟的3D场景，用来表示模拟生活中的真实三维场景,或者说三维世界。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建3D场景对象Scene</span><br><span class="hljs-keyword">const</span> scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();<br></code></pre></td></tr></table></figure><p><strong>物体形状：几何体<code>Geometry</code></strong></p><p>Three.js提供了各种各样的几何体API，用来表示三维物体的几何形状</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E5%87%A0%E4%BD%95%E4%BD%93Geometry.svg" alt="img"></p><p>文档搜索关键词<code>geometry</code>你可以看到threejs提供各种几何体相关API。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//创建一个长方体几何对象Geometry</span><br><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>); <br></code></pre></td></tr></table></figure><p><strong>物体外观：材质<code>Material</code></strong></p><p>如果你想定义物体的外观效果，比如颜色，就需要通过材质<code>Material</code>相关的API实现。</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E6%9D%90%E8%B4%A8Material.svg" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//创建一个材质对象Material</span><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span>,<span class="hljs-comment">//0xff0000设置材质颜色为红色</span><br>&#125;); <br></code></pre></td></tr></table></figure><p><strong>物体：网格模型<code>Mesh</code></strong></p><p>实际生活中有各种各样的物体，在threejs中可以通过<strong>网格模型</strong><a href="https://threejs.org/docs/index.html?q=mesh#api/zh/objects/Mesh">Mesh</a>表示一个虚拟的物体，比如一个箱子、一个鼠标。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 两个参数分别为几何体geometry、材质material</span><br><span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material); <span class="hljs-comment">//网格模型对象Mesh</span><br></code></pre></td></tr></table></figure><p><strong>模型位置<code>.position</code></strong></p><p>实际生活中，一个物体往往是有位置的，对于threejs而言也是一样的，你可以<strong>通过位置属性<code>.position</code>定义网格模型<code>Mesh</code>在三维场景<code>Scene</code>中的位置</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material); <span class="hljs-comment">//网格模型对象Mesh</span><br><span class="hljs-comment">//设置网格模型在三维空间中的位置坐标，默认是坐标原点</span><br>mesh.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><strong><code>.add()</code>方法</strong></p><p>在threejs中你创建了一个表示物体的虚拟对象Mesh，需要<strong>通过<code>.add()</code>方法，把网格模型<code>mesh</code>添加到三维场景<code>scene</code>中。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">scene.<span class="hljs-title function_">add</span>(mesh); <br></code></pre></td></tr></table></figure><p><strong>后续内容</strong></p><p>需要加入后面两节课关于<strong>相机Camera</strong>和<strong>渲染器Renderer</strong>的介绍，这样可以看到渲染的效果。</p><h2 id="5-第一个3D案例—透视投影相机"><a href="#5-第一个3D案例—透视投影相机" class="headerlink" title="5. 第一个3D案例—透视投影相机"></a>5. 第一个3D案例—透视投影相机</h2><p>Threejs如果想把三维场景<code>Scene</code>渲染到web网页上，还需要定义一个<strong>虚拟相机</strong><code>Camera</code>，就像你生活中想获得一张照片，需要一台用来拍照的相机。</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E5%9C%BA%E6%99%AF%E7%9B%B8%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%99%A8.png" alt="img"></p><p><strong>透视投影相机<code>PerspectiveCamera</code></strong></p><p>Threejs提供了正投影相机<a href="https://threejs.org/docs/index.html?q=Camera#api/zh/cameras/OrthographicCamera">OrthographicCamera</a>和透视投影相机<a href="https://threejs.org/docs/index.html?q=PerspectiveCamera#api/zh/cameras/PerspectiveCamera">PerspectiveCamera</a>。本节课先给大家比较常用的透视投影相机<code>PerspectiveCamera</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 实例化一个透视投影相机对象</span><br><span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>();<br></code></pre></td></tr></table></figure><p><strong>相机位置<code>.position</code></strong></p><p>相机位置不同，拍照结果也不同，threejs中虚拟相机同样如此。</p><p>相机对象<code>Camera</code>具有位置属性<code>.position</code>，通过<strong>位置属性<code>.position</code>可以设置相机的位置。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 相机在Three.js三维坐标系中的位置</span><br><span class="hljs-comment">// 根据需要设置相机位置具体值</span><br>camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>); <br></code></pre></td></tr></table></figure><p><strong>相机观察目标<code>.lookAt()</code></strong></p><p>你用相机拍照你需要<strong>控制相机的拍照目标</strong>，具体说<strong>相机镜头对准哪个物体或说哪个坐标</strong>。对于threejs相机而言，就是<strong>设置<code>.lookAt()</code>方法的参数，指定一个3D坐标。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//相机观察目标指向Threejs 3D空间中某个位置</span><br>camera.<span class="hljs-title function_">lookAt</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//坐标原点</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">camera.<span class="hljs-title function_">lookAt</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//y轴上位置10</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">camera.<span class="hljs-title function_">lookAt</span>(mesh.<span class="hljs-property">position</span>);<span class="hljs-comment">//指向mesh对应的位置</span><br></code></pre></td></tr></table></figure><p><img src="http://www.webgl3d.cn/imgthreejs/%E7%9B%B8%E6%9C%BA%E4%BD%8D%E7%BD%AE%E5%92%8C%E7%9B%AE%E6%A0%87.png" alt="img"></p><p><strong>判断相机相对三维场景中长方体位置</strong></p><p>你可以把三维场景中长方体<code>mesh</code>想象为一个房间，然后<strong>根据相机位置和长方体位置尺寸对比，判断两者相对位置</strong>。你可以发现<strong>设置相机坐标(200, 200, 200)，位于长方体外面一处位置。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 长方体尺寸100, 100, 100</span><br><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>( <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span> );<br><span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry,material);<br><span class="hljs-comment">// 网格模型位置xyz坐标：0,10,0</span><br>mesh.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 相机位置xyz坐标：200, 200, 200</span><br>camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>); <br></code></pre></td></tr></table></figure><p><strong>定义相机渲染输出的画布尺寸</strong></p><p>你生活中相机拍照的照片是有大小的，对于threejs而言一样，需要定义相机在网页上输出的<strong>Canvas画布</strong>(照片)尺寸，大小可以根据需要定义，这里先随机定义一个尺寸。</p><p><strong>Canvas画布</strong>：课程中会把threejs虚拟相机渲染三维场景在浏览器网页上呈现的结果称为<strong>Canvas画布</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义相机输出画布的尺寸(单位:像素px)</span><br><span class="hljs-keyword">const</span> width = <span class="hljs-number">800</span>; <span class="hljs-comment">//宽度</span><br><span class="hljs-keyword">const</span> height = <span class="hljs-number">500</span>; <span class="hljs-comment">//高度</span><br></code></pre></td></tr></table></figure><p><strong>透视投影相机<code>PerspectiveCamera</code>：视锥体</strong></p><p>透视投影相机的四个参数<code>fov, aspect, near, far</code>构成一个<strong>四棱台</strong>3D空间，被称为<strong>视锥体</strong>，只有视锥体之内的物体，才会渲染出来，视锥体范围之外的物体不会显示在Canvas画布上。</p><p><img src="http://www.webgl3d.cn/threejs/%E8%A7%86%E9%94%A5%E4%BD%93.png" alt="视锥体"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)</span><br><span class="hljs-keyword">const</span> width = <span class="hljs-number">800</span>; <span class="hljs-comment">//宽度</span><br><span class="hljs-keyword">const</span> height = <span class="hljs-number">500</span>; <span class="hljs-comment">//高度</span><br><span class="hljs-comment">// 30:视场角度, width / height:Canvas画布宽高比, 1:近裁截面, 3000：远裁截面</span><br><span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">30</span>, width / height, <span class="hljs-number">1</span>, <span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p><code>PerspectiveCamera</code>参数介绍：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">PerspectiveCamera</span>( fov, aspect, near, far )<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center"><strong>参数</strong></th><th align="center"><strong>含义</strong></th><th align="center"><strong>默认值</strong></th></tr></thead><tbody><tr><td align="center">fov</td><td align="center">相机视锥体竖直方向视野角度</td><td align="center">50</td></tr><tr><td align="center">aspect</td><td align="center">相机视锥体水平方向和竖直方向长度比，一般设置为Canvas画布宽高比width &#x2F; height</td><td align="center">11</td></tr><tr><td align="center">near</td><td align="center">相机视锥体近裁截面相对相机距离</td><td align="center">0.1</td></tr><tr><td align="center">far</td><td align="center">相机视锥体远裁截面相对相机距离，far-near构成了视锥体高度方向</td><td align="center">2000</td></tr></tbody></table><h2 id="6-第一个3D案例—渲染器"><a href="#6-第一个3D案例—渲染器" class="headerlink" title="6. 第一个3D案例—渲染器"></a>6. 第一个3D案例—渲染器</h2><p>生活中如果<strong>有了景物和相机</strong>，那么如果想获得一张照片，就需要你拿着相机，按一下，咔，完成拍照。对于threejs而言，如果<strong>完成“咔”这个拍照动作，就需要一个新的对象，也就是WebGL渲染器<a href="https://threejs.org/docs/index.html?q=webgl#api/zh/renderers/WebGLRenderer">WebGLRenderer</a></strong></p><p><img src="http://www.webgl3d.cn/imgthreejs/%E5%9C%BA%E6%99%AF%E7%9B%B8%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%99%A8.png" alt="img"></p><p><strong>WebGL渲染器<code>WebGLRenderer</code></strong></p><p>通过WebGL渲染器<a href="https://threejs.org/docs/index.html?q=webgl#api/zh/renderers/WebGLRenderer">WebGLRenderer</a>可以实例化一个WebGL渲染器对象.。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建渲染器对象</span><br><span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>();<br></code></pre></td></tr></table></figure><p><strong>设置Canvas画布尺寸<code>.setSize()</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义threejs输出画布的尺寸(单位:像素px)</span><br><span class="hljs-keyword">const</span> width = <span class="hljs-number">800</span>; <span class="hljs-comment">//宽度</span><br><span class="hljs-keyword">const</span> height = <span class="hljs-number">500</span>; <span class="hljs-comment">//高度</span><br>renderer.<span class="hljs-title function_">setSize</span>(width, height); <span class="hljs-comment">//设置three.js渲染区域的尺寸(像素px)</span><br></code></pre></td></tr></table></figure><p><strong>渲染器渲染方法<code>.render()</code></strong></p><p>渲染器<code>WebGLRenderer</code>执行渲染方法<code>.render()</code>就可以生成一个Canvas画布(照片)，并把三维场景Scene呈现在canvas画布上面,你<strong>可以把<code>.render()</code>理解为相机的拍照动作“咔”</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">renderer.<span class="hljs-title function_">render</span>(scene, camera); <span class="hljs-comment">//执行渲染操作</span><br></code></pre></td></tr></table></figure><p> <strong>渲染器Canvas画布属性<code>.domElement</code></strong></p><p>渲染器<code>WebGLRenderer</code>通过属性<code>.domElement</code>可以获得渲染方法<code>.render()</code>生成的Canvas画布，<code>.domElement</code>本质上就是一个HTML元素：Canvas画布。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);<br></code></pre></td></tr></table></figure><p><strong>Canvas画布插入到任意HTML元素中</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;webgl&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top: 200px;margin-left: 100px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;webgl&#x27;</span>).<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);<br></code></pre></td></tr></table></figure><h2 id="7-三维坐标系-加强三维空间认识"><a href="#7-三维坐标系-加强三维空间认识" class="headerlink" title="7. 三维坐标系-加强三维空间认识"></a>7. 三维坐标系-加强三维空间认识</h2><p>本节课的目的就是为了加强大家对threejs三维空间的认识。</p><p><strong>辅助观察坐标系</strong></p><p><code>THREE.AxesHelper()</code>的参数表示坐标系坐标轴线段尺寸大小，你可以根据需要改变尺寸。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// AxesHelper：辅助观察的坐标系</span><br><span class="hljs-keyword">const</span> axesHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AxesHelper</span>(<span class="hljs-number">150</span>);<br>scene.<span class="hljs-title function_">add</span>(axesHelper);<br></code></pre></td></tr></table></figure><p><strong>材质半透明设置</strong></p><p>设置材质半透明,这样可以看到坐标系的坐标原点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-number">0x0000ff</span>, <span class="hljs-comment">//设置材质颜色</span><br>    <span class="hljs-attr">transparent</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启透明</span><br>    <span class="hljs-attr">opacity</span>:<span class="hljs-number">0.5</span>,<span class="hljs-comment">//设置透明度</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong><code>AxesHelper</code>的xyz轴</strong></p><p>three.js坐标轴颜色红<strong>R</strong>、绿<strong>G</strong>、蓝<strong>B</strong>分别对应坐标系的<strong>x</strong>、<strong>y</strong>、<strong>z</strong>轴，对于three.js的3D坐标系默认<strong>y轴朝上</strong>。</p><p><strong>设置模型在坐标系中的位置或尺寸</strong></p><p>通过模型的位置、尺寸设置，加深3D坐标系的概念。</p><p>测试：设置长方体xyz不同方向尺寸</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置几何体长宽高，也就是x、y、z三个方向的尺寸</span><br><span class="hljs-comment">//对比三个参数分别对应xyz轴哪个方向</span><br><span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">100</span>, <span class="hljs-number">60</span>, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>测试：改变位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置模型mesh的xyz坐标</span><br>mesh.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><strong>改变相机参数——预览新的渲染效果</strong></p><p>你可以尝试源码中改变相机的参数，看看场景中的物体渲染效果怎么变化。</p><p>相机放在x轴负半轴，目标观察点是坐标原点，这样相当于相机的视线是沿着x轴正方向，只能看到长方体的一个矩形平面。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">camera</span>.position.set(-<span class="hljs-number">1000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-attribute">camera</span>.lookAt(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 相机视线沿着x轴负半轴，mesh位于相机后面，自然看不到</span><br>camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(-<span class="hljs-number">1000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>camera.<span class="hljs-title function_">lookAt</span>(-<span class="hljs-number">2000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>相机far偏小，mesh位于far之外，物体不会显示在画布上。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">// const camera = <span class="hljs-built_in">new</span> THREE.PerspectiveCamera(<span class="hljs-number">30</span>, <span class="hljs-built_in">width</span> / <span class="hljs-built_in">height</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3000</span>);<br>// 你可以进行下面测试，改变相机参数，把<span class="hljs-built_in">mesh</span>放在视锥体之外，看看是否显示<br>// <span class="hljs-number">3000</span>改为<span class="hljs-number">300</span>，使<span class="hljs-built_in">mesh</span>位于far之外，<span class="hljs-built_in">mesh</span>不在视锥体内，被剪裁掉<br>const camera = <span class="hljs-built_in">new</span> THREE.PerspectiveCamera(<span class="hljs-number">30</span>, <span class="hljs-built_in">width</span> / <span class="hljs-built_in">height</span>, <span class="hljs-number">1</span>, <span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><p><img src="http://www.webgl3d.cn/threejs/%E8%A7%86%E9%94%A5%E4%BD%93.png" alt="视锥体"></p><h2 id="8-光源对物体表面影响"><a href="#8-光源对物体表面影响" class="headerlink" title="8. 光源对物体表面影响"></a>8. 光源对物体表面影响</h2><p>实际生活中物体表面的<strong>明暗</strong>效果是会受到<strong>光照</strong>的影响，比如晚上不开灯，你就看不到物体，灯光比较暗，物体也比较暗。在threejs中，咱们用网格模型<code>Mesh</code>模拟生活中物体，所以threejs中模拟光照<code>Light</code>对物体表面的影响，就是模拟光照<code>Light</code>对网格模型<code>Mesh</code>表面的影响。</p><h3 id="材质介绍"><a href="#材质介绍" class="headerlink" title="材质介绍"></a>材质介绍</h3><p><strong>受光照影响材质</strong></p><p>threejs提供的网格材质，有的受光照影响，有的不受光照影响。</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8.svg" alt="img"></p><p><strong>基础网格材质<a href="https://threejs.org/docs/index.html?q=MeshBasicMaterial#api/zh/materials/MeshBasicMaterial">MeshBasicMaterial</a>不会受到光照影响。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//MeshBasicMaterial不受光照影响</span><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(); <br></code></pre></td></tr></table></figure><p><strong>漫反射网格材质<a href="https://threejs.org/docs/index.html?q=MeshLambertMaterial#api/zh/materials/MeshLambertMaterial">MeshLambertMaterial</a>会受到光照影响</strong>，该材质也可以称为<strong>Lambert网格材质</strong>，音译为兰伯特网格材质。</p><p>一个立方体长方体使用MeshLambertMaterial材质，<strong>不同面和光线夹角不同，立方体不同面就会呈现出来不同的明暗效果</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//MeshLambertMaterial受光照影响</span><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshLambertMaterial</span>(); <br></code></pre></td></tr></table></figure><h3 id="光源简介"><a href="#光源简介" class="headerlink" title="光源简介"></a><strong>光源简介</strong></h3><p>Three.js提供了多种模拟生活中光源的API，文档搜索关键词light就可以看到。</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E5%85%89%E6%BA%90.svg" alt="img"></p><p><strong>点光源</strong></p><p><img src="http://www.webgl3d.cn/imgthreejs/%E5%85%89%E6%BA%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"></p><p>点光源<a href="https://threejs.org/docs/index.html?q=PointLight#api/zh/lights/PointLight">PointLight</a>可以类比为一个发光点，就像生活中一个灯泡以灯泡为中心向四周发射光线。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//点光源：两个参数分别表示光源颜色和光照强度</span><br><span class="hljs-comment">// 参数1：0xffffff是纯白光,表示光源颜色</span><br><span class="hljs-comment">// 参数2：1.0,表示光照强度，可以根据需要调整</span><br><span class="hljs-keyword">const</span> pointLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><p>除了通过<code>THREE.PointLight</code>的参数2设置光照强度，你可以可以直接访问光照强度属性<code>.intensity</code>设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pointLight.<span class="hljs-property">intensity</span> = <span class="hljs-number">1.0</span>;<span class="hljs-comment">//光照强度</span><br></code></pre></td></tr></table></figure><p> <strong>光源衰减</strong></p><p>实际生活中点光源，比如比如一个灯泡，随机距离的改变，光线会衰减，越来越弱，光源衰减属性<code>.decay</code>默认值是2.0，如果你不希望衰减可以设置为<code>0.0</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pointLight.<span class="hljs-property">decay</span> = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//设置光源不随距离衰减</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 你可以对比不同光照强度明暗差异(传播同样距离)</span><br>pointLight.<span class="hljs-property">intensity</span> = <span class="hljs-number">10000.0</span>;<span class="hljs-comment">//光照强度</span><br>pointLight.<span class="hljs-property">intensity</span> = <span class="hljs-number">50000.0</span>;<span class="hljs-comment">//光照强度</span><br></code></pre></td></tr></table></figure><p><strong>光源位置</strong></p><p>你把点光源想象为一个电灯泡，你在3D空间中，放的位置不同，模型的渲染效果就不一样。</p><p>注意光源位置尺寸大小：如果你<strong>希望光源照在模型的外表面，那你就需要把光源放在模型的外面。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//点光源位置</span><br>pointLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">400</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//点光源放在x轴上</span><br></code></pre></td></tr></table></figure><p><strong>光源添加到场景</strong></p><p>光源和网格模型<strong>Mesh</strong>对应一样是三维场景的一部分，自然需要添加到三维场景中才能起作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">scene.<span class="hljs-title function_">add</span>(pointLight); <span class="hljs-comment">//点光源添加到场景中</span><br></code></pre></td></tr></table></figure><p>设置好上面所有代码，你现在可以执行代码，用浏览器查看渲染效果。</p><p><strong>改变光源位置，观察网格模型表面的明暗变化。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">pointLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">400</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><h2 id="9-相机控件OrbitControls"><a href="#9-相机控件OrbitControls" class="headerlink" title="9. 相机控件OrbitControls"></a>9. 相机控件OrbitControls</h2><p>平时开发调试代码，或者展示模型的时候，可以通过<strong>相机控件OrbitControls实现旋转缩放预览效果。</strong></p><p><strong>OrbitControls使用</strong></p><ul><li>旋转：拖动鼠标左键</li><li>缩放：滚动鼠标中键</li><li>平移：拖动鼠标右键</li></ul><p><strong>引入扩展库OrbitControls.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入轨道控制器扩展库OrbitControls.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">OrbitControls</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/addons/controls/OrbitControls.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p><em>注意：如果你在原生.html文件中，使用上面引入方式<code>import &#123; OrbitControls &#125; from &#39;three/addons/controls/OrbitControls.js&#39;;</code>，注意通过<code>&lt;script type=&quot;importmap&quot;&gt;</code>配置。</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;importmap&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript"><span class="hljs-string">&quot;imports&quot;</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-string">&quot;three&quot;</span>: <span class="hljs-string">&quot;../../../three.js/build/three.module.js&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-string">&quot;three/addons/&quot;</span>: <span class="hljs-string">&quot;../../../three.js/examples/jsm/&quot;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>使用OrbitControls</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置相机控件轨道控制器OrbitControls</span><br><span class="hljs-keyword">const</span> controls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrbitControls</span>(camera, renderer.<span class="hljs-property">domElement</span>);<br><span class="hljs-comment">// 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景</span><br>controls.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    renderer.<span class="hljs-title function_">render</span>(scene, camera); <span class="hljs-comment">//执行渲染操作</span><br>&#125;);<span class="hljs-comment">//监听鼠标、键盘事件</span><br></code></pre></td></tr></table></figure><p><strong>OrbitControls本质</strong></p><p><strong>OrbitControls本质上就是改变相机的参数，</strong>比如相机的位置属性，改变相机位置也可以改变相机拍照场景中模型的角度，实现模型的360度旋转预览效果，改变透视投影相机距离模型的距离，就可以改变相机能看到的视野范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">controls.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 浏览器控制台查看相机位置变化</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;camera.position&#x27;</span>,camera.<span class="hljs-property">position</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="10-平行光与环境光"><a href="#10-平行光与环境光" class="headerlink" title="10. 平行光与环境光"></a>10. 平行光与环境光</h2><p>本节课通过平行光<a href="https://threejs.org/docs/index.html?q=DirectionalLight#api/zh/lights/DirectionalLight">DirectionalLight</a>和环境光<a href="https://threejs.org/docs/index.html?q=AmbientLight#api/zh/lights/AmbientLight">AmbientLight</a>进一步了解光照对应模型Mesh表面的影响。</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E5%85%89%E6%BA%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"></p><p><img src="http://www.webgl3d.cn/imgthreejs/%E5%85%89%E6%BA%90.svg" alt="img"></p><p><strong>点光源辅助观察<code>PointLightHelper</code></strong></p><p>通过点光源辅助观察对象<a href="https://threejs.org/docs/index.html?q=PointLightHelper#api/zh/helpers/PointLightHelper">PointLightHelper</a>可视化点光源。</p><p>预览观察：可以借助相机控件<code>OrbitControls</code>旋转缩放三维场景便于预览点光源位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 光源辅助观察</span><br><span class="hljs-keyword">const</span> pointLightHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLightHelper</span>(pointLight, <span class="hljs-number">10</span>);<br>scene.<span class="hljs-title function_">add</span>(pointLightHelper);<br></code></pre></td></tr></table></figure><p>改变点光源位置，观察光照效果变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">pointLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">100</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>);<br><span class="hljs-comment">// 改变点光源位置，使用OrbitControls辅助观察</span><br>pointLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(-<span class="hljs-number">400</span>, -<span class="hljs-number">200</span>, -<span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><h3 id="环境光设置"><a href="#环境光设置" class="headerlink" title="环境光设置"></a>环境光设置</h3><p>环境光<a href="https://threejs.org/docs/index.html?q=AmbientLight#api/zh/lights/AmbientLight">AmbientLight</a>没有特定方向，只是整体改变场景的光照明暗。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//环境光:没有特定方向，整体改变场景的光照明暗</span><br><span class="hljs-keyword">const</span> ambient = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">0.4</span>);<br>scene.<span class="hljs-title function_">add</span>(ambient);<br></code></pre></td></tr></table></figure><h3 id="平行光"><a href="#平行光" class="headerlink" title="#平行光"></a><a href="http://www.webgl3d.cn/pages/343ae9/#%E5%B9%B3%E8%A1%8C%E5%85%89">#</a>平行光</h3><p>平行光<a href="https://threejs.org/docs/index.html?q=DirectionalLight#api/zh/lights/DirectionalLight">DirectionalLight</a>就是沿着特定方向发射</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E5%85%89%E6%BA%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 平行光</span><br><span class="hljs-keyword">const</span> directionalLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">DirectionalLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 设置光源的方向：通过光源position属性和目标指向对象的position属性计算</span><br>directionalLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">80</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);<br><span class="hljs-comment">// 方向光指向对象网格模型mesh，可以不设置，默认的位置是0,0,0</span><br>directionalLight.<span class="hljs-property">target</span> = mesh;<br>scene.<span class="hljs-title function_">add</span>(directionalLight);<br></code></pre></td></tr></table></figure><h3 id="平行光辅助观察DirectionalLightHelper"><a href="#平行光辅助观察DirectionalLightHelper" class="headerlink" title="平行光辅助观察DirectionalLightHelper"></a>平行光辅助观察<code>DirectionalLightHelper</code></h3><p>通过点光源辅助观察对象<a href="https://threejs.org/docs/index.html?q=LightHelper#api/zh/helpers/DirectionalLightHelper">DirectionalLightHelper (opens new window)</a>可视化点光源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// DirectionalLightHelper：可视化平行光</span><br><span class="hljs-keyword">const</span> dirLightHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">DirectionalLightHelper</span>(directionalLight, <span class="hljs-number">5</span>,<span class="hljs-number">0xff0000</span>);<br>scene.<span class="hljs-title function_">add</span>(dirLightHelper);<br></code></pre></td></tr></table></figure><h3 id="平行光与Mesh表面光线反射规律"><a href="#平行光与Mesh表面光线反射规律" class="headerlink" title="平行光与Mesh表面光线反射规律"></a>平行光与Mesh表面光线反射规律</h3><p>平行光照射到网格模型Mesh表面，光线和模型表面构成一个入射角度，入射角度不同，对光照的反射能力不同。</p><p>光线照射到<strong>漫反射网格材质</strong><a href="https://threejs.org/docs/index.html?q=MeshLambertMaterial#api/zh/materials/MeshLambertMaterial">MeshLambertMaterial</a>对应Mesh表面，Mesh表面对光线反射程度与入射角大小有关。</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E6%BC%AB%E5%8F%8D%E5%B0%84.jpg" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对比不同入射角，mesh表面对光照的反射效果</span><br>directionalLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>directionalLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>);<br>directionalLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>directionalLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">100</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>);<br><span class="hljs-comment">//directionalLight.target默认指向坐标原点</span><br></code></pre></td></tr></table></figure><h2 id="11-动画渲染循环"><a href="#11-动画渲染循环" class="headerlink" title="11. 动画渲染循环"></a>11. 动画渲染循环</h2><p>threejs可以借助HTML5的API<strong>请求动画帧<code>window.requestAnimationFrame</code>实现动画渲染。</strong></p><p><strong>请求动画帧<code>window.requestAnimationFrame</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// requestAnimationFrame实现周期性循环执行</span><br><span class="hljs-comment">// requestAnimationFrame默认每秒钟执行60次，但不一定能做到，要看代码的性能</span><br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    i+=<span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行次数&#x27;</span>+i);<br>    <span class="hljs-title function_">requestAnimationFrame</span>(render);<span class="hljs-comment">//请求再次执行函数render</span><br>&#125;<br><span class="hljs-title function_">render</span>();<br></code></pre></td></tr></table></figure><h3 id="threejs旋转动画"><a href="#threejs旋转动画" class="headerlink" title="threejs旋转动画"></a>threejs旋转动画</h3><p>动画说白了就是一张张照片，连起来依次展示，这样就形成一个动画效果，只要帧率高，人的眼睛就感觉不到卡顿，是连续的视频效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>();<br>renderer.<span class="hljs-title function_">setSize</span>(width, height);<br><span class="hljs-comment">// renderer.render(scene, camera); //执行渲染操作</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);<br><br><span class="hljs-comment">// 渲染函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    renderer.<span class="hljs-title function_">render</span>(scene, camera); <span class="hljs-comment">//执行渲染操作</span><br>    mesh.<span class="hljs-title function_">rotateY</span>(<span class="hljs-number">0.01</span>);<span class="hljs-comment">//每次绕y轴旋转0.01弧度</span><br>    <span class="hljs-title function_">requestAnimationFrame</span>(render);<span class="hljs-comment">//请求再次执行渲染函数render，渲染下一帧</span><br>&#125;<br><span class="hljs-title function_">render</span>();<br></code></pre></td></tr></table></figure><p><strong>计算两帧渲染时间间隔和帧率</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 渲染循环</span><br><span class="hljs-keyword">const</span> clock = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Clock</span>();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> spt = clock.<span class="hljs-title function_">getDelta</span>()*<span class="hljs-number">1000</span>;<span class="hljs-comment">//毫秒</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;两帧渲染时间间隔(毫秒)&#x27;</span>,spt);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;帧率FPS&#x27;</span>,<span class="hljs-number">1000</span>/spt);<br>    renderer.<span class="hljs-title function_">render</span>(scene, camera); <span class="hljs-comment">//执行渲染操作</span><br>    mesh.<span class="hljs-title function_">rotateY</span>(<span class="hljs-number">0.01</span>);<span class="hljs-comment">//每次绕y轴旋转0.01弧度</span><br>    <span class="hljs-title function_">requestAnimationFrame</span>(render);<span class="hljs-comment">//请求再次执行渲染函数render，渲染下一帧</span><br>&#125;<br><span class="hljs-title function_">render</span>();<br></code></pre></td></tr></table></figure><p><strong>渲染循环和相机控件OrbitControls</strong></p><p>设置了渲染循环,相机控件OrbitControls就不用再通过事件<code>change</code>执行<code>renderer.render(scene, camera);</code>，毕竟渲染循环一直在执行<code>renderer.render(scene, camera);</code></p><h2 id="12-Canvas画布布局和全屏"><a href="#12-Canvas画布布局和全屏" class="headerlink" title="12. Canvas画布布局和全屏"></a>12. Canvas画布布局和全屏</h2><p>threejs渲染输出的结果就是一个Cavnas画布，canvas画布也是HTML的元素之一，这意味着three.js渲染结果的布局和普通web前端习惯是一样的。</p><p>通过<code>renderer.domElement</code>属性可以访问threejs的渲染结果，也就是HTML的元素<code>canvas</code>画布。</p><h3 id="非全屏局部布局"><a href="#非全屏局部布局" class="headerlink" title="非全屏局部布局"></a>非全屏局部布局</h3><p>你可以<strong>把threejs的渲染结果<code>renderer.domElement</code>，插入到web页面上任何一个元素中</strong>，只要符合你项目的布局规则即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;webgl&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top: 100px;margin-left: 200px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> width = <span class="hljs-number">800</span>; <span class="hljs-comment">//宽度</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> height = <span class="hljs-number">500</span>; <span class="hljs-comment">//高度</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">30</span>, width / height, <span class="hljs-number">1</span>, <span class="hljs-number">3000</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript"> * 创建渲染器对象</span></span><br><span class="hljs-comment"><span class="language-javascript"> */</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>();</span><br><span class="language-javascript">renderer.<span class="hljs-title function_">setSize</span>(width, height); <span class="hljs-comment">//设置three.js渲染区域的尺寸(像素px)</span></span><br><span class="language-javascript">renderer.<span class="hljs-title function_">render</span>(scene, camera); <span class="hljs-comment">//执行渲染操作</span></span><br><span class="language-javascript"><span class="hljs-comment">//three.js执行渲染命令会输出一个canvas画布，也就是一个HTML元素，你可以插入到web页面中</span></span><br><span class="language-javascript"><span class="hljs-comment">// document.body.appendChild(renderer.domElement);</span></span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;wegbl&#x27;</span>).<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);</span><br></code></pre></td></tr></table></figure><p><strong>全屏渲染</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)</span><br><span class="hljs-keyword">const</span> width = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>; <span class="hljs-comment">//窗口文档显示区的宽度作为画布宽度</span><br><span class="hljs-keyword">const</span> height = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>; <span class="hljs-comment">//窗口文档显示区的高度作为画布高度</span><br><span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>();<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);<br></code></pre></td></tr></table></figure><p>全屏布局<strong>注意CSS的设置</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">body</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>canvas画布宽高度动态变化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// onresize 事件会在窗口被调整大小时发生</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 重置渲染器输出画布canvas尺寸</span><br>    renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);<br>    <span class="hljs-comment">// 全屏情况下：设置观察范围长宽比aspect为窗口宽高比</span><br>    camera.<span class="hljs-property">aspect</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;<br>    <span class="hljs-comment">// 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix</span><br>    <span class="hljs-comment">// 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)</span><br>    <span class="hljs-comment">// 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵</span><br>    camera.<span class="hljs-title function_">updateProjectionMatrix</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="13-stats查看threejs渲染帧率"><a href="#13-stats查看threejs渲染帧率" class="headerlink" title="13. stats查看threejs渲染帧率"></a>13. stats查看threejs渲染帧率</h3><p>three.js每执行WebGL渲染器<code>.render()</code>方法一次，就在canvas画布上得到一帧图像，不停地周期性执行<code>.render()</code>方法就可以更新canvas画布内容，一般场景越复杂往往渲染性能越低，也就是每秒钟执行<code>.render()</code>的次数越低。</p><p>通过stats.js库可以查看three.js当前的渲染性能，具体说就是计算three.js的渲染帧率(FPS),所谓渲染帧率(FPS)，简单说就是three.js每秒钟完成的渲染次数，一般渲染达到每秒钟60次为最佳状态。</p><p>stats.js下载链接：<a href="https://github.com/mrdoob/stats.js">https://github.com/mrdoob/stats.js</a></p><p> <strong>引入Stats</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入性能监视器stats.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Stats</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/addons/libs/stats.module.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>Stats使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//创建stats对象</span><br><span class="hljs-keyword">const</span> stats = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stats</span>();<br><span class="hljs-comment">//stats.domElement:web页面上输出计算结果,一个div元素，</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(stats.<span class="hljs-property">domElement</span>);<br><span class="hljs-comment">// 渲染函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">//requestAnimationFrame循环调用的函数中调用方法update(),来刷新时间</span><br>stats.<span class="hljs-title function_">update</span>();<br>renderer.<span class="hljs-title function_">render</span>(scene, camera); <span class="hljs-comment">//执行渲染操作</span><br><span class="hljs-title function_">requestAnimationFrame</span>(render); <span class="hljs-comment">//请求再次执行渲染函数render，渲染下一帧</span><br>&#125;<br><span class="hljs-title function_">render</span>();<br></code></pre></td></tr></table></figure><p><strong>stats方法setMode(mode)</strong></p><p>可以通过<code>setMode()</code>方法的参数mode的数值设置首次打开页面，测试结果的显示模式，鼠标单击可以更换不同的显示模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// stats.domElement显示：渲染帧率  刷新频率,一秒渲染次数 </span><br>stats.<span class="hljs-title function_">setMode</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//默认模式</span><br><span class="hljs-comment">//stats.domElement显示：渲染周期 渲染一帧多长时间(单位：毫秒ms)</span><br>  stats.<span class="hljs-title function_">setMode</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>性能测试</strong></p><p>控制长方体模型数量，你可以逐渐增加或减少,看看帧率变化，电脑性能不同结果不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 随机创建大量的模型,测试渲染性能</span><br><span class="hljs-keyword">const</span> num = <span class="hljs-number">1000</span>; <span class="hljs-comment">//控制长方体模型数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshLambertMaterial</span>(&#123;<br>        <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ffff</span><br>    &#125;);<br>    <span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);<br>    <span class="hljs-comment">// 随机生成长方体xyz坐标</span><br>    <span class="hljs-keyword">const</span> x = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">200</span><br>    <span class="hljs-keyword">const</span> y = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">200</span><br>    <span class="hljs-keyword">const</span> z = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">200</span><br>    mesh.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(x, y, z)<br>    scene.<span class="hljs-title function_">add</span>(mesh); <span class="hljs-comment">// 模型对象插入场景中</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-阵列立方体和相机适配体验"><a href="#14-阵列立方体和相机适配体验" class="headerlink" title="14. 阵列立方体和相机适配体验"></a>14. 阵列立方体和相机适配体验</h2><p><strong>for循环创建一列模型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br><span class="hljs-comment">//材质对象Material</span><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshLambertMaterial</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ffff</span>, <span class="hljs-comment">//设置材质颜色</span><br>    <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//开启透明</span><br>    <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>,<span class="hljs-comment">//设置透明度</span><br>&#125;);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material); <span class="hljs-comment">//网格模型对象Mesh</span><br>    <span class="hljs-comment">// 沿着x轴分布</span><br>    mesh.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(i*<span class="hljs-number">200</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    scene.<span class="hljs-title function_">add</span>(mesh); <span class="hljs-comment">//网格模型添加到场景中</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>双层for循环创建阵列模型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建一个长方体几何对象Geometry</span><br><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br><span class="hljs-comment">//材质对象Material</span><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshLambertMaterial</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ffff</span>, <span class="hljs-comment">//设置材质颜色</span><br>    <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//开启透明</span><br>    <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>,<span class="hljs-comment">//设置透明度</span><br>&#125;);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>        <span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material); <span class="hljs-comment">//网格模型对象Mesh</span><br>        <span class="hljs-comment">// 在XOZ平面上分布</span><br>        mesh.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(i * <span class="hljs-number">200</span>, <span class="hljs-number">0</span>, j * <span class="hljs-number">200</span>);<br>        scene.<span class="hljs-title function_">add</span>(mesh); <span class="hljs-comment">//网格模型添加到场景中  </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>相机位置拉远，可以看到更大的观察范围</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">30</span>, width / height, <span class="hljs-number">1</span>, <span class="hljs-number">3000</span>);<br><span class="hljs-comment">// camera.position.set(292, 223, 185);</span><br><span class="hljs-comment">//在原来相机位置基础上拉远，可以观察到更大的范围</span><br> camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">800</span>, <span class="hljs-number">800</span>, <span class="hljs-number">800</span>);<br> camera.<span class="hljs-title function_">lookAt</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><strong>超出视锥体远裁界面的范围的会被剪裁掉</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);</span><br><span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">30</span>, width / height, <span class="hljs-number">1</span>, <span class="hljs-number">8000</span>);<br><span class="hljs-comment">// camera.position.set(292, 223, 185);</span><br><span class="hljs-comment">// 超出视锥体远裁界面的范围的会被剪裁掉，不渲染  可以调整far参数适配</span><br>camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2000</span>);<br>camera.<span class="hljs-title function_">lookAt</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><strong>改变相机观察目标</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);</span><br><span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">30</span>, width / height, <span class="hljs-number">1</span>, <span class="hljs-number">8000</span>);<br>camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2000</span>);<br><span class="hljs-comment">// camera.lookAt(0, 0, 0);</span><br><span class="hljs-comment">// 改变相机观察目标点</span><br>camera.<span class="hljs-title function_">lookAt</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><strong>注意相机控件OrbitControls会影响lookAt设置，注意手动设置OrbitControls的目标参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置相机控件轨道控制器OrbitControls</span><br><span class="hljs-keyword">const</span> controls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrbitControls</span>(camera, renderer.<span class="hljs-property">domElement</span>);<br><span class="hljs-comment">// 相机控件.target属性在OrbitControls.js内部表示相机目标观察点，默认0,0,0</span><br><span class="hljs-comment">// console.log(&#x27;controls.target&#x27;, controls.target);</span><br>controls.<span class="hljs-property">target</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>);<br>controls.<span class="hljs-title function_">update</span>();<span class="hljs-comment">//update()函数内会执行camera.lookAt(controls.targe)</span><br></code></pre></td></tr></table></figure><p><strong>远小近大投影规律</strong></p><p>透视投影相机的投影规律是<strong>远小近大</strong>，通过相机观察阵列立方体大小变化，可以看到距离相机越远，立方体的渲染视觉效果越小。</p><p><strong>fov改变</strong></p><p><strong>增加相机视角fov，视锥体范围更大</strong>，意味着可以看到渲染范围更大，远小近大的视觉效果更明显。</p><h2 id="15-Threejs常见几何体简介"><a href="#15-Threejs常见几何体简介" class="headerlink" title="15. Threejs常见几何体简介"></a>15. Threejs常见几何体简介</h2><p>介绍几个比较<strong>简单</strong>的案例</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E5%87%A0%E4%BD%95%E4%BD%93Geometry.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//BoxGeometry：长方体</span><br><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br><span class="hljs-comment">// SphereGeometry：球体</span><br><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SphereGeometry</span>(<span class="hljs-number">50</span>);<br><span class="hljs-comment">// CylinderGeometry：圆柱</span><br><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">CylinderGeometry</span>(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>);<br><span class="hljs-comment">// PlaneGeometry：矩形平面</span><br><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneGeometry</span>(<span class="hljs-number">100</span>,<span class="hljs-number">50</span>);<br><span class="hljs-comment">// CircleGeometry：圆形平面</span><br><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">CircleGeometry</span>(<span class="hljs-number">50</span>);<br></code></pre></td></tr></table></figure><p><strong>双面可见</strong></p><p>Three.js的材质默认正面可见，反面不可见,对于<strong>矩形</strong>平面<code>PlaneGeometry</code>、<strong>圆形</strong>平面如果你想看到两面，可以设置<code>side: THREE.DoubleSide</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123;<br>    <span class="hljs-attr">side</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">FrontSide</span>, <span class="hljs-comment">//默认只有正面可见</span><br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123;<br>    <span class="hljs-attr">side</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">DoubleSide</span>, <span class="hljs-comment">//两面可见</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="16-高光网格材质Phong"><a href="#16-高光网格材质Phong" class="headerlink" title="16. 高光网格材质Phong"></a>16. 高光网格材质Phong</h2><p>高光网格材质<code>MeshPhongMaterial</code>和基础网格材质<code>MeshBasicMaterial</code>、漫反射网格材质<code>MeshLambertMaterial</code>一样都是<strong>网格模型的<code>Mesh</code>的材质。</strong></p><p>高光网格材质MeshPhongMaterial和漫反射网格材质MeshLambertMaterial一样<strong>会受到光照的影响</strong>。</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8.svg" alt="img"></p><p><strong><code>MeshPhongMaterial</code>对光照反射特点</strong></p><p><code>MeshPhongMaterial</code>和<code>MeshLambertMaterial</code>都会收到光照的影响区别在于，<strong>对光线反射方式有差异。</strong></p><p><code>MeshPhongMaterial</code>可以实现<code>MeshLambertMaterial</code>不能实现的高光反射效果。对于高光效果，你可以想象一下，你在太阳下面观察一辆车，你会发现在特定角度和位置，你可以看到车表面<strong>某个局部区域非常高亮。</strong></p><p><strong>镜面反射与漫反射</strong></p><p><code>MeshPhongMaterial</code>可以提供一个镜面反射效果,可以类比你生活中拿一面镜子，放在太阳光下，调整角度，可以把太阳光反射到其它地方，如果反射光对着眼睛，也就是反射光线和视线平行的时候，会非常刺眼。</p><p><code>MeshLambertMaterial</code>对应的Mesh受到光线照射，没有镜面反射的效果，只是一个漫反射，也就是光线向四周反射。</p><p><img src="http://www.webgl3d.cn/imgthreejs/%E6%BC%AB%E5%8F%8D%E5%B0%84.jpg" alt="img"></p><p><strong>高光亮度属性<code>.shininess</code></strong></p><p>通过<code>MeshPhongMaterial</code>的高光亮度<code>.shininess</code>属性,可以控制高光反射效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟镜面反射，产生一个高光效果</span><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshPhongMaterial</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span>,<br>    <span class="hljs-attr">shininess</span>: <span class="hljs-number">20</span>, <span class="hljs-comment">//高光部分的亮度，默认30</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>高光颜色属性<code>.specular</code></strong></p><p>可以给颜色属性<code>.specular</code>设置不同的值，比如<code>0x444444</code>、<code>0xfffffff</code> 查看渲染效果变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟镜面反射，产生一个高光效果</span><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshPhongMaterial</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span>,<br>    <span class="hljs-attr">shininess</span>: <span class="hljs-number">20</span>, <span class="hljs-comment">//高光部分的亮度，默认30</span><br>    <span class="hljs-attr">specular</span>: <span class="hljs-number">0x444444</span>, <span class="hljs-comment">//高光部分的颜色</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="17-WebGL渲染器设置-锯齿模糊"><a href="#17-WebGL渲染器设置-锯齿模糊" class="headerlink" title="17. WebGL渲染器设置(锯齿模糊)"></a>17. WebGL渲染器设置(锯齿模糊)</h2><p>一般实际开发，threejs的WebGL渲染器需要进行一些通用的基础配置，本节课给大家简单介绍下,比如<strong>渲染模糊或锯齿问题</strong></p><p><strong>渲染器锯齿属性<code>.antialias</code></strong></p><p>设置渲染器锯齿属性<code>.antialias</code>的值可以直接在参数中设置，也可通过渲染器对象属性设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>(&#123;<br>  <span class="hljs-attr">antialias</span>:<span class="hljs-literal">true</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">renderer.<span class="hljs-property">antialias</span> = <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><p><strong>设备像素比<code>window.devicePixelRatio</code></strong></p><p>如果你有web前端基础，应该了解<code>window</code>对象，<strong>设备像素比</strong><code>.devicePixelRatio</code>是window对象的一个属性，该属性的值和你的硬件设备<strong>屏幕</strong>相关，不同硬件设备的屏幕<code>window.devicePixelRatio</code>的值可能不同，可能就是1、1.5、2.0等其它值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不同硬件设备的屏幕的设备像素比window.devicePixelRatio值可能不同</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;查看当前屏幕设备像素比&#x27;</span>,<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>);<br></code></pre></td></tr></table></figure><p><strong>设置设备像素比<code>.setPixelRatio()</code></strong></p><p>如果你遇到你的canvas画布输出模糊问题，注意<strong>设置<code>renderer.setPixelRatio(window.devicePixelRatio)</code>。</strong></p><p><em>注意：注意你的硬件设备设备像素比<code>window.devicePixelRatio</code>刚好是1，那么是否执行<code>.setPixelRatio()</code>不会有明显差异，不过为了适应不同的硬件设备屏幕，通常需要执行该方法。</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取你屏幕对应的设备像素比.devicePixelRatio告诉threejs,以免渲染模糊问题</span><br>renderer.<span class="hljs-title function_">setPixelRatio</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>);<br></code></pre></td></tr></table></figure><p><strong>设置背景颜色<code>.setClearColor()</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">renderer.<span class="hljs-title function_">setClearColor</span>(<span class="hljs-number">0x444444</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//设置背景颜色</span><br></code></pre></td></tr></table></figure><h2 id="18-gui-js库-可视化改变三维场景"><a href="#18-gui-js库-可视化改变三维场景" class="headerlink" title="18. gui.js库(可视化改变三维场景)"></a>18. gui.js库(可视化改变三维场景)</h2><p><strong>gui.js库(可视化改变三维场景)</strong></p><p>就是一个前端js库，对HTML、CSS和JavaScript进行了封装，学习开发的时候，借助<strong>dat.gui.js</strong>可以快速创建<strong>控制三维场景的UI交互界面</strong></p><p>学习<strong>dat.gui.js</strong>也不仅仅是为了学习<strong>dat.gui.js</strong>，也是建立一种思想，<strong>就是threejs三维空间的很多参数，不是心算出来的，往往需要可视化的方式调试出来</strong></p><p><strong>引入dat.gui.js</strong></p><p>gihtub地址：<a href="https://github.com/dataarts/dat.gui">https://github.com/dataarts/dat.gui</a></p><p>npm地址：<a href="https://www.npmjs.com/package/dat.gui">https://www.npmjs.com/package/dat.gui</a></p><p>你可以通过npm或github方式获得dat.gui.js库，当然为了学习方便，threejs官方案例扩展库中也提供了gui.js，你可以直接使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入dat.gui.js的一个类GUI</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">GUI</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/addons/libs/lil-gui.module.min.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>创建一个GUI对象</strong></p><p>创建一个GUI对象，你可以看到浏览器右上角多了一个交互界面，GUI本质上就是一个前端js库。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实例化一个gui对象</span><br><span class="hljs-keyword">const</span> gui = <span class="hljs-keyword">new</span> <span class="hljs-title function_">GUI</span>();<br></code></pre></td></tr></table></figure><p><strong><code>.domElement</code>：改变GUI界面默认的style属性</strong></p><p>通过<code>.domElement</code>属性可以获取gui界面的HTML元素，那就意味着你<strong>可以改变默认的style样式，比如位置、宽度等。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//改变交互界面style属性</span><br>gui.<span class="hljs-property">domElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">right</span> = <span class="hljs-string">&#x27;0px&#x27;</span>;<br>gui.<span class="hljs-property">domElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&#x27;300px&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong><code>.add()</code>方法</strong></p><p>执行gui的<code>.add()</code>方法可以快速创建一个UI交互界面，比如一个拖动条，可以用来改变一个JavaScript对象属性的属性值。</p><p>格式：<code>.add(控制对象，对象具体属性，其他参数)</code></p><p><strong>其他参数</strong>，可以一个或多个，数据类型也可以不同，gui会自动根据参数形式，自动生成对应的交互界面。</p><p>参数3和参数4，分别是一个<strong>数字</strong>，交互界面是一个鼠标可以拖动的<strong>拖动条</strong>，可以在一个区间改变属性的值</p><p>执行<code>gui.add(obj, &#39;x&#39;, 0, 100);</code>你可以发现右上角gui界面增加了新的内容，可以控制obj对象x属性的新交互界面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建一个对象，对象属性的值可以被GUI库创建的交互界面改变</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">30</span>,<br>&#125;;<br><span class="hljs-comment">// gui增加交互界面，用来改变obj对应属性</span><br>gui.<span class="hljs-title function_">add</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p><strong>体验<code>.add()</code>功能——改变对象属性值</strong></p><p>为了方便观察<code>.add()</code>是如何改变JavaScript对象属性的，可以浏览器控制台不停地打印obj的值，这样通过gui界面拖动改变obj对象属性的的时候，便于观察obj的变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">30</span>&#125;;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x&#x27;</span>, obj.<span class="hljs-property">x</span>);<br>&#125;, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p><strong>gui改变js对象多个属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-attr">z</span>: <span class="hljs-number">300</span>,<br>&#125;;<br><span class="hljs-comment">// gui界面上增加交互界面，改变obj对应属性</span><br>gui.<span class="hljs-title function_">add</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>gui.<span class="hljs-title function_">add</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>);<br>gui.<span class="hljs-title function_">add</span>(obj, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>);<br></code></pre></td></tr></table></figure><p><strong>gui改变threejs光照强度测试</strong></p><p>three.js在调试场景渲染效果的时候，比如光照的强度，人大脑的CPU是没有能力通过光照参数算出来模型渲染效果的，一般来说你先大概给一个经验值，然后通过gui在这个大概值的基础上下浮动可视化调试。</p><p>光源对象具有一个光照强度属性<code>.intensity</code>，可以通过gui拖动条改变该属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 光照强度属性.intensity</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ambient.intensity&#x27;</span>,ambient.<span class="hljs-property">intensity</span>);<br><span class="hljs-comment">// 通过GUI改变mesh.position对象的xyz属性</span><br>gui.<span class="hljs-title function_">add</span>(ambient, <span class="hljs-string">&#x27;intensity&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure><p><strong>gui改变threejs模型位置测试</strong></p><p><code>mesh.position</code>是JavaScript对象，具有<code>x</code>、<code>y</code>、<code>z</code>属性,这三个属性分别表示模型的xyz坐标，这就是说，<strong>gui改变<code>mesh.position</code>的<code>x</code>、<code>y</code>、<code>z</code>属性，就可以可视化改变mesh的位置。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">gui.<span class="hljs-title function_">add</span>(mesh.<span class="hljs-property">position</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">180</span>);<br>gui.<span class="hljs-title function_">add</span>(mesh.<span class="hljs-property">position</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">180</span>);<br>gui.<span class="hljs-title function_">add</span>(mesh.<span class="hljs-property">position</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">180</span>);<br></code></pre></td></tr></table></figure><h2 id="19-gui调试界面2-颜色命名等"><a href="#19-gui调试界面2-颜色命名等" class="headerlink" title="19. gui调试界面2-颜色命名等"></a>19. gui调试界面2-颜色命名等</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Webpack</title>
    <link href="/2024/11/05/webpack/"/>
    <url>/2024/11/05/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="Webpack上"><a href="#Webpack上" class="headerlink" title="Webpack上"></a>Webpack上</h1><p>资料来自:<a href="https://blog.csdn.net/2301_78542842/article/details/138397841">webpack超详细教程，学webpack看这一篇就够了！（上）_webpack教程-CSDN博客</a></p><p>视频资料:<a href="https://www.bilibili.com/video/BV11g411y7Sd/?spm_id_from=333.337.search-card.all.click&vd_source=27cb0115158d7f1bbfe93adc7370ebf2">30 分钟掌握 Webpack_哔哩哔哩_bilibili</a></p><p>要遍历并显示 <code>../../file/md</code> 目录下的所有 Markdown 文件，你可以使用 <strong>Webpack 的 <code>require.context</code></strong> 来动态导入目录中的所有 <code>.md</code> 文件。JavaScript 原生不支持直接读取目录中的文件，但 Webpack 可以帮忙在编译时将文件打包进来。以下是具体步骤：</p><ol><li>**使用 Webpack 的 <code>require.context</code>**：<br>先用 <code>require.context</code> 加载目录中所有 <code>.md</code> 文件，生成一个模块集合。</li><li><strong>遍历文件内容并显示</strong>：<br>将文件内容读取后，逐个显示。</li></ol><h2 id="一、webpack简介及体验"><a href="#一、webpack简介及体验" class="headerlink" title="一、webpack简介及体验"></a>一、webpack简介及体验</h2><h3 id="1、webpack简介"><a href="#1、webpack简介" class="headerlink" title="1、webpack简介"></a>1、webpack简介</h3><p>Webpack 是一个<strong>静态模块打包工具</strong>，从入口构建依赖图，打包有关的模块，最后用于展示你的内容</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2d2166cade467d7ff79d0f0a2e2e63ba.png" alt="img"></p><h3 id="2、webpack作用"><a href="#2、webpack作用" class="headerlink" title="2、webpack作用"></a>2、webpack作用</h3><p>把静态模块内容，<strong>压缩、转译、打包等（前端工程化）</strong></p><ul><li>把 less&#x2F;sass 转成 css 代码</li><li>把 ES6+ 降级成 ES5 等</li><li>支持多种模块文件类型，多种模块标准语法</li></ul><h3 id="3、体验Webpack-打包-2-个-JS-文件内容"><a href="#3、体验Webpack-打包-2-个-JS-文件内容" class="headerlink" title="3、体验Webpack 打包 2 个 JS 文件内容"></a>3、体验Webpack 打包 2 个 JS 文件内容</h3><p><strong>3.2.1 新建项目文件夹 Webpack_study，初始化包环境，得到 package.json 文件</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init -y<br></code></pre></td></tr></table></figure><p><strong>3.2.2 新建 src 源代码文件夹（书写代码）包括 utils&#x2F;check.js 封装用户名和密码长度函数，引入到 src&#x2F;index.js 进行使用</strong></p><p>src&#x2F;utils&#x2F;check.js</p><pre><code class="hljs">// 封装校验手机号长度和校验验证码长度的函数export const checkPhone = phone =&gt; phone.length === 11export const checkCode = code =&gt; code.length === 6</code></pre><p> src&#x2F;login&#x2F;index.js</p><pre><code class="hljs">import &#123; checkPhone, checkCode &#125; from &#39;../utils/check.js&#39;console.log(checkPhone(&#39;13900002020&#39;))console.log(checkCode(&#39;123123123123&#39;))</code></pre><p> <strong>3.2.3 下载 webpack webpack-cli 到项目（版本独立）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> webpack webpack-cli <span class="hljs-attr">--save-dev</span><br></code></pre></td></tr></table></figure><p><strong>注意：虽然 webpack 是全局软件包，封装的是命令工具，但是为了保证项目之间版本分别独立，所以这次比较特殊，下载到某个项目环境下，但是需要把 webpack 命令配置到 package.json 的 scripts 自定义命令，作为局部命令使用</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/03d2b822df00d2c7d5ea7e0718a9b920.png" alt="img"></p><p>3.2.4 项目中<strong>运行工具命令</strong>，采用自定义命令的方式（局部命令）</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> run build<br></code></pre></td></tr></table></figure><p>npm run 自定义命令名字</p><p><strong>注意：实际上在终端运行的是 build 右侧的具体命名</strong></p><p>3.2.5 自动产生 dist 分发文件夹（压缩和优化后，用于最终运行的代码）</p><blockquote><p><strong>注意：Webpack 默认入口和出口分别为：</strong></p><p><strong>src&#x2F;index.js 和 dist&#x2F;main.js</strong></p></blockquote><p><strong>最终流程图：</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/692192bdbc98da6a072d9991b9be29c0.png" alt="img"></p><h2 id="二、Webpack-修改入口和出口"><a href="#二、Webpack-修改入口和出口" class="headerlink" title="二、Webpack 修改入口和出口"></a>二、Webpack 修改入口和出口</h2><h3 id="1、实现步骤"><a href="#1、实现步骤" class="headerlink" title="1、实现步骤"></a>1、实现步骤</h3><p>1.1 项目根目录，新建 <strong>Webpack.config.js</strong> 配置文件</p><p>1.2 导出<strong>配置对象，配置入口、出口文件路径</strong>（别忘了修改磁盘文件夹和文件的名字）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">const <span class="hljs-selector-tag">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>) <span class="hljs-comment">// node自带的path模块</span><br> <br>module<span class="hljs-selector-class">.exports</span> = &#123;<br>  entry: <span class="hljs-selector-tag">path</span><span class="hljs-selector-class">.resolve</span>(__dirname, <span class="hljs-string">&#x27;src/login/index.js&#x27;</span>),<br>  output: &#123;<br>    <span class="hljs-selector-tag">path</span>: <span class="hljs-selector-tag">path</span><span class="hljs-selector-class">.resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    filename: <span class="hljs-string">&#x27;./login/index.js&#x27;</span>  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.3 重新打包观察</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> build<br></code></pre></td></tr></table></figure><h3 id="2、图解"><a href="#2、图解" class="headerlink" title="2、图解"></a>2、图解</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2cb6099a8cffd426c42982d930fe9543.png" alt="img"></p><h2 id="三、案例练习"><a href="#三、案例练习" class="headerlink" title="三、案例练习"></a>三、案例练习</h2><p>接下来我们通过一个小案例再巩固一下webpack打包的知识</p><h3 id="1、目标"><a href="#1、目标" class="headerlink" title="1、目标"></a>1、目标</h3><p>写一段登录相关的js代码（点击登录按钮，判断手机号和验证码长度是否符合要求），让 Webpack 打包 JS 代码，运行 dist&#x2F;login.html 在浏览器查看效果</p><h3 id="2、实现步骤"><a href="#2、实现步骤" class="headerlink" title="2、实现步骤"></a>2、实现步骤</h3><p>2.1 新建 <strong>public&#x2F;login.html</strong> 准备网页模板（方便查找标签和后期自动生成 html 文件做准备）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1281d2dbbbe3fa4bc6aafa1aa97440f.png" alt="img"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login-form&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>用户登录<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mobile&quot;</span>&gt;</span>手机号：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mobile&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mobile&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入手机号&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>验证码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入验证码&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../src/login/index.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.2 核心 JS 代码写在 <strong>src&#x2F;login&#x2F;index.js</strong> 文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：用户登录-长度判断案例</span><br><span class="hljs-comment"> *  1 准备用户登录页面</span><br><span class="hljs-comment"> *  2 编写核心 JS 逻辑代码</span><br><span class="hljs-comment"> *  3 打包并手动复制网页到 dist 下，引入打包后的 js，运行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//2 编写核心 JS 逻辑代码</span><br>document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&#x27;.btn&#x27;</span>)<span class="hljs-selector-class">.addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>  const phone = document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&#x27;.login-form [name=mobile]&#x27;</span>)<span class="hljs-selector-class">.value</span><br>  const <span class="hljs-selector-tag">code</span> = document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&#x27;.login-form [name=code]&#x27;</span>)<span class="hljs-selector-class">.value</span><br> <br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">checkPhone</span>(phone)) &#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;手机号长度必须是11位&#x27;</span>)<br>    return<br>  &#125;<br> <br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">checkCode</span>(code)) &#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;验证码长度必须是6位&#x27;</span>)<br>    return<br>  &#125;<br> <br>  console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;提交到服务器登录...&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>2.3 运行自定义命令，让 Webpack 打包 JS 代码</p><p>2.4 <strong>手动复制</strong> public&#x2F;login.html 到 dist 下（<strong>先手动引入，下面会讲 Webpack 自动生成 html 文件</strong>），手动引入打包后的 JS 代码文件，运行 dist&#x2F;login.html 在浏览器查看效果</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2cb2ddcb7297857b8d4a3895a25a9cde.png" alt="img"></p><h2 id="四、Webpack-自动生成-html-文件"><a href="#四、Webpack-自动生成-html-文件" class="headerlink" title="四、Webpack 自动生成 html 文件"></a>四、<strong>Webpack 自动生成 html 文件</strong></h2><h3 id="1、目标-1"><a href="#1、目标-1" class="headerlink" title="1、目标"></a>1、目标</h3><p>让 Webpack 拥有<strong>自动生成 html 文件能力</strong>，并引入打包后的其他资源，这里的重点就是通过html-webpack-plugin 插件来实现</p><h3 id="2、实现步骤-1"><a href="#2、实现步骤-1" class="headerlink" title="2、实现步骤"></a>2、实现步骤</h3><p>2.1 下载 html-webpack-plugin 本地软件包到项目中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">html</span>-webpack-plugin <span class="hljs-attr">--save-dev</span><br></code></pre></td></tr></table></figure><p>2.2 配置 webpack.config.js 让 Webpack 拥有插件功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cobol">// ...<br>const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)<br> <br>module.exports = &#123;<br>  // ...<br>  plugins: [<br>    new HtmlWebpackPlugin(&#123;<br>      template: &#x27;./public/login.html&#x27;, // 模板文件<br>      filename: &#x27;./login/index.html&#x27; // 输出文件<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>2.3 指定<strong>以 public&#x2F;login.html 为模板复制到 dist&#x2F;login&#x2F;index.html</strong>，并自动引入其他打包后资源</p><p>2.4 运行打包命令，<strong>观察打包后 dist 文件夹下内容并运行查看效果</strong></p><h2 id="四、Webpack-打包-css-代码"><a href="#四、Webpack-打包-css-代码" class="headerlink" title="四、Webpack-打包 css 代码"></a>四、Webpack-打包 css 代码</h2><h3 id="1、前置知识"><a href="#1、前置知识" class="headerlink" title="1、前置知识"></a>1、前置知识</h3><p><strong>1.1 加载器</strong>：让 Webpack 识别更多的代码内容类型</p><p><strong>Webpack 默认只识别 JS 和 JSON 文件内容，所以想要让 Webpack 识别更多不同内容，需要使用加载器</strong>。也就是说，如果想要在打包的时候顺利打包css代码，就需要在webpack中引入css相关的加载器</p><p>1.2 打包 css 代码所需的<strong>两个加载器</strong></p><p><strong>1 加载器 css-loader</strong><br><a href="https://webpack.docschina.org/loaders/css-loader/">css-loader | webpack 中文文档</a><br>加载器 css-loader用来解析 css 代码</p><p><strong>2 加载器 style-loader</strong></p><p>​<a href="https://webpack.docschina.org/loaders/style-loader/">style-loader | webpack 中文文档</a></p><p>加载器 style-loader用来把解析后的 css 代码插入到 DOM（style 标签之间）</p><h3 id="2、实现步骤-2"><a href="#2、实现步骤-2" class="headerlink" title="2、实现步骤"></a>2、实现步骤</h3><p>2.1 准备 css 文件引入到 src&#x2F;login&#x2F;index.js 中</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;bootstrap/dist/css/bootstrap.min.css&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span><br></code></pre></td></tr></table></figure><p><em><strong>注意：这里只是引入代码内容让 Webpack 处理，不需定义变量接收在 JS 代码中继续使用，所以没有定义变量接收</strong></em></p><p>2.2 下载 css-loader 和 style-loader 本地软件包</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> css-loader style-loader <span class="hljs-attr">--save-dev</span><br></code></pre></td></tr></table></figure><p>2.3 配置 webpack.config.js 让 Webpack 拥有该加载器功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cobol">// ...<br> <br>module.exports = &#123;<br>  // ...<br>  module: &#123; // 加载器<br>    rules: [ // 规则列表<br>      &#123;<br>        test: /\.css$/i, // 匹配 .css 结尾的文件<br>        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], // 使用从后到前的加载器来解析 css 代码和插入到 DOM<br>      &#125;<br>    ]<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2.4 打包后运行 dist&#x2F;login&#x2F;index.html 观察效果，看看准备好的样式是否作用在网页上</p><h3 id="3、优化-提取-css-代码"><a href="#3、优化-提取-css-代码" class="headerlink" title="3、优化-提取 css 代码"></a>3、优化-提取 css 代码</h3><p><strong>3.1 目标</strong></p><p>让 <strong>Webpack 能够提取 css 代码到独立的 css 文件中</strong>，好处：css 文件可以被浏览器缓存，减少 JS 文件体积，让浏览器并行下载 css 和 js 文件</p><p>例如，继续上面的练习，我们需要<strong>让 webpack 把 css 代码内容字符串单独提取到 dist 下的 css 文件中</strong>，这需要一个关键插件**–mini-css-extract-plugin 插件**来实现 </p><p> <strong>3.2 实现步骤</strong></p><p>3.2.1 下载 <strong>mini-css-extract-plugin</strong> 插件软件包到本地项目中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> <span class="hljs-attr">--save-dev</span> mini-css-extract-plugin<br></code></pre></td></tr></table></figure><p>3.2.2 配置 webpack.config.js 让 Webpack 拥有该插件功能</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// ...</span><br>const MiniCssExtractP<span class="hljs-attr">lugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>)<br> <br>module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// ...</span><br><span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    rules:</span> [<br>      <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        test:</span> /\.css$/i,<br>        <span class="hljs-comment">// use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]</span><br><span class="hljs-symbol">        use:</span> [MiniCssExtractPlugin.loader, <span class="hljs-string">&quot;css-loader&quot;</span>],<br>      <span class="hljs-punctuation">&#125;</span>,<br>    ],<br>  <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">  plugins:</span> [<br>    <span class="hljs-comment">// ...</span><br>    new MiniCssExtractPlugin()<br>  ]<br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>3.2.3 打包后观察效果,这样做<strong>使得css 文件可以被浏览器缓存，减少 JS 文件体积</strong>，让浏览器并行下载 css 和 js 文件</p><p><em><strong>注意：不能和 style-loader 一起使用</strong></em></p><h3 id="4、进一步优化压缩过程–把单独提取的-css-文件内代码压缩"><a href="#4、进一步优化压缩过程–把单独提取的-css-文件内代码压缩" class="headerlink" title="4、进一步优化压缩过程–把单独提取的 css 文件内代码压缩"></a>4、进一步优化压缩过程–把单独提取的 css 文件内代码压缩</h3><p><strong>4.1 下载 mini-css-extract-plugin 插件软件包到本地项目中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> css-minimizer-webpack-plugin <span class="hljs-attr">--save-dev</span> <br></code></pre></td></tr></table></figure><p><strong>4.2 配置 webpack.config.js 让 Webpack 拥有该插件功能</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cobol">// ...<br>const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);<br> <br>module.exports = &#123;<br>  // ...<br>  // 优化<br>  optimization: &#123;<br>    // 最小化<br>    minimizer: [<br>      // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 <br>      // `terser-webpack-plugin`），将下一行取消注释（保证 JS 代码还能被压缩处理）<br>      `...`,<br>      new CssMinimizerPlugin(),<br>    ],<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>4.3 打包后观察 css 文件内自己代码是否被压缩了</strong></p><h2 id="五、Webpack-打包-less-代码"><a href="#五、Webpack-打包-less-代码" class="headerlink" title="五、Webpack-打包 less 代码"></a>五、<strong>Webpack-打包 less 代码</strong></h2><p>目标：让 Webpack 拥有打包 less 代码功能</p><p>用到的关键加载器：</p><p><strong>加载器 less-loader</strong></p><p><a href="https://webpack.docschina.org/loaders/less-loader/">less-loader | webpack 中文文档</a></p><p>用来把 less 代码编译为 css 代码</p><h3 id="1、新建-login-index-less-文件，设置背景图样式"><a href="#1、新建-login-index-less-文件，设置背景图样式" class="headerlink" title="1、新建 login&#x2F;index.less 文件，设置背景图样式"></a>1、新建 login&#x2F;index.less 文件，设置背景图样式</h3><p>ps : 这里随便引用一张自己电脑上的图片即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;./assets/login-bg.png&#x27;</span>) no-repeat center/cover;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、less-样式引入到-src-login-index-js-中"><a href="#2、less-样式引入到-src-login-index-js-中" class="headerlink" title="2、less 样式引入到 src&#x2F;login&#x2F;index.js 中"></a>2、less 样式引入到 src&#x2F;login&#x2F;index.js 中</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.less&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3、下载-less-和-less-loader-本地软件包"><a href="#3、下载-less-和-less-loader-本地软件包" class="headerlink" title="3、下载 less 和 less-loader 本地软件包"></a>3、下载 less 和 less-loader 本地软件包</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm i <span class="hljs-keyword">less</span> <span class="hljs-keyword">less</span>-loader --save-dev<br></code></pre></td></tr></table></figure><h3 id="4、配置-webpack-config-js-让-Webpack-拥有功能"><a href="#4、配置-webpack-config-js-让-Webpack-拥有功能" class="headerlink" title="4、配置 webpack.config.js 让 Webpack 拥有功能"></a>4、配置 webpack.config.js 让 Webpack 拥有功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cobol">// ...<br> <br>module.exports = &#123;<br>  // ...<br>  module: &#123;<br>    rules: [<br>      // ...<br>      &#123;<br>        test: /\.less$/i,<br>        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;less-loader&quot;]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、打包后运行-观察效果"><a href="#5、打包后运行-观察效果" class="headerlink" title="5、打包后运行 观察效果"></a>5、打包后运行 观察效果</h3><h2 id="六、让-Webpack-支持图片等资源打包"><a href="#六、让-Webpack-支持图片等资源打包" class="headerlink" title="六、让 Webpack 支持图片等资源打包"></a>六、让 Webpack 支持图片等资源打包</h2><blockquote><p>Webpack <strong>内置</strong>了资源模块的打包，无需下载额外 loader</p></blockquote><h3 id="1-配置-webpack-config-js-让-Webpack-拥有打包图片功能"><a href="#1-配置-webpack-config-js-让-Webpack-拥有打包图片功能" class="headerlink" title="1.配置 webpack.config.js 让 Webpack 拥有打包图片功能"></a>1.配置 webpack.config.js 让 Webpack 拥有打包图片功能</h3><blockquote><p>占位符 【hash】对模块内容做算法计算，得到映射的数字字母组合的字符串</p><p>占位符 【ext】使用当前模块原本的占位符，例如：.png &#x2F; .jpg 等字符串</p><p>占位符 【query】保留引入文件时代码中查询参数（只有 URL 下生效</p></blockquote><blockquote><p>注意：判断临界值默认为 8KB</p><p>大于 8KB 文件：发送一个单独的文件并导出 URL 地址</p><p>小于 8KB 文件：导出一个 data URI（base64字符串）  </p></blockquote><h3 id="2-在-src-login-index-js-中给-img-标签添加-logo-图片"><a href="#2-在-src-login-index-js-中给-img-标签添加-logo-图片" class="headerlink" title="2. 在 src&#x2F;login&#x2F;index.js 中给 img 标签添加 logo 图片"></a>2. 在 src&#x2F;login&#x2F;index.js 中给 img 标签添加 logo 图片</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 注意：js 中引入本地图片资源要用 import 方式（如果是网络图片http地址，字符串可以直接写）</span><br><span class="hljs-keyword">import</span> imgObj <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./assets/logo.png&#x27;</span><br><span class="hljs-keyword">const</span> theImg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>)<br>theImg.<span class="hljs-property">src</span> = imgObj<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.login-wrap&#x27;</span>).<span class="hljs-title function_">appendChild</span>(theImg)<br></code></pre></td></tr></table></figure><h3 id="3-配置-webpack-config-js-让-Webpack-拥有打包图片功能"><a href="#3-配置-webpack-config-js-让-Webpack-拥有打包图片功能" class="headerlink" title="3. 配置 webpack.config.js 让 Webpack 拥有打包图片功能"></a>3. 配置 webpack.config.js 让 Webpack 拥有打包图片功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cobol">// ...<br> <br>module.exports = &#123;<br>  // ...<br>  module: &#123;<br>    rules: [<br>      // ...<br>      &#123;<br>        test: /\.(png|jpg|jpeg|gif)$/i,<br>        type: &#x27;asset&#x27;,<br>        generator: &#123;<br>          filename: &#x27;assets/[hash][ext][query]&#x27;<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-打包后运行观察效果。"><a href="#4-打包后运行观察效果。" class="headerlink" title="4. 打包后运行观察效果。"></a>4. 打包后运行观察效果。</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h1 id="Webpack下"><a href="#Webpack下" class="headerlink" title="Webpack下"></a>Webpack下</h1><h2 id="一、Webpack-搭建开发环境"><a href="#一、Webpack-搭建开发环境" class="headerlink" title="一、Webpack 搭建开发环境"></a>一、Webpack 搭建开发环境</h2><h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a><strong>1、背景</strong></h3><p>1.1 每次改动代码，都要重新打包，很麻烦，所以这里<strong>给项目集成 webpack-dev-server 开发服务器</strong>，快速开发应用程序</p><p>1.2 作用：启动 Web 服务，打包输出源码在内存，并会自动检测代码变化热更新到网页</p><h3 id="2、实现步骤-3"><a href="#2、实现步骤-3" class="headerlink" title="2、实现步骤"></a><strong>2、实现步骤</strong></h3><p>2.1 下载 <strong>webpack-dev-server</strong> 软件包到当前项目</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm i webpack-<span class="hljs-built_in">dev</span>-server --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>2.2 配置自定义命令，并设置打包的模式为开发模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cobol">// ...<br> <br>module.exports = &#123;<br>  // ...<br>  mode: &#x27;development&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>  <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack serve --mode=development&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>2.3 使用 <strong>npm run dev</strong> 来启动开发服务器，访问提示的<strong>域名+端口号</strong>，在浏览器访问打包后的项目网页，修改代码后试试热更新效果</p><blockquote><p>在 js &#x2F; css 文件中修改代码保存后，会实时反馈到浏览器</p></blockquote><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>启动 Webpack 开发服务器，会启动一个 Web 服务，实时检测代码变化重新打包，并快速反应最新效果到浏览器页面上</p><h2 id="二、Webpack-打包模式"><a href="#二、Webpack-打包模式" class="headerlink" title="二、Webpack 打包模式"></a>二、Webpack 打包模式</h2><h3 id="1、分类"><a href="#1、分类" class="headerlink" title="1、分类"></a>1、分类</h3><table><thead><tr><th align="left"><strong>模式名称</strong></th><th align="left"><strong>模式名字</strong></th><th align="left"><strong>特点</strong></th><th align="left">场景</th></tr></thead><tbody><tr><td align="left">开发模式</td><td align="left">development</td><td align="left">调试代码，实时加载，模块热替换等</td><td align="left">本地开发</td></tr><tr><td align="left">生产模式</td><td align="left">production</td><td align="left">压缩代码，资源优化，更轻量等</td><td align="left">打包上线</td></tr></tbody></table><h3 id="2、如何设置影响-Webpack–两种方式"><a href="#2、如何设置影响-Webpack–两种方式" class="headerlink" title="2、如何设置影响 Webpack–两种方式"></a>2、如何设置影响 Webpack–两种方式</h3><p>2.1 在 webpack.config.js 配置文件<strong>设置 mode 选项</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ...</span><br> <br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  mode: <span class="hljs-string">&#x27;production&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.2 在 package.json 命令行<strong>设置 mode 参数</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --mode=production&quot;</span>,<br>  <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack serve --mode=development&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><blockquote><p>注意：命令行设置的优先级高于配置文件中的，<strong>推荐用命令行设置</strong></p></blockquote><h3 id="3、两种打包模式的区别"><a href="#3、两种打包模式的区别" class="headerlink" title="3、两种打包模式的区别"></a>3、两种打包模式的区别</h3><blockquote><p><strong>开发模式注重代码热替换更快，让开发调试代码更便捷</strong></p><p><strong>生产模式注重项目体积更小</strong>，更轻量，适配不同的浏览器环境</p></blockquote><h2 id="三、Webpack-前端注入环境变量"><a href="#三、Webpack-前端注入环境变量" class="headerlink" title="三、Webpack 前端注入环境变量"></a>三、Webpack 前端注入环境变量</h2><p>使用 Webpack 内置的 DefinePlugin 插件 ，实现在编译时，将前端代码中匹配的变量名替换为值或表达式 。从而实现前端项目中，开发模式下打印语句生效，生产模式下打印语句失效这样的效果</p><p><strong>配置 webpack.config.js 中给前端注入环境变量 ，代码示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cobol">// ...<br>const webpack = require(&#x27;webpack&#x27;)<br> <br>module.exports = &#123;<br>  // ...<br>  plugins: [<br>    // ...<br>    new webpack.DefinePlugin(&#123;<br>      // key 是注入到打包后的前端 JS 代码中作为全局变量<br>      // value 是变量对应的值（在 corss-env 注入在 node.js 中的环境变量字符串）<br>      &#x27;process.env.NODE_ENV&#x27;: JSON.stringify(process.env.NODE_ENV)<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、Webpack-设置解析别名路径"><a href="#四、Webpack-设置解析别名路径" class="headerlink" title="四、Webpack 设置解析别名路径"></a>四、<strong>Webpack 设置解析别名路径</strong></h2><h3 id="1、目标-2"><a href="#1、目标-2" class="headerlink" title="1、目标"></a>1、目标</h3><p>创建 import 或 require 的别名，来确保模块引入变得更简单</p><h3 id="2、实现步骤-4"><a href="#2、实现步骤-4" class="headerlink" title="2、实现步骤"></a>2、实现步骤</h3><p>2.1 原来路径如下</p><p>import { checkPhone, checkCode } from ‘..&#x2F;src&#x2F;utils&#x2F;check.js’</p><p>2.2 <strong>配置解析别名</strong>：在 webpack.config.js 中设置</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-comment">// ...</span><br>  resolve: &#123;<br>    <span class="hljs-keyword">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: path.resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">路径中的 &#x27;@&#x27; 符号代表什么意思 ？<br>看在 webpack 配置中的别名路径是什么，就会在打包时替换成哪个路径使用  <br></code></pre></td></tr></table></figure><h4 id="2-3-这样我们以后，引入目标模块写的路径就更简单了（可以更换为-）"><a href="#2-3-这样我们以后，引入目标模块写的路径就更简单了（可以更换为-）" class="headerlink" title="2.3 这样我们以后，引入目标模块写的路径就更简单了（可以更换为 @ ）"></a>2.3 这样我们以后，引入目标模块写的路径就更简单了（可以更换为 @ ）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; checkPhone, checkCode &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/check.js&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2-4-修改代码的路径后，重新打包观察效果是否正常！"><a href="#2-4-修改代码的路径后，重新打包观察效果是否正常！" class="headerlink" title="2.4 修改代码的路径后，重新打包观察效果是否正常！"></a>2.4 修改代码的路径后，重新打包观察效果是否正常！</h4><h2 id="五、优化-CDN使用"><a href="#五、优化-CDN使用" class="headerlink" title="五、优化-CDN使用"></a>五、优化-CDN使用</h2><h3 id="1、目标-3"><a href="#1、目标-3" class="headerlink" title="1、目标"></a>1、目标</h3><p>开发模式使用本地第三方库，生产模式下使用 CDN 加载引入</p><h3 id="2、使用CDN"><a href="#2、使用CDN" class="headerlink" title="2、使用CDN"></a>2、使用CDN</h3><p>2.1 cdn定义<br>内容分发网络，指的是一组分布在各个地区的服务器</p><p>2.2 cdn作用<br>把静态资源文件&#x2F;第三方库放在 CDN 网络中各个服务器中，供用户就近请求获取。</p><p><strong>好处：减轻自己服务器请求压力，就近请求物理延迟低，配套缓存策略。</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/dae8055062785eab28dee080ceb9fcb8.png" alt="img"></p><h3 id="3、实现需求的思路图"><a href="#3、实现需求的思路图" class="headerlink" title="3、实现需求的思路图"></a>3、实现需求的思路图</h3><p>假设我们之前发送请求时通过下载axios的npm包来实现，那么下面这张图的思路就是换成了—-在生产模式下是通过引入axios的cdn链接来实现，这样做能够减少自身的体积，提升响应性能</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5ed8e6de4b0472bc10e376c48373bf81.png" alt="img"></p><h3 id="4、具体步骤"><a href="#4、具体步骤" class="headerlink" title="4、具体步骤"></a>4、具体步骤</h3><p><strong>4.1 在 html 中引入第三方库的 <a href="https://www.bootcdn.cn/">CDN </a><a href="https://www.bootcdn.cn/">地址</a>并用模板语法判断</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;% <span class="hljs-keyword">if</span>(htmlWebpackPlugin.options.useCdn)&#123; %&gt;<br>    &lt;link <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.2.3/css/bootstrap.min.css&quot;</span> <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;<br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure><p><strong>4.2 配置 webpack.config.js 中 <a href="https://webpack.docschina.org/configuration/externals">externals</a> 外部扩展选项（防止某些 import 的包被打包）</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">// 生产环境下使用相关配置</span><br>   <span class="hljs-keyword">if</span> (process.<span class="hljs-keyword">env</span>.NODE_ENV === <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>     <span class="hljs-comment">// 外部扩展（让 webpack 防止 import 的包被打包进来）</span><br>     config.externals = &#123;<br>       <span class="hljs-comment">// key：import from 语句后面的字符串</span><br>       <span class="hljs-comment">// value：留在原地的全局变量（最好和 cdn 在全局暴露的变量一致）</span><br>       <span class="hljs-string">&#x27;bootstrap/dist/css/bootstrap.min.css&#x27;</span>: <span class="hljs-string">&#x27;bootstrap&#x27;</span>,<br>       <span class="hljs-string">&#x27;axios&#x27;</span>: <span class="hljs-string">&#x27;axios&#x27;</span><br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-comment">// ...</span><br>  plugins: [<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-comment">// ...</span><br>      <span class="hljs-comment">// 自定义属性，在 html 模板中 &lt;%=htmlWebpackPlugin.options.useCdn%&gt; 访问使用</span><br>      useCdn: process.env.NODE_ENV === <span class="hljs-string">&#x27;production&#x27;</span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-两种模式下打包观察效果"><a href="#4-3-两种模式下打包观察效果" class="headerlink" title="4.3 两种模式下打包观察效果"></a>4.3 两种模式下打包观察效果</h4><h1 id="webpack官网教程"><a href="#webpack官网教程" class="headerlink" title="webpack官网教程"></a>webpack官网教程</h1><p><a href="https://www.webpackjs.com/concepts/#entry">概念 | webpack 中文文档 | webpack中文文档 | webpack中文网</a></p><p>一些<strong>核心概念</strong>：</p><ul><li><a href="https://www.webpackjs.com/concepts/#entry">入口(entry)</a></li><li><a href="https://www.webpackjs.com/concepts/#output">输出(output)</a></li><li><a href="https://www.webpackjs.com/concepts/#loaders">loader</a></li><li><a href="https://www.webpackjs.com/concepts/#plugins">插件(plugin)</a></li><li><a href="https://www.webpackjs.com/concepts/#mode">模式(mode)</a></li><li><a href="https://www.webpackjs.com/concepts/#browser-compatibility">浏览器兼容性(browser compatibility)</a></li><li><a href="https://www.webpackjs.com/concepts/#environment">环境(environment)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react教程</title>
    <link href="/2024/11/05/react/"/>
    <url>/2024/11/05/react/</url>
    
    <content type="html"><![CDATA[<h1 id="react教程"><a href="#react教程" class="headerlink" title="react教程"></a>react教程</h1><h2 id="初始React"><a href="#初始React" class="headerlink" title="初始React"></a>初始React</h2><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241104231125908.png" alt="image-20241104231125908"></p><p><strong>官方脚手架可能会比较简单，会缺少一些必要插件</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105001606377.png" alt="image-20241105001606377"></p><p><strong>react项目文件</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105003653779.png" alt="image-20241105003653779"></p><p><strong>react项目组件关系</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105002351044.png" alt="image-20241105002351044"></p><p>主要两个库，一个是react库，另一个是reactDOM库</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105003255976.png" alt="image-20241105003255976"></p><p>可以实现2s后卸载root组件（使用unmount()）</p><h2 id="react与jsx"><a href="#react与jsx" class="headerlink" title="react与jsx"></a>react与jsx</h2><p>组件化开发，定义一个<strong>基本组件的东西</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105002542551.png" alt="image-20241105002542551"></p><p><strong>react组件分类</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105002602438.png" alt="image-20241105002602438"></p><p><strong>函数组件，直接返回一个jsx格式的文件（现在主流新写法）</strong></p><p>class类组件中，要注意会返回一个render渲染函数，其作用是将组件渲染到 DOM 上</p><p>示例如下，在App.js文件中<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105004234482.png" alt="image-20241105004234482"></p><p>上面的写法<strong>使用的是jsx的写法</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105004345671.png" alt="image-20241105004345671"></p><p>注意：<strong>jsx和react相互独立</strong>，也就是写react不一定非用jsx的写法</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105004727783.png" alt="image-20241105004727783"></p><h4 id="jsx特点："><a href="#jsx特点：" class="headerlink" title="jsx特点："></a>jsx特点：</h4><p>​<strong>1.可以和js文件混用。</strong><br>​<strong>2.写法和js非常接近。</strong></p><p><strong>编写jsx文件的本质：</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105005041098.png" alt="image-20241105005041098"></p><p>react还可以<strong>用一个变量来存储一个组件函数</strong>，不过在导出时需要用一个 <strong>{}</strong> 来包裹。（其渲染方式非常灵活）</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105005720121.png" alt="image-20241105005720121"></p><p>jsx里面渲染不同内容的区别（不能渲染普通对象，可以渲染react.element对象）<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105005807720.png" alt="image-20241105005807720"></p><p>例如：渲染对象时，会报错<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105010132652.png" alt="image-20241105010132652"></p><p>其他都可以渲染成功<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105010419681.png" alt="image-20241105010419681"></p><h2 id="react的事件绑定"><a href="#react的事件绑定" class="headerlink" title="react的事件绑定"></a>react的事件绑定</h2><p><strong>规则模式</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105090803061.png" alt="image-20241105090803061"></p><p><strong>先讲class（老写法），再讲函数式新写法</strong></p><p><strong>class写法</strong>（把App用class写）<img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105091512082.png" alt="image-20241105091512082"></p><p>或是下面这样（注意：此处的<strong>onClick中调用的fn函数不要带括号</strong>，带括号的话表示这个方法绑定的是一个返回值而不是函数这个方法，而且这里<strong>要用this指向</strong>）<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105091700870.png" alt="image-20241105091700870"></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105091844023.png" alt="image-20241105091844023"></p><p><strong>处理this指向方案</strong></p><p>​1.给方法调用bind</p><p>​2.写成一个匿名函数</p><p>​3.方法本身写成一个箭头函数</p><p><strong>事件绑定其他操作</strong></p><p>​1.传递参数</p><p>​2.获取事件对象</p><p>​3.阻止默认行为，冒泡等</p><p><strong>1.传递参数（通过bind方法进行传递）</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105112339435.png" alt="image-20241105112339435"></p><p><strong>2.事件对象（不是原生事件对象，而是一个合成的事件对象）</strong></p><p>相当于用bind进行传参的时候，函数定义那里多一个形参，那么最后一个形参就是事件对象</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105112449472.png" alt="image-20241105112449472"></p><h2 id="react组件的响应式数据"><a href="#react组件的响应式数据" class="headerlink" title="react组件的响应式数据"></a>react组件的响应式数据</h2><p>响应式数据定义在<strong>类的state属性</strong>中</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105112756890.png" alt="image-20241105112756890"></p><p><strong>es7写法</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105113250399.png" alt="image-20241105113250399"></p><p><strong>react与vue一些不同点</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105113456291.png" alt="image-20241105113456291"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105113500617.png" alt="image-20241105113500617"></p><p>视图不会更改，而是需要<strong>使用this.setState方法来触发更新</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105113557470.png" alt="image-20241105113557470"></p><p><strong>this.setState方法的工作流程</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105113919617.png" alt="image-20241105113919617"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105113917696.png" alt="image-20241105113917696"></p><p>this.setState方法修改参数时异步的<img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105114329943.png" alt="image-20241105114329943"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105114528634.png" alt="image-20241105114528634"></p><p><strong>多个</strong>this.setState是使用<strong>一次更新</strong>的，而且重复<strong>修改为相同的值是会触发渲染</strong>的（<strong>这是一个典型问题</strong>）。<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105114620945.png" alt="image-20241105114620945"></p><p>解决上面的问题方法：使用<strong>React.PureComponent</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105114759316.png" alt="image-20241105114759316"></p><p><strong>不要</strong>在render函数里面直接调用this.setState,这样会触发死循环。</p><p> 注意PureComponent下对于对象和数组的修改</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105120324808.png" alt="image-20241105120324808"></p><h2 id="条件渲染和列表渲染（类似v-if-v-for）"><a href="#条件渲染和列表渲染（类似v-if-v-for）" class="headerlink" title="条件渲染和列表渲染（类似v-if&#x2F;v-for）"></a>条件渲染和列表渲染（类似v-if&#x2F;v-for）</h2><p><strong>条件渲染的本质：</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105134222862.png" alt="image-20241105134222862"></p><p> <strong>列表循环的本质：</strong><br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105134734256.png" alt="image-20241105134734256"></p><p>条件渲染和列表渲染示例：<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105135340849.png" alt="image-20241105135340849"></p><p>Vue和React开发区别：<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105135708775.png" alt="image-20241105135708775"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105135713455.png" alt="image-20241105135713455"></p><p><strong>React会更灵活，Vue更方便</strong></p><h2 id="React表单绑定"><a href="#React表单绑定" class="headerlink" title="React表单绑定"></a>React表单绑定</h2><p>基本思路：<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105135853126.png" alt="image-20241105135853126"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105140340958.png" alt="image-20241105140340958"></p><h2 id="Props和组件间的传值，插槽"><a href="#Props和组件间的传值，插槽" class="headerlink" title="Props和组件间的传值，插槽"></a>Props和组件间的传值，插槽</h2><p><strong>props：react中的核心</strong>（很多react组件的根本）</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105151958231.png" alt="image-20241105151958231"></p><p><strong>Props的类型验证和默认值</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105153245861.png" alt="image-20241105153245861"></p><p>和Vue不同，react的类型验证需要自己定义</p><p><strong>模拟Vue组件的插槽方法</strong><br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105154339690.png" alt="image-20241105154339690"></p><p><strong>子往父传值：</strong>也是用<strong>props</strong>来搞定的，通过父组件使用props传递的一个方法<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105160348386.png" alt="image-20241105160348386"></p><p><strong>兄弟组件传值：</strong><br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105161743147.png" alt="image-20241105161743147"></p><h2 id="React里的样式设置"><a href="#React里的样式设置" class="headerlink" title="React里的样式设置"></a>React里的样式设置</h2><p><strong>class和style</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105161906220.png" alt="image-20241105161906220"></p><p><strong>但是目前写法是有问题的</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105210744599.png" alt="image-20241105210744599"></p><p>使用组件名.module.css这种格式，可以防止组件全局生效。</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105223019156.png" alt="image-20241105223019156"></p><p>用的时候只需要导入，然后再在<strong>className中加入需要的样式类名</strong>即可：<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105223102470.png" alt="image-20241105223102470"></p><p><strong>一些问题的解决：</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105223142806.png" alt="image-20241105223142806"></p><p>可以使用一些库来操作css文件：</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105224335708.png" alt="image-20241105224335708"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105224445016.png" alt="image-20241105224445016"></p><p>如果要配合使用classnames模块化，这样操作会有所更改<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105224647796.png" alt="image-20241105224647796"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105224738100.png" alt="image-20241105224738100"></p><h2 id="React的生命周期："><a href="#React的生命周期：" class="headerlink" title="React的生命周期："></a>React的生命周期：</h2><p>主要分为<strong>三大阶段</strong>（相对于vue少一个create）<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105224825043.png" alt="image-20241105224825043"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241105224856905.png" alt="image-20241105224856905"></p><p>例如：下面是创建阶段的生命周期（无更新的生命周期）</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106102348310.png" alt="image-20241106102348310"></p><p>为什么上面的会执行两次呢？因为在根组件渲染时执行了两次。</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106102428607.png" alt="image-20241106102428607"></p><p>如何模仿PureComponent的<strong>功能之一</strong>？（防止组件未变化而更新）。</p><p>可以在组件更新的生命周期那步来执行：检查数据是否一致。</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106103034801.png" alt="image-20241106103034801"></p><p><strong>生命周期详解：</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106103647694.png" alt="image-20241106103647694"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106103741665.png" alt="image-20241106103741665"></p><p><strong>render函数一般别写操作，因为这样会调用组件更新，会造成死循环</strong></p><p>Vue和React的<strong>更新问题</strong>的对比：</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106103814127.png" alt="image-20241106103814127"></p><h2 id="ref和context"><a href="#ref和context" class="headerlink" title="ref和context"></a>ref和context</h2><h4 id="1-ref"><a href="#1-ref" class="headerlink" title="1 ref"></a>1 ref</h4><p>如何获取组件的<strong>真实DOM</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106111033824.png" alt="image-20241106111033824"></p><h4 id="2-context"><a href="#2-context" class="headerlink" title="2 context"></a>2 context</h4><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106133139352.png" alt="image-20241106133139352"></p><h2 id="函数组件和hook（函数组件相当于Vue3版本）"><a href="#函数组件和hook（函数组件相当于Vue3版本）" class="headerlink" title="函数组件和hook（函数组件相当于Vue3版本）"></a>函数组件和hook（函数组件相当于Vue3版本）</h2><p>函数组件与类组件的<strong>不同点</strong>：<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106135046623.png" alt="image-20241106135046623"></p><h3 id="state的创建和更新"><a href="#state的创建和更新" class="headerlink" title="state的创建和更新"></a>state的创建和更新</h3><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106140132734.png" alt="image-20241106140132734"></p><p><strong>响应式数据-—-修改数据的方法</strong><br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106140521195.png" alt="image-20241106140521195"></p><p>其props也不需要使用this来指向了：<br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106140825148.png" alt="image-20241106140825148"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106140827432.png" alt="image-20241106140827432"></p><h4 id="useEffect（用来-模拟生命周期-做数据监听-作用）"><a href="#useEffect（用来-模拟生命周期-做数据监听-作用）" class="headerlink" title="useEffect（用来 模拟生命周期&#x2F;做数据监听 作用）"></a>useEffect（用来 模拟生命周期&#x2F;做数据监听 作用）</h4><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106140904488.png" alt="image-20241106140904488"></p><p>情况一：在组件挂载和更新时使用</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106141347971.png" alt="image-20241106141347971"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106141159568.png" alt="image-20241106141159568"></p><p>情况二：只在组件挂载时使用</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106141323411.png" alt="image-20241106141323411"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106141242788.png" alt="image-20241106141242788"></p><p>情况三：起到监听作用，但是和vue有区别，在组件<strong>挂载时也使用（vue不同，vue的watch只在更新时使用）</strong></p><h4 id="useMemo（类似于vue中的computed）"><a href="#useMemo（类似于vue中的computed）" class="headerlink" title="useMemo（类似于vue中的computed）"></a>useMemo（类似于vue中的computed）</h4><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106141632439.png" alt="image-20241106141632439"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106142123321.png" alt="image-20241106142123321"></p><p><strong>useMemo参数规律：和useEffect是一致的</strong></p><h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h4><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106145223074.png" alt="image-20241106145223074"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106145426082.png" alt="image-20241106145426082"></p><p>其他一些hook函数</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106145440165.png" alt="image-20241106145440165"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106152717524.png" alt="image-20241106152717524"></p><h2 id="高级组件（相当于复用组件）"><a href="#高级组件（相当于复用组件）" class="headerlink" title="高级组件（相当于复用组件）"></a>高级组件（相当于复用组件）</h2><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106152757332.png" alt="image-20241106152757332"></p><h4 id="使用例子-1（组件复用）"><a href="#使用例子-1（组件复用）" class="headerlink" title="使用例子 1（组件复用）"></a>使用例子 1（组件复用）</h4><p><strong>App.js</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106155109733.png" alt="image-20241106155109733"></p><p><strong>testHoc.js</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106155143915.png" alt="image-20241106155143915"></p><p><strong>Son.js</strong></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106155207818.png" alt="image-20241106155207818"></p><h4 id="使用例子-2"><a href="#使用例子-2" class="headerlink" title="使用例子 2"></a>使用例子 2</h4><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106155803607.png" alt="image-20241106155803607"></p><h4 id="什么时候使用高阶组件？"><a href="#什么时候使用高阶组件？" class="headerlink" title="什么时候使用高阶组件？"></a>什么时候使用高阶组件？</h4><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106160644518.png" alt="image-20241106160644518"></p><h2 id="React的性能问题和优化"><a href="#React的性能问题和优化" class="headerlink" title="React的性能问题和优化"></a>React的性能问题和优化</h2><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106160746406.png" alt="image-20241106160746406"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106160930307.png" alt="image-20241106160930307"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106161158460.png" alt="image-20241106161158460"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106161622443.png" alt="image-20241106161622443"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106161714410.png" alt="image-20241106161714410"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106161927562.png" alt="image-20241106161927562"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106161941585.png" alt="image-20241106161941585"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106162024250.png" alt="image-20241106162024250"></p><h2 id="Route路由"><a href="#Route路由" class="headerlink" title="Route路由"></a>Route路由</h2><p>注意，react v5和v6是有很大区别的</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106163307408.png" alt="image-20241106163307408"></p><h4 id="一般前端按照React-router-dom使用"><a href="#一般前端按照React-router-dom使用" class="headerlink" title="一般前端按照React-router-dom使用"></a>一般前端按照React-router-dom使用</h4><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106163347778.png" alt="image-20241106163347778"></p><p>步骤：首先先下载路由插件：npm install react-router-dom</p><p>1:  在根组件中导入和包裹App组件<img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106163534398.png" alt="image-20241106163534398"></p><p>2：3：这两步骤是一起的：（注意：v4是只有component的，v5还有element）</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106164158191.png" alt="image-20241106164158191"></p><p>4：跳转链接（类似于vue中的 route-link ）</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106164349693.png" alt="image-20241106164349693"></p><p><strong>或者使用Link：</strong><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106164451750.png" alt="image-20241106164451750"></p><p><strong>其他重要组件：</strong><br><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106164517993.png" alt="image-20241106164517993"></p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106164534249.png" alt="image-20241106164534249"></p><h4 id="嵌套路由和动态路由"><a href="#嵌套路由和动态路由" class="headerlink" title="嵌套路由和动态路由"></a>嵌套路由和动态路由</h4><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106164623830.png" alt="image-20241106164623830"></p><h4 id="如何获取路由参数？"><a href="#如何获取路由参数？" class="headerlink" title="如何获取路由参数？"></a>如何获取路由参数？</h4><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241106164850542.png" alt="image-20241106164850542"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mock.js</title>
    <link href="/2024/10/31/mockjs/"/>
    <url>/2024/10/31/mockjs/</url>
    
    <content type="html"><![CDATA[<h1 id="Mock-js"><a href="#Mock-js" class="headerlink" title="Mock.js"></a>Mock.js</h1><p>来自 CSDN：<a href="https://blog.csdn.net/Mme061300/article/details/130343270">Mock.js 超全 超详细总结 保姆级别的教程_mockjs-CSDN 博客</a></p><h3 id="一、Mock-js-介绍"><a href="#一、Mock-js-介绍" class="headerlink" title="一、Mock.js 介绍"></a>一、Mock.js 介绍</h3><p>(1). 什么是 Mock.js？</p><p>mock.js:是一款模拟数据生成器，可以生成随机数据，拦截 Ajax 请求</p><p>(2). Mock.js 的特性</p><ol><li>使用 mockjs 模拟后端接口，可随机生成所需数据，模拟对数据的增删改查</li><li>数据类型丰富，支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等。</li><li>拦截 Ajax 请求不需要修改既有代码就可以拦截，返回模拟的响应数据。</li></ol><h3 id="二、Mock-js-的使用"><a href="#二、Mock-js-的使用" class="headerlink" title="二、Mock.js 的使用"></a>二、Mock.js 的使用</h3><p><strong>(1). 安装</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> mockjs<br></code></pre></td></tr></table></figure><p><strong>(2). 在项目中使用 Mock.js</strong></p><ol><li>在 src 目录下创建 mock 目录，定义 mock 主文件 index.js，并在该文件中存放我们的 mock 数据</li></ol><p><img src="https://i-blog.csdnimg.cn/blog_migrate/56c47ae06c69a3be84560368f03cb8e9.png" alt="img"></p><ol start="2"><li>在 main.js 引入 mock 文件，方便在其他文件中使用</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import <span class="hljs-string">&quot;@/mockjs/index&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>开始使用</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Mock.mock( url, <span class="hljs-keyword">type</span>, <span class="hljs-keyword">template</span>)<br>第一个参数 url 为请求路径，<br>第二个参数 <span class="hljs-keyword">type</span> 为请求类型 如：<span class="hljs-keyword">get</span>、popst、<span class="hljs-keyword">delete</span>、put 等<br>第三个参数是生成的数据，作为响应数据返回。可以为对象，也可以为函数，函数需要<span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>！！！下方是<strong>Mock.js 的 index 文件</strong> ！！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引用 Mock</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Mock</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mockjs&#x27;</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> userData = <span class="hljs-title class_">Mock</span>.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&quot;/data/list&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, &#123;<br>  <span class="hljs-comment">// 属性 list 的值是一个数组，随机生成 1 到 10 个元素</span><br>  <span class="hljs-string">&quot;list|1-10&quot;</span>: [<br>    &#123;<br>      <span class="hljs-comment">// 随机生成1-10个★</span><br>      <span class="hljs-string">&quot;string|1-10&quot;</span>: <span class="hljs-string">&quot;★&quot;</span>,<br>      <span class="hljs-comment">// 随机生成1-100之间的任意整数</span><br>      <span class="hljs-string">&quot;number|1-100&quot;</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-comment">// 生成一个浮点数，整数部分大于等于 1、小于等于 100，小数部分保留 1 到 10 位。</span><br>      <span class="hljs-string">&quot;floatNumber|1-100.1-10&quot;</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-comment">// 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率同样是 1/2。</span><br>      <span class="hljs-string">&quot;boolean|1&quot;</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-comment">// 随机生成一个布尔值，值为 false 的概率是 2 / (2 + 5)，值为 true 的概率是 5 / (2 + 5)。</span><br>      <span class="hljs-string">&#x27;bool|2-5&#x27;</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-comment">// 从属性值 object 中随机选取 2-4 个属性</span><br>      <span class="hljs-string">&quot;object|2-4&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;310000&quot;</span>: <span class="hljs-string">&quot;上海市&quot;</span>,<br>        <span class="hljs-string">&quot;320000&quot;</span>: <span class="hljs-string">&quot;江苏省&quot;</span>,<br>        <span class="hljs-string">&quot;330000&quot;</span>: <span class="hljs-string">&quot;浙江省&quot;</span>,<br>        <span class="hljs-string">&quot;340000&quot;</span>: <span class="hljs-string">&quot;安徽省&quot;</span><br>      &#125;,<br>      <span class="hljs-comment">// 通过重复属性值 array 生成一个新数组，重复次数为 2</span><br>      <span class="hljs-string">&quot;array|2&quot;</span>: [<br>        <span class="hljs-string">&quot;AMD&quot;</span>,<br>        <span class="hljs-string">&quot;CMD&quot;</span>,<br>        <span class="hljs-string">&quot;UMD&quot;</span><br>      ],<br>      <span class="hljs-comment">// 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 &#x27;name&#x27; 所在的对象。</span><br>      <span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;哇哈哈哈哈&#x27;</span>,<br>      <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span><br>      &#125;,<br>      <span class="hljs-comment">// 根据正则表达式 regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。</span><br>      <span class="hljs-string">&#x27;regexp&#x27;</span>: <span class="hljs-regexp">/\d&#123;5,10&#125;/</span>,<br>    &#125;,<br>  ],<br>  <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;ok&#x27;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>！！！下方是需要<strong>使用<a href="https://so.csdn.net/so/search?q=mockjs&spm=1001.2101.3001.7020">mockjs</a>数据的文件</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 首先需要引入axios 如果没安装的话 在终端输入npm i axios 安装一下</span><br><span class="hljs-keyword">import</span> axios from <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-keyword">export</span> default &#123;<br><span class="hljs-attr">methods</span>: &#123;<br>getData() &#123;<br>          axios.get(<span class="hljs-string">&quot;/data/list&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);<br>          &#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(error);<br>          &#125;)<br>&#125;,<br>&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>！！！打印出来的效果 ！！！</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/52af2a96bef1f38ea5d493288d1afac8.png" alt="img"></p><p><strong>(3). Mock.Random 的使用</strong></p><ol><li>Mock.Random 是一个工具类，用于生成各种随机数据。</li><li>Mock.Random 的方法在数据模板中称为『占位符』，书写格式为 @占位符(参数) 。</li></ol><p>！！！ 下方是使用<strong>random 生成数据的方法</strong> ！！！</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs awk">const Mock = require(<span class="hljs-string">&quot;mockjs&quot;</span>)<br>const Random = Mock.Random<br><br>export const userData = Mock.mock(<span class="hljs-string">&quot;/data/list&quot;</span>, <span class="hljs-string">&quot;post&quot;</span>, &#123;<br>  <span class="hljs-regexp">//</span> 属性 list 的值是一个数组，随机生成 <span class="hljs-number">1</span> 到 <span class="hljs-number">10</span> 个元素<br>  <span class="hljs-string">&quot;list|1-10&quot;</span>: [<br>    &#123;<br>      <span class="hljs-regexp">//</span> 生成随机字符串 长度为 <span class="hljs-number">5</span><br>      <span class="hljs-string">&quot;string&quot;</span>: Random.string(<span class="hljs-number">5</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;jPXEu&quot;</span><br>      <span class="hljs-string">&quot;string2&quot;</span>: <span class="hljs-string">&#x27;@string(5)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;jPXEu&quot;</span><br>      <span class="hljs-regexp">//</span> 生成随机邮箱地址 可以指定域名，例如 <span class="hljs-number">163</span>.com<br>      <span class="hljs-string">&quot;email&quot;</span>: Random.email(<span class="hljs-string">&#x27;163.com&#x27;</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;l.fvilfpz@163.com&quot;</span><br>      <span class="hljs-string">&quot;email2&quot;</span>: <span class="hljs-string">&#x27;@email()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;l.fvilfpz@163.com&quot;</span><br>      <span class="hljs-regexp">//</span> 返回一个随机的布尔值。<br>      <span class="hljs-string">&quot;boolean&quot;</span>: Random.boolean(), <span class="hljs-regexp">//</span> true<br>      <span class="hljs-string">&quot;boolean2&quot;</span>: <span class="hljs-string">&#x27;@boolean()&#x27;</span>, <span class="hljs-regexp">//</span> true<br>      <span class="hljs-regexp">//</span> 生成 <span class="hljs-number">60</span>-<span class="hljs-number">100</span> 随机整数<br>      <span class="hljs-string">&quot;point&quot;</span>: Random.integer(<span class="hljs-number">60</span>, <span class="hljs-number">100</span>), <span class="hljs-regexp">//</span> <span class="hljs-number">69</span><br>      <span class="hljs-string">&quot;point2&quot;</span>: <span class="hljs-string">&#x27;@integer(60, 100)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-number">98</span><br>      <span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span> 生成一个浮点数，整数部分大于等于 <span class="hljs-number">1</span>、小于等于 <span class="hljs-number">100</span>，小数部分保留 <span class="hljs-number">3</span> 到 <span class="hljs-number">5</span> 位。<br>      <span class="hljs-string">&quot;floatNumber&quot;</span>: Random.float(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>), <span class="hljs-regexp">//</span> <span class="hljs-number">60.695</span><br>      <span class="hljs-string">&quot;floatNumber2&quot;</span>: <span class="hljs-string">&#x27;@float(1, 100, 3, 5)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-number">19.29368</span><br>      <span class="hljs-regexp">//</span> 随机日期<br>      <span class="hljs-string">&quot;date&quot;</span>: Random.datetime(<span class="hljs-string">&#x27;yyyy-MM-dd&#x27;</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;2017-05-01&quot;</span><br>      <span class="hljs-string">&quot;date2&quot;</span>: <span class="hljs-string">&quot;@datetime()&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;1973-06-12 13:05:18&quot;</span><br>      <span class="hljs-regexp">//</span> 随机时间<br>      <span class="hljs-string">&quot;time&quot;</span>: Random.time(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;21:33:01&quot;</span><br>      <span class="hljs-string">&quot;time2&quot;</span>: <span class="hljs-string">&quot;@time()&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;21:33:01&quot;</span><br>      <span class="hljs-regexp">//</span> 当前日期<br>      <span class="hljs-string">&quot;now&quot;</span>: Random.now(<span class="hljs-string">&#x27;year&#x27;</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;2023-01-01 00:00:00&quot;</span><br>      <span class="hljs-string">&quot;now2&quot;</span>: <span class="hljs-string">&quot;@now(&#x27;year&#x27;)&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;2023-01-01 00:00:00&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成图片 Random.image( size, background, foreground, format, text )<br>      <span class="hljs-string">&quot;img&quot;</span>: Random.image(<span class="hljs-string">&#x27;200x100&#x27;</span>, <span class="hljs-string">&#x27;#16d46b&#x27;</span>, <span class="hljs-string">&#x27;#fff&#x27;</span>, <span class="hljs-string">&#x27;png&#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;http://dummyimage.com/200x100/16d46b/fff.png&amp;text=Hello&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成颜色,格式为 <span class="hljs-string">&#x27;#RRGGBB&#x27;</span>。<br>      <span class="hljs-string">&quot;color&quot;</span>: Random.color(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;#94f279&quot;</span><br>      <span class="hljs-string">&quot;color2&quot;</span>: <span class="hljs-string">&#x27;@color()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;#94f279&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成颜色,格式为 <span class="hljs-string">&#x27;rgb(r, g, b, a)&#x27;</span>。<br>      <span class="hljs-string">&quot;rgbaColor&quot;</span>: Random.rgba(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;rgba(242, 121, 183, 0.22)&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一段文本 文本中句子的个数为 <span class="hljs-number">2</span> 到 <span class="hljs-number">5</span>。默认值为 <span class="hljs-number">3</span> 到 <span class="hljs-number">7</span><br>      <span class="hljs-string">&quot;paragraph&quot;</span>: Random.paragraph(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Ymkp nvyryy vieq hlqdb pplbbikbd mtqiq uue jdufhkxy wpybjqi djico jxqkwvw kbmsscpfw owtgsqwn.&quot;</span><br>      <span class="hljs-string">&quot;paragraph2&quot;</span>: <span class="hljs-string">&#x27;@paragraph(2, 5)&#x27;</span>,  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Ymkp nvyryy vieq hlqdb pplbbikbd mtqiq uue jdufhkxy wpybjqi djico jxqkwvw kbmsscpfw owtgsqwn.&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一段中文文本 参数同 Random.paragraph( min?, max? )<br>      <span class="hljs-string">&quot;cparagraph&quot;</span>: Random.cparagraph(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;重工边政应信江半实金改北反调程五八。张资圆向规成新家天交对传许。军较军七养多认维市般况验式华行证。&quot;</span><br>      <span class="hljs-string">&quot;cparagraph2&quot;</span>: <span class="hljs-string">&#x27;@cparagraph(2, 5)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;重工边政应信江半实金改北反调程五八。张资圆向规成新家天交对传许。军较军七养多认维市般况验式华行证。&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个句子，第一个单词的首字母大写。 句子中单词的个数为 <span class="hljs-number">2</span> 到 <span class="hljs-number">5</span> 。默认值为 <span class="hljs-number">12</span> 到 <span class="hljs-number">18</span><br>      <span class="hljs-string">&quot;sentence&quot;</span>: Random.sentence(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Yyfvs genrdeiyf.&quot;</span><br>      <span class="hljs-string">&quot;sentence2&quot;</span>: <span class="hljs-string">&#x27;@sentence(2, 5)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Yyfvs genrdeiyf.&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一段中文文本，参数同 Random.sentence( min?, max? )<br>      <span class="hljs-string">&quot;csentence&quot;</span>: Random.csentence(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;积现。&quot;</span><br>      <span class="hljs-string">&quot;csentence2&quot;</span>: <span class="hljs-string">&#x27;@csentence(2, 5)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;积现。&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个单词，单词中字符的个数为 <span class="hljs-number">2</span> 到 <span class="hljs-number">5</span> 个。默认值为 <span class="hljs-number">3</span> 到 <span class="hljs-number">10</span><br>      <span class="hljs-string">&quot;word&quot;</span>: Random.word(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;nlgcl&quot;</span><br>      <span class="hljs-string">&quot;word2&quot;</span>: <span class="hljs-string">&#x27;@word(2, 5)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;nlgcl&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个汉字，汉字中字符串的长度为 <span class="hljs-number">2</span> 到 <span class="hljs-number">5</span> 个。默认值为 <span class="hljs-number">1</span><br>      <span class="hljs-string">&quot;cword&quot;</span>: Random.cword(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;系即感&quot;</span><br>      <span class="hljs-string">&quot;cword2&quot;</span>: <span class="hljs-string">&#x27;@cword(2, 5)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;系即感&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一句标题，其中每个单词的首字母大写。单词中字符的个数为 <span class="hljs-number">2</span> 到 <span class="hljs-number">5</span>。默认值为 <span class="hljs-number">3</span> 到 <span class="hljs-number">7</span><br>      <span class="hljs-string">&quot;title&quot;</span>: Random.title(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Vmpx Rizds Smguoqki&quot;</span><br>      <span class="hljs-string">&quot;title2&quot;</span>: <span class="hljs-string">&#x27;@title(2, 5)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Vmpx Rizds Smguoqki&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一句中文标题，参数同 Random.title( min?, max? )<br>      <span class="hljs-string">&quot;ctitle&quot;</span>: Random.ctitle(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;其感期&quot;</span><br>      <span class="hljs-string">&quot;ctitle2&quot;</span>: <span class="hljs-string">&#x27;@ctitle(2, 5)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;其感期&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个常见的英文名<br>      <span class="hljs-string">&quot;firstName&quot;</span>: Random.first(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Michelle&quot;</span><br>      <span class="hljs-string">&quot;firstName2&quot;</span>: <span class="hljs-string">&#x27;@first()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Jose&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个常见的英文姓。<br>      <span class="hljs-string">&quot;lastName&quot;</span>: Random.last(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Taylor&quot;</span><br>      <span class="hljs-string">&quot;lastName2&quot;</span>: <span class="hljs-string">&#x27;@last()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Clark&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个常见的英文姓名。括号里的布尔值，指示是否生成中间名（可选）。<br>      <span class="hljs-string">&quot;name&quot;</span>: Random.name(true), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Donald Eric Jackson&quot;</span><br>      <span class="hljs-string">&quot;name2&quot;</span>: <span class="hljs-string">&#x27;@name(true)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Donald Eric Jackson&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个常见的中文姓<br>      <span class="hljs-string">&quot;cfirstName&quot;</span>: Random.cfirst(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;任&quot;</span><br>      <span class="hljs-string">&quot;cfirstName2&quot;</span>: <span class="hljs-string">&#x27;@cfirst()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;郭&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个常见的中文名。<br>      <span class="hljs-string">&quot;clastName&quot;</span>: Random.clast(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;芳&quot;</span><br>      <span class="hljs-string">&quot;clastName2&quot;</span>: <span class="hljs-string">&#x27;@clast()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;芳&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个常见的中文姓名。<br>      <span class="hljs-string">&quot;cname&quot;</span>: Random.cname(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;程强&quot;</span><br>      <span class="hljs-string">&quot;cname2&quot;</span>: <span class="hljs-string">&#x27;@cname()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;程强&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个URL。可以指定url协议，域名和端口号。例如<span class="hljs-string">&#x27;http&#x27;</span> nuysoft.com。<br>      <span class="hljs-string">&#x27;url&#x27;</span>: Random.url(<span class="hljs-string">&#x27;http&#x27;</span>, <span class="hljs-string">&#x27;nuysoft.com&#x27;</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;http://nuysoft.com/ysq&quot;</span><br>      <span class="hljs-string">&#x27;url2&#x27;</span>: <span class="hljs-string">&#x27;@url()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;http://nuysoft.com/ysq&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个 IP 地址<br>      <span class="hljs-string">&#x27;IP&#x27;</span>: Random.ip(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;112.127.151.37&quot;</span><br>      <span class="hljs-string">&#x27;IP2&#x27;</span>: <span class="hljs-string">&#x27;@ip()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;233.144.17.219&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个（中国）大区。<br>      <span class="hljs-string">&quot;region&quot;</span>: Random.region(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;华北&quot;</span><br>      <span class="hljs-string">&quot;region2&quot;</span>: <span class="hljs-string">&#x27;@region()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;华北&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个（中国）省（或直辖市、自治区、特别行政区）。<br>      <span class="hljs-string">&quot;province&quot;</span>: Random.province(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;澳门特别行政区&quot;</span><br>      <span class="hljs-string">&quot;province2&quot;</span>: <span class="hljs-string">&#x27;@province()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;澳门特别行政区&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个（中国）市。括号里的布尔值，指是否生成所属的省（可选）<br>      <span class="hljs-string">&quot;city&quot;</span>: Random.city(true), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;广东省 肇庆市&quot;</span><br>      <span class="hljs-string">&quot;city2&quot;</span>: <span class="hljs-string">&#x27;@city()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;广东省 肇庆市&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个（中国）县。括号里的布尔值，指是否生成所属的省、市（可选）<br>      <span class="hljs-string">&quot;county&quot;</span>: Random.county(true), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;江苏省 常州市 其它区&quot;</span><br>      <span class="hljs-string">&quot;county2&quot;</span>: <span class="hljs-string">&#x27;@county()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;江苏省 常州市 其它区&quot;</span><br>      <span class="hljs-regexp">//</span> 随机生成一个邮政编码（六位数字）。<br>      <span class="hljs-string">&quot;zip&quot;</span>: Random.zip(), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;806124&quot;</span><br>      <span class="hljs-string">&quot;zip2&quot;</span>: <span class="hljs-string">&#x27;@zip()&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;806124&quot;</span><br>      <span class="hljs-regexp">//</span> 把字符串的第一个字母转换为大写。<br>      <span class="hljs-string">&quot;capitalize&quot;</span>: Random.capitalize(<span class="hljs-string">&#x27;hello&#x27;</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Hello&quot;</span><br>      <span class="hljs-string">&quot;capitalize2&quot;</span>: <span class="hljs-string">&#x27;@capitalize(&quot;hello&quot;)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Hello&quot;</span><br>      <span class="hljs-regexp">//</span> 把字符串转换为大写。<br>      <span class="hljs-string">&quot;upper&quot;</span>: Random.upper(<span class="hljs-string">&#x27;hello&#x27;</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;HELLO&quot;</span><br>      <span class="hljs-string">&quot;upper2&quot;</span>: <span class="hljs-string">&#x27;@upper(&quot;hello&quot;)&#x27;</span>,  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;HELLO&quot;</span><br>      <span class="hljs-regexp">//</span> 把字符串转换为小写。<br>      <span class="hljs-string">&quot;lower&quot;</span>: Random.lower(<span class="hljs-string">&#x27;HELLO&#x27;</span>), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;hello&quot;</span><br>      <span class="hljs-string">&quot;lower2&quot;</span>: <span class="hljs-string">&#x27;@lower(&quot;HELLO&quot;)&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;hello&quot;</span><br>      <span class="hljs-regexp">//</span> 从数组中随机选取一个元素并返回。<br>      <span class="hljs-string">&quot;pick&quot;</span>: Random.pick([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]), <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;e&quot;</span><br>      <span class="hljs-string">&quot;pick2&quot;</span>: <span class="hljs-string">&#x27;@pick([&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;])&#x27;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;e&quot;</span><br>      <span class="hljs-regexp">//</span> 打乱数组中元素的顺序，并返回。<br>      <span class="hljs-string">&quot;shuffle&quot;</span>: Random.shuffle([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]), <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br>      <span class="hljs-string">&quot;shuffle2&quot;</span>: <span class="hljs-string">&#x27;@shuffle([&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;])&#x27;</span>, <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br>      <span class="hljs-regexp">//</span> 随机生成一个 <span class="hljs-number">18</span> 位身份证。<br>      <span class="hljs-string">&quot;id&quot;</span>: Random.id(), <span class="hljs-regexp">//</span> <span class="hljs-number">112.127</span>.<span class="hljs-number">151.37</span><br>      <span class="hljs-string">&quot;id2&quot;</span>: <span class="hljs-string">&#x27;@id()&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-number">97.46</span>.<span class="hljs-number">129.222</span><br>    &#125;,<br>  ],<br>  code: <span class="hljs-number">200</span>,<br>  message: <span class="hljs-string">&#x27;ok&#x27;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>来自CSDN -- Mock.js 超全 超详细总结 保姆级别的教程_mockjs-CSDN博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS</title>
    <link href="/2024/10/30/js/"/>
    <url>/2024/10/30/js/</url>
    
    <content type="html"><![CDATA[<h1 id="js中的对象、类与面向对象编程"><a href="#js中的对象、类与面向对象编程" class="headerlink" title="js中的对象、类与面向对象编程"></a>js中的对象、类与面向对象编程</h1><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对象在代码执行过程中的任何时候都可以被创建和增强，具有极大的动态性，并不是严格定义的实体。下面的模式适用于创建对象。<br> 工厂模式就是一个简单的函数，这个函数可以创建对象，为它添加属性和方法，然后返回这个对象。这个模式在构造函数模式出现后就很少用了。<br> 使用构造函数模式可以自定义引用类型，可以使用new 关键字像创建内置类型实例一样创建自定义类型的实例。不过，构造函数模式也有不足，主要是其成员无法重用，包括函数。考虑到函数本身是松散的、弱类型的，没有理由让函数不能在多个对象实例间共享。<br> 原型模式解决了成员共享的问题，只要是添加到构造函数prototype 上的属性和方法就可以共享。而组合构造函数和原型模式通过构造函数定义实例属性，通过原型定义共享的属性和方法。<br>JavaScript 的继承主要通过原型链来实现。原型链涉及把构造函数的原型赋值为另一个类型的实例。<br>这样一来，子类就可以访问父类的所有属性和方法，就像基于类的继承那样。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。盗用构造函数模式通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）。目前最流行的继承模式是组合继承，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。<br>除上述模式之外，还有以下几种继承模式。<br> 原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。这种操作的结果之后还可以再进一步增强。<br> 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。这个模式也被用在组合继承中，用于避免重复调用父类构造函数导致的浪费。<br> 寄生组合继承被认为是实现基于类型继承的最有效方式。<br>ECMAScript 6 新增的类很大程度上是基于既有原型机制的语法糖。类的语法让开发者可以优雅地定义向后兼容的类，既可以继承内置类型，也可以继承自定义类型。类有效地跨越了对象实例、对象原型和对象类之间的鸿沟。</p><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>讲讲属性：</p><p>属性分两种：<strong>数据属性</strong>和<strong>访问器属性</strong>。</p><h3 id="数据属性-Object-defineProperty"><a href="#数据属性-Object-defineProperty" class="headerlink" title="数据属性(Object.defineProperty())"></a><strong>数据属性</strong>(Object.defineProperty())</h3><p>（它包含的是一个数据值的位置，在这可以对数据值进行读写）</p><p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有4<br>个特性描述它们的行为。<br> [[<strong>Configurable</strong>]]：表示属性是否可以通过delete 删除并重新定义，是否可以修改它的特<br>性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特<br>性都是true，如前面的例子所示。<br> [[<strong>Enumerable</strong>]]：表示属性是否可以通过for-in 循环返回。默认情况下，所有直接定义在对<br>象上的属性的这个特性都是true，如前面的例子所示。<br> [[<strong>Writable</strong>]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的<br>这个特性都是true，如前面的例子所示。<br> [[<strong>Value</strong>]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为undefined。</p><p>这时，我们要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3 个参数：<br>要给其<strong>添加属性的对象</strong>、<strong>属性的名称</strong>和<strong>一个描述符对象</strong>。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable 和value，跟相关特性的名称一一对应。根据要修改<br>的特性，可以设置其中一个或多个值。<strong>比如</strong>：<br>let person &#x3D; {};<br><strong>Object.defineProperty</strong>(person, “name”, {<br>    writable: false,<br>    value: “Nicholas”<br>});<br>console.log(person.name); &#x2F;&#x2F; “Nicholas”<br>person.name &#x3D; “Greg”;<br>console.log(person.name); &#x2F;&#x2F; “Nicholas”<br>这个例子创建了一个名为name 的属性并给它赋予了一个只读的值”Nicholas”。<strong>这个属性的值就不能再修改了</strong>，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。</p><h3 id="访问器属性-Object-defineProperty"><a href="#访问器属性-Object-defineProperty" class="headerlink" title="访问器属性(Object.defineProperty())"></a><strong>访问器属性</strong>(Object.defineProperty())</h3><p>（这个属性不包含数据值，包含的是一对<strong>get</strong>和<strong>set</strong>方法，在读写访问器属性时，就是通过这两个方法来进行操作处理的。）</p><p>访问器属性不包含数据值。相反，它们<strong>包含一个获取（getter）函数</strong>和<strong>一个设置（setter）函数</strong>，不过<strong>这两个函数不是必需的</strong>。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效<br>的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访<br>问器属性有4 个特性描述它们的行为。<br> [[<strong>Configurable</strong>]]：表示属性是否可以通过delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是true。<br> [[<strong>Enumerable</strong>]]：表示属性是否可以通过for-in 循环返回。默认情况下，所有直接定义在对<br>象上的属性的这个特性都是true。<br> [[<strong>Get</strong>]]：获取函数，在读取属性时调用。默认值为undefined。<br> [[<strong>Set</strong>]]：设置函数，在写入属性时调用。默认值为undefined。<br>访问器属性是不能直接定义的，必须使用Object.defineProperty()。下面是一个例子：</p><p>&#x2F;&#x2F; 定义一个对象，包含伪私有成员year和公共成员edition</p><p>let book &#x3D; {};</p><p>Object.defineProperties(book, {<br>    years: {<br>        value: 2017,<br>        writable: true &#x2F;&#x2F; 允许内部修改<br>    },<br>    edition: {<br>        value: 1,<br>        writable: true &#x2F;&#x2F; 允许内部修改<br>    },<br>    year: {<br>        get() {<br>            return this.years;<br>        },<br>        set(newValue) {<br>            if (newValue &gt; this.years) {<br>                const editionsIncrease &#x3D; newValue - this.years;<br>                this.years &#x3D; newValue;<br>                this.edition +&#x3D; editionsIncrease;<br>            }<br>        }<br>    }<br>});</p><p>console.log(book); &#x2F;&#x2F; 输出: { years: 2017, edition: 1 }<br>book.year &#x3D; 2018;<br>console.log(book); &#x2F;&#x2F; 输出: { years: 2018, edition: 2 }</p><p>在这个例子中，对象book 有两个默认属性：year_和edition。year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问。另一个属性year 被定义为一个访问器属性，其中获取函数简单地返回year_的值，而设置函数会做一些计算以决定正确的版本（edition）。因此，把year 属性修改为2018 会导致year_变成2018，edition 变成2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。</p><h3 id="定义多个属性-Object-defineProperties"><a href="#定义多个属性-Object-defineProperties" class="headerlink" title="定义多个属性(Object.defineProperties())"></a>定义多个属性(Object.defineProperties())</h3><p>在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript 提供了<strong>Object.defineProperties()<strong>方法。这个方法可</strong>以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象</strong>，其属性与要添加或修改的属性一一对应。比如：</p><p>let book &#x3D; {};<br>Object.defineProperties(book, {<br>    years: {<br>        value: 2017<br>    },<br>    edition: {<br>        value: 1<br>    },<br>    year: {<br>        get() {<br>            return this.years;<br>        },</p><p>​set(newValue) {<br>​if (newValue &gt; 2017) {<br>​this.years &#x3D; newValue;<br>​this.edition +&#x3D; newValue - 2017;<br>​}<br>​}<br>​}<br>});</p><p>这段代码在book 对象上定义了两个数据属性years和edition，还有一个访问器属性year。最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的<strong>configurable、enumerable 和writable 特性值都是false</strong>。</p><h3 id="读取属性的特性-Object-getOwnPropertyDescriptor"><a href="#读取属性的特性-Object-getOwnPropertyDescriptor" class="headerlink" title="读取属性的特性(Object.getOwnPropertyDescriptor())"></a>读取属性的特性(Object.getOwnPropertyDescriptor())</h3><p>使用<strong>Object.getOwnPropertyDescriptor()<strong>方法可以取得指定属性的属性描述符。这个方法接收两个参数：</strong>属性所在的对象</strong>和<strong>要取得其描述符的属性名</strong>。<strong>返回值是一个对象</strong>，对于访问器属性包含configurable、enumerable、get 和set 属性，对于数据属性包含configurable、enumerable、writable 和value 属性。比如：</p><p>let book &#x3D; {};<br>Object.defineProperties(book, {<br>    years: {<br>        value: 2017<br>    },<br>    edition: {<br>        value: 1<br>    },<br>    year: {<br>        get: function () {<br>            return this.years;<br>        },<br>        set: function (newValue) {<br>            if (newValue &gt; 2017) {<br>                this.years &#x3D; newValue;<br>                this.edition +&#x3D; newValue - 2017;<br>            }<br>        }<br>    }<br>});<br>let descriptor &#x3D; Object.getOwnPropertyDescriptor(book, “years”);<br>console.log(descriptor.value); &#x2F;&#x2F; 2017<br>console.log(descriptor.configurable); &#x2F;&#x2F; false<br>console.log(typeof descriptor.get); &#x2F;&#x2F; “undefined”</p><p>let descriptor2 &#x3D; Object.getOwnPropertyDescriptor(book, “year”);<br>console.log(descriptor2.value); &#x2F;&#x2F; undefined<br>console.log(descriptor2.enumerable); &#x2F;&#x2F; false<br>console.log(typeof descriptor2.get); &#x2F;&#x2F; “function”</p><p>对于数据属性years，value 等于原来的值，configurable 是false，get 是undefined。对于访问器属性year，value 是undefined，enumerable 是false，get 是一个指向获取函数的指针。</p><h3 id="合并对象-Object-assign"><a href="#合并对象-Object-assign" class="headerlink" title="合并对象(Object.assign())"></a>合并对象(Object.assign())</h3><p>就是把源对象所有的本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（mixin）。合并对象有**Object.assign()**方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回true）和自有（Object.hasOwnProperty()返回true）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值。</p><p>（解释一下：通过调用hasOwnProperty()能够清楚地看到访问的是实例属性还是原型属性。调用person1.hasOwnProperty(“name”)只在重写person1 上name 属性的情况下才返回true，表明此时name 是一个实例属性，不是原型属性。如下图：<img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241023150407470.png" alt="image-20241023150407470">）</p><p>let dest, src, result;<br>&#x2F;**</p><p>简单复制<br><em>&#x2F;<br>dest &#x3D; {};<br>src &#x3D; { id: ‘src’ };<br>result &#x3D; Object.assign(dest, src);<br>&#x2F;&#x2F; Object.assign 修改目标对象<br>&#x2F;&#x2F; 也会返回修改后的目标对象<br>console.log(dest &#x3D;&#x3D;&#x3D; result); &#x2F;&#x2F; true<br>console.log(dest !&#x3D;&#x3D; src); &#x2F;&#x2F; true<br>console.log(result); &#x2F;&#x2F; { id: src }<br>console.log(dest); &#x2F;&#x2F; { id: src }<br>&#x2F;</em>*</p><p>多个源对象<br><em>&#x2F;<br>dest &#x3D; {};<br>result &#x3D; Object.assign(dest, { a: ‘foo’ }, { b: ‘bar’ });<br>console.log(result); &#x2F;&#x2F; { a: foo, b: bar }<br>&#x2F;</em>*</p><p>获取函数与设置函数<br>*&#x2F;<br>dest &#x3D; {<br>  set a(val) {<br>      console.log(<code>Invoked dest setter with param $&#123;val&#125;</code>);<br>  }<br>};<br>src &#x3D; {<br>  get a() {<br>      console.log(‘Invoked src getter’);<br>      return ‘foo’;<br>  }<br>};<br>Object.assign(dest, src);<br>&#x2F;&#x2F; 调用src 的获取方法<br>&#x2F;&#x2F; 调用dest 的设置方法并传入参数”foo”<br>&#x2F;&#x2F; 因为这里的设置函数不执行赋值操作<br>&#x2F;&#x2F; 所以实际上并没有把值转移过来<br>console.log(dest); &#x2F;&#x2F; { set a(val) {…} }</p><h3 id="对象标识及相等判定-Object-is"><a href="#对象标识及相等判定-Object-is" class="headerlink" title="对象标识及相等判定(Object.is())"></a>对象标识及相等判定(Object.is())</h3><p>在ECMAScript 6 之前，有些特殊情况即使是&#x3D;&#x3D;&#x3D;操作符也无能为力：</p><p>&#x2F;&#x2F; 这些情况在不同JavaScript 引擎中表现不同，但仍被认为相等<br>console.log(+0 &#x3D;&#x3D;&#x3D; -0); &#x2F;&#x2F; true<br>console.log(+0 &#x3D;&#x3D;&#x3D; 0); &#x2F;&#x2F; true<br>console.log(-0 &#x3D;&#x3D;&#x3D; 0); &#x2F;&#x2F; true<br>&#x2F;&#x2F; 要确定NaN 的相等性，必须使用极为讨厌的isNaN()<br>console.log(NaN &#x3D;&#x3D;&#x3D; NaN); &#x2F;&#x2F; false<br>console.log(isNaN(NaN)); &#x2F;&#x2F; true</p><p>为改善这类情况，ECMAScript 6 规范新增了Object.is()，这个方法与&#x3D;&#x3D;&#x3D;很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：</p><p>&#x2F;&#x2F; 正确的0、-0、+0 相等&#x2F;不等判定<br>console.log(Object.is(+0, -0)); &#x2F;&#x2F; false<br>console.log(Object.is(+0, 0)); &#x2F;&#x2F; true<br>console.log(Object.is(-0, 0)); &#x2F;&#x2F; false<br>&#x2F;&#x2F; 正确的NaN 相等判定<br>console.log(Object.is(NaN, NaN)); &#x2F;&#x2F; true<br>要检查超过两个值，递归地利用相等性传递即可：<br>function recursivelyCheckEqual(x, …rest) {<br>    return Object.is(x, rest[0]) &amp;&amp;<br>        (rest.length &lt; 2 || recursivelyCheckEqual(…rest));<br>}</p><h3 id="解构赋值（略）"><a href="#解构赋值（略）" class="headerlink" title="解构赋值（略）"></a>解构赋值（略）</h3><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。</p><p>例：<br>function createPerson(name, age, job) {<br>    let o &#x3D; new Object();<br>    o.name &#x3D; name;<br>    o.age &#x3D; age;<br>    o.job &#x3D; job;<br>    o.sayName &#x3D; function() {<br>        console.log(this.name);<br>    };<br>    return o;<br>}<br>let person1 &#x3D; createPerson(“Nicholas”, 29, “Software Engineer”);<br>let person2 &#x3D; createPerson(“Greg”, 27, “Doctor”);</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>前面的例子使用构造函数模式可以这样写：<br>function Person(name, age, job){<br>    this.name &#x3D; name;<br>    this.age &#x3D; age;<br>    this.job &#x3D; job;<br>    this.sayName &#x3D; function() {<br>        console.log(this.name);<br>    };<br>}<br>let person1 &#x3D; <strong>new</strong> Person(“Nicholas”, 29, “Software Engineer”);<br>let person2 &#x3D; <strong>new</strong> Person(“Greg”, 27, “Doctor”);<br>person1.sayName(); &#x2F;&#x2F; Nicholas<br>person2.sayName(); &#x2F;&#x2F; Greg</p><p>要创建Person 的实例，应使用new 操作符。以这种方式调用构造函数会执行如下操作。<br>(1) 在内存中创建一个新对象。<br>(2) 这个新对象内部的[[<strong>Prototype</strong>]]特性被赋值为构造函数的<strong>prototype</strong> 属性。<br>(3) 构造函数内部的<strong>this</strong> <strong>被赋值为这个新对象</strong>（即this 指向新对象）。<br>(4) 执行构造函数内部的代码（给新对象添加属性）。<br>(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p><p>person1 和person2 分别保存着Person 的不同实例。这两个对象都有一个<br>constructor 属性指向Person，如下所示：<br>console.log(person1.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F; true<br>console.log(person2.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F; true</p><p><strong>constructor</strong> 本来是用于标识对象类型的。不过，一般认为<strong>instanceof 操作符是确定对象类型更可靠的方式。</strong>前面例子中的每个对象都是Object 的实例，同时也是Person 的实例，如下面调用instanceof 操作符的结果所示：<br>console.log(person1 instanceof Object); &#x2F;&#x2F; true<br>console.log(person1 instanceof Person); &#x2F;&#x2F; true<br>console.log(person2 instanceof Object); &#x2F;&#x2F; true<br>console.log(person2 instanceof Person); &#x2F;&#x2F; true</p><p>如果不想传参数，那么构造函数后面的括号可加可不加。只要有new 操作符，就可以调用相应的构造函数</p><p><strong>构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new 操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数</strong></p><h3 id="原型模式（Object-getPrototypeOf-，Object-setPrototypeOf，Object-create-）"><a href="#原型模式（Object-getPrototypeOf-，Object-setPrototypeOf，Object-create-）" class="headerlink" title="原型模式（Object.getPrototypeOf()，Object.setPrototypeOf，Object.create()）"></a>原型模式（Object.getPrototypeOf()，Object.setPrototypeOf，Object.create()）</h3><p>每个函数都会创建一个<strong>prototype 属性，</strong>这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型，如下所示：</p><p>function Person() {  }<br>Person.prototype.name &#x3D; “Nicholas”;<br>Person.prototype.age &#x3D; 29;<br>Person.prototype.job &#x3D; “Software Engineer”;<br>Person.prototype.sayName &#x3D; function() {<br>    console.log(this.name);<br>};<br>let person1 &#x3D; new Person();<br>person1.sayName(); &#x2F;&#x2F; “Nicholas”<br>let person2 &#x3D; new Person();<br>person2.sayName(); &#x2F;&#x2F; “Nicholas”<br>console.log(person1.sayName &#x3D;&#x3D; person2.sayName); &#x2F;&#x2F; true</p><p>ECMAScript 的Object 类型有一个方法叫Object.getPrototypeOf()，返回参数的内部特性<br>[[Prototype]]的值。例如：<br>console.log(Object.getPrototypeOf(person1) &#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true<br>console.log(Object.getPrototypeOf(person1).name); &#x2F;&#x2F; “Nicholas”<br>第一行代码简单确认了Object.getPrototypeOf()返回的对象就是传入对象的原型对象。第二行代码则取得了原型对象上name 属性的值，即”Nicholas”。使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在通过原型实现继承时显得尤为重要。</p><p>Object 类型还有一个setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系：<br>let biped &#x3D; {<br>    numLegs: 2<br>};<br>let person &#x3D; {<br>    name: ‘Matt’<br>};<br>Object.setPrototypeOf(person, biped);<br>console.log(person.name); &#x2F;&#x2F; Matt<br>console.log(person.numLegs); &#x2F;&#x2F; 2<br>console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; biped); &#x2F;&#x2F; true</p><p><strong><u>Object.setPrototypeOf()可能会严重影响代码性能</u></strong></p><p>为避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过**Object.create()**来创建一个新对象，同时为其指定原型。</p><h4 id="For-in"><a href="#For-in" class="headerlink" title="For-in"></a>For-in</h4><p>在for-in 循环中使用in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（[[Enumerable]]特性被设置为false）属性的实例属性也会在for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。<br>要获得对象上所有可枚举的实例属性，可以使用Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。比如：<br>function Person() {}<br>Person.prototype.name &#x3D; “Nicholas”;<br>Person.prototype.age &#x3D; 29;<br>Person.prototype.job &#x3D; “Software Engineer”;<br>Person.prototype.sayName &#x3D; function() {<br>    console.log(this.name);<br>};<br>let keys &#x3D; Object.keys(Person.prototype);<br>console.log(keys); &#x2F;&#x2F; “name,age,job,sayName”<br>let p1 &#x3D; new Person();<br>p1.name &#x3D; “Rob”;<br>p1.age &#x3D; 31;<br>let p1keys &#x3D; Object.keys(p1);<br>console.log(p1keys); &#x2F;&#x2F; “[name,age]”</p><p>这里，<strong>keys 变量保存的数组中包含”name”、”age”、”job”和”sayName”。</strong>这是正常情况下通过for-in 返回的顺序。而在Person 的实例上调用时，<strong>Object.keys()返回的数组中只包含”name”和”age”两个属性。</strong>如果想列出所有实例属性，无论是否可以枚举，都可以使用**Object.getOwnPropertyNames()**：</p><p>let keys &#x3D; Object.getOwnPropertyNames(Person.prototype);<br>console.log(keys); &#x2F;&#x2F; “[constructor,name,age,job,sayName]”</p><h3 id="对象迭代-Object-values-Object-entries"><a href="#对象迭代-Object-values-Object-entries" class="headerlink" title="对象迭代(Object.values(),Object.entries())"></a>对象迭代(Object.values(),Object.entries())</h3><p>这两个静态方法Object.values()和Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键&#x2F;值对的数组。<br>下面的示例展示了这两个方法：<br>const o &#x3D; {<br>    foo: ‘bar’,<br>    baz: 1,<br>    qux: {}<br>};<br>console.log(Object.values(o)); &#x2F;&#x2F; [“bar”, 1, {}]<br>console.log(Object.entries((o)));&#x2F;&#x2F; [[“foo”, “bar”], [“baz”, 1], [“qux”, {}]]<br><strong>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制, 符号属性会被忽略</strong></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>实现继承是ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有<br>一个属性指回构造函数，而实例有一个内部指针指向原型，<strong>如下</strong>：</p><p>在 JavaScript 中，每个构造函数都有一个 <code>prototype</code> 属性，这个属性是一个对象，称为“原型对象”。原型对象中有一个特殊的属性 <code>constructor</code>，它指回构造函数本身。同时，每个通过构造函数创建的实例对象都有一个内部属性（通常表示为 <code>[[Prototype]]</code>），这个内部属性指向构造函数的原型对象。</p><p>假设我们有一个构造函数 <code>Person</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个构造函数中，<code>Person.prototype</code> 是一个对象，它有一个 <code>constructor</code> 属性，指向 <code>Person</code> 构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><p>当我们使用 <code>new</code> 关键字创建 <code>Person</code> 的实例时，JavaScript 会执行以下步骤：</p><ol><li>创建一个新对象。</li><li>将新对象的 <code>[[Prototype]]</code> 内部属性设置为 <code>Person.prototype</code>。</li><li>执行构造函数，将 <code>this</code> 绑定到新对象。</li><li>返回新对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>在 <code>person1</code> 这个实例对象中，有一个内部指针 <code>[[Prototype]]</code> 指向 <code>Person.prototype</code>。虽然这个内部指针在 JavaScript 中不能直接访问，但可以通过 <code>Object.getPrototypeOf</code> 方法来查看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person1) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><p>通过原型链，实例对象可以访问原型对象上的属性和方法。例如，如果我们在 <code>Person.prototype</code> 上定义一个方法 <code>sayHello</code>，那么所有 <code>Person</code> 的实例都可以访问这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> and I am <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> years old.`</span>);<br>&#125;;<br><br>person1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出: Hello, my name is Alice and I am 30 years old.</span><br></code></pre></td></tr></table></figure><ul><li><strong>构造函数</strong>：<code>Person</code>。</li><li><strong>原型对象</strong>：<code>Person.prototype</code>。</li><li><strong>原型对象的 <code>constructor</code> 属性</strong>：<code>Person.prototype.constructor</code> 指回 <code>Person</code>。</li><li><strong>实例对象</strong>：<code>person1</code>。</li><li><strong>实例对象的内部指针</strong>：<code>person1</code> 的 <code>[[Prototype]]</code> 指向 <code>Person.prototype</code>。</li></ul><p>通过这种方式，JavaScript 实现了基于原型的继承机制。每个实例对象都可以访问其构造函数原型对象上的属性和方法，从而实现了代码的复用和继承。</p><h3 id="盗用构造函数-继承"><a href="#盗用构造函数-继承" class="headerlink" title="盗用构造函数(继承)"></a>盗用构造函数(继承)</h3><p>基本思路：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和call()方法以新创建的对象为上下文执行构造函数。</p><p>function SuperType() {<br>    this.colors &#x3D; [“red”, “blue”, “green”];<br>}<br>function SubType() {<br>    <strong>&#x2F;&#x2F; 继承SuperType</strong><br>    <strong>SuperType.call(this);</strong><br>}<br>let instance1 &#x3D; new SubType();<br>instance1.colors.push(“black”);<br>console.log(instance1.colors); &#x2F;&#x2F; “red,blue,green,black”<br>let instance2 &#x3D; new SubType();<br>console.log(instance2.colors); &#x2F;&#x2F; “red,blue,green”</p><p>示例中加粗的代码展示了盗用构造函数的调用。通过使用call()（或apply()）方法，SuperType构造函数在为SubType 的实例创建的新对象的上下文中执行了。这相当于新的SubType 对象上运行了SuperType()函数中的所有初始化代码。结果就是每个实例都会有自己的colors 属性。</p><p>相比于使用原型链，盗用构造函数的<strong>一个优点就是可以在子类构造函数中向父类构造函数传参</strong>。来看下面的例子：<br>function SuperType(name){<br>    this.name &#x3D; name;<br>}<br>function SubType() {<br>    &#x2F;&#x2F; 继承SuperType 并传参<br>    SuperType.call(this, “Nicholas”);<br>    &#x2F;&#x2F; 实例属性<br>    this.age &#x3D; 29;<br>}<br>let instance &#x3D; new SubType();<br>console.log(instance.name); &#x2F;&#x2F; “Nicholas”;<br>console.log(instance.age); &#x2F;&#x2F; 29<br>在这个例子中，SuperType 构造函数接收一个参数name，然后将它赋值给一个属性。在SubType构造函数中调用SuperType 构造函数时传入这个参数，实际上会在SubType 的实例上定义name 属性。为确保SuperType 构造函数不会覆盖SubType 定义的属性，可以在调用父类构造函数之后再给子类实例添加额外的属性。</p><p>主要缺点，也是使用构造函数模式自定义类型的问题：<strong>必须在构造函数中定义方法，因此函数不能重用</strong>。此外，<strong>子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式</strong>。由于存在这些问题，盗用构造函数基本上也不能单独使用。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承（有时候也叫伪经典继承）<strong>综合了原型链和盗用构造函数</strong>，将两者的优点集中了起来。基本的思路是使用<strong>原型链继承原型上的属性和方法</strong>，而通过<strong>盗用构造函数继承实例属性</strong>。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。例如：</p><p>function SuperType(name){<br>    this.name &#x3D; name;<br>    this.colors &#x3D; [“red”, “blue”, “green”];<br>}<br>SuperType.prototype.sayName &#x3D; function() {<br>    console.log(this.name);<br>};<br>function SubType(name, age){<br>    &#x2F;&#x2F; 继承属性<br>    <strong>SuperType.call(this, name);</strong><br>    this.age &#x3D; age;<br>}<br>&#x2F;&#x2F; 继承方法<br><strong>SubType.prototype &#x3D; new SuperType();</strong><br>SubType.prototype.sayAge &#x3D; function() {<br>    console.log(this.age);<br>};<br>let instance1 &#x3D; new SubType(“Nicholas”, 29);<br>instance1.colors.push(“black”);<br>console.log(instance1.colors); &#x2F;&#x2F; “red,blue,green,black”<br>instance1.sayName(); &#x2F;&#x2F; “Nicholas”;<br>instance1.sayAge(); &#x2F;&#x2F; 29<br>let instance2 &#x3D; new SubType(“Greg”, 27);<br>console.log(instance2.colors); &#x2F;&#x2F; “red,blue,green”<br>instance2.sayName(); &#x2F;&#x2F; “Greg”;<br>instance2.sayAge(); &#x2F;&#x2F; 27</p><p>组合继承弥补了原型链和盗用构造函数的不足，是JavaScript 中使用最多的继承模式。而且组合继承也保留了instanceof 操作符和isPrototypeOf()方法识别合成对象的能力。</p><h3 id="原型式继承（-Object-create-）"><a href="#原型式继承（-Object-create-）" class="headerlink" title="原型式继承（**Object.create()**）"></a>原型式继承（**Object.create()**）</h3><p>一种不涉及严格意义上构造函数的继承方法，例如：</p><p>function object(o) {<br>    function F() {}<br>    F.prototype &#x3D; o;<br>    return new F();<br>}<br>这个object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制。来看下面的例子：</p><p>let person &#x3D; {<br>    name: “Nicholas”,<br>    friends: [“Shelby”, “Court”, “Van”]<br>};<br>let anotherPerson &#x3D; object(person);<br>anotherPerson.name &#x3D; “Greg”;<br>anotherPerson.friends.push(“Rob”);<br>let yetAnotherPerson &#x3D; object(person);<br>yetAnotherPerson.name &#x3D; “Linda”;<br>yetAnotherPerson.friends.push(“Barbie”);<br>console.log(person.friends); &#x2F;&#x2F; “Shelby,Court,Van,Rob,Barbie”</p><p>原型式继承适用于这种情况：<strong>有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给object()，然后再对返回的对象进行适当修改。</strong></p><p>在这个例子中，person 对象定义了另一个对象也应该共享的信息，把它传给object()之后会返回一个新对象。这个新对象的原型是person，意味着它的原型上既有原始值属性又有引用值属性。这也意味着person.friends 不仅是person 的属性，也会跟anotherPerson 和yetAnotherPerson 共享。这里实际上克隆了两个person。</p><p>ECMAScript 5 通过增加**Object.create()**方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。Object.create()的第二个参数与Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。</p><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），是Crockford 首倡的一种模式。<strong>寄生式继承背后的思路类似于寄生构造函数和工厂模式</strong>：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：</p><p>function createAnother(original){<br>    let clone &#x3D; object(original); &#x2F;&#x2F; 通过调用函数创建一个新对象<br>    clone.sayHi &#x3D; function() { &#x2F;&#x2F; 以某种方式增强这个对象<br>        console.log(“hi”);<br>    };<br>    return clone; &#x2F;&#x2F; 返回这个对象<br>}</p><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。再来看一看这个组合继承的例子：</p><p>function SuperType(name) {<br>    this.name &#x3D; name;<br>    this.colors &#x3D; [“red”, “blue”, “green”];<br>}<br>SuperType.prototype.sayName &#x3D; function() {<br>    console.log(this.name);<br>};<br>function SubType(name, age){<br>    SuperType.call(this, name); &#x2F;&#x2F; 第二次调用SuperType()<br>    this.age &#x3D; age;<br>}<br>SubType.prototype &#x3D; new SuperType(); &#x2F;&#x2F; 第一次调用SuperType()<br>SubType.prototype.constructor &#x3D; SubType;<br>SubType.prototype.sayAge &#x3D; function() {<br>    console.log(this.age);<br>};</p><p>代码中加粗的部分是调用SuperType 构造函数的地方。在上面的代码执行后，SubType.prototype上会有两个属性：name 和colors。它们都是SuperType 的实例属性，但现在成为了SubType 的原型属性。在调用SubType 构造函数时，也会调用SuperType 构造函数，这一次会在新对象上创建实例属性name 和colors。这两个实例属性会遮蔽原型上同名的属性。</p><h2 id="类-class（该处略写）"><a href="#类-class（该处略写）" class="headerlink" title="类 class（该处略写）"></a>类 class（该处略写）</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>与函数类型相似，定义类也有两种主要方式：<strong>类声明</strong>和<strong>类表达式</strong>。这<strong>两种方式都使用class 关键字加大括号</strong>：</p><p>&#x2F;&#x2F; 类声明<br>class Person {}<br>&#x2F;&#x2F; 类表达式<br>const Animal &#x3D; class {};</p><p>类的构成<br>类可以包含<strong>构造函数方法</strong>、<strong>实例方法</strong>、<strong>获取函数</strong>、<strong>设置函数</strong>和<strong>静态类方法</strong>，但这些都<strong>不是</strong>必需的。<strong>空的类定义照样有效</strong>。默认情况下，类定义中的代码都在严格模式下执行。</p><p>&#x2F;&#x2F; 空类定义，有效<br>class Foo {}<br>&#x2F;&#x2F; 有构造函数的类，有效<br>class Bar {<br>    constructor() {}<br>}<br>&#x2F;&#x2F; 有获取函数的类，有效<br>class Baz {<br>    get myBaz() {}<br>}<br>&#x2F;&#x2F; 有静态方法的类，有效<br>class Qux {<br>    static myQux() {}<br>}</p><h3 id="类构造函数（constructor）"><a href="#类构造函数（constructor）" class="headerlink" title="类构造函数（constructor）"></a>类构造函数（constructor）</h3><p><strong>constructor 关键字</strong>用于在类定义块内部创建类的构造函数。方法名constructor 会告诉解释器在使用new 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p><p>1.实例化<br>使用new 操作符实例化Person 的操作等于使用new 调用其构造函数。唯一可感知的不同之处就是，JavaScript 解释器知道使用new 和类意味着应该使用constructor 函数进行实例化。</p><p><strong>使用new 调用类的构造函数会执行如下操作。</strong><br>(1) 在内存中创建一个新对象。<br>(2) 这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype 属性。<br>(3) 构造函数内部的this 被赋值为这个新对象（即this 指向新对象）。<br>(4) 执行构造函数内部的代码（给新对象添加属性）。<br>(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p><p>例子：<br>class Animal {}<br>class Person {<br>    constructor() {<br>        console.log(‘person ctor’);<br>    }<br>}<br>class Vegetable {<br>    constructor() {<br>        this.color &#x3D; ‘orange’;<br>    }<br>}<br>let a &#x3D; new Animal();<br>let p &#x3D; new Person(); &#x2F;&#x2F; person ctor<br>let v &#x3D; new Vegetable();<br>console.log(v.color); &#x2F;&#x2F; orange</p><p>2.把类当成特殊函数<br>ECMAScript 中没有正式的类这个类型。从各方面来看，ECMAScript <strong>类就是一种特殊函数</strong>。声明一个类之后，通过typeof 操作符检测类标识符，表明它是一个函数：</p><p>class Person {}<br>console.log(Person); &#x2F;&#x2F; class Person {}<br>console.log(typeof Person); &#x2F;&#x2F; function</p><p>类标识符<strong>有prototype 属性</strong>，而<strong>这个原型也有一个constructor 属性指向类自身。</strong>与普通构造函数一样，可以使用<strong>instanceof 操作符检查构造函数原型是否存在于实例的原型链中</strong>。</p><h3 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h3><p>类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p><h3 id="继承（extends，super-）"><a href="#继承（extends，super-）" class="headerlink" title="继承（extends，super()）"></a>继承（extends，super()）</h3><p>本章前面花了大量篇幅讨论如何使用ES5 的机制实现继承。ECMAScript 6 新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p><p>ES6 类支持单继承。使用extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）：</p><p>class Vehicle {}<br>&#x2F;&#x2F; 继承类<br>class Bus extends Vehicle {}<br>let b &#x3D; new Bus();<br>console.log(b instanceof Bus); &#x2F;&#x2F; true<br>console.log(b instanceof Vehicle); &#x2F;&#x2F; true<br>function Person() {}<br>&#x2F;&#x2F; 继承普通构造函数<br>class <strong>Engineer</strong> extends Person {}<br><strong>let e &#x3D; new Engineer();</strong><br>console.log(e instanceof Engineer); &#x2F;&#x2F; true<br>console.log(e instanceof Person); &#x2F;&#x2F; true</p><p><strong>extends</strong> 关键字也可以在类表达式中使用，因此let Bar &#x3D; class extends Foo {}<br>是有效的语法。</p><p>构造函数、HomeObject 和super()</p><p>派生类的方法可以通过super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super 可以调用父类构造函数。<br>class Vehicle {<br>    constructor() {<br>        this.hasEngine &#x3D; true;<br>    }<br>}<br>class Bus extends Vehicle {<br>    constructor() {<br>        <strong>&#x2F;&#x2F; 不要在调用super()之前引用this，否则会抛出ReferenceError</strong><br>        <strong>super(); &#x2F;&#x2F; 相当于super.constructor()</strong><br>        console.log(this instanceof Vehicle);   &#x2F;&#x2F; true<br>        console.log(this);   &#x2F;&#x2F; Bus { hasEngine: true }<br>    }<br>}<br>new Bus();</p><p>在静态方法中可以通过super 调用继承的类上定义的静态方法：<br>class Vehicle {<br>    static identify() {<br>        console.log(‘vehicle’);<br>    }<br>}<br>class Bus extends Vehicle {<br>    static identify() {<br>        super.identify();<br>    }<br>}<br>Bus.identify(); &#x2F;&#x2F; vehicle</p><p>ES6 给类构造函数和静态方法添加了内部特性**[[HomeObject]]，这个特性是一个**<br><strong>指针，指向定义该方法的对象。</strong>这个指针是自动赋值的，而且只能在JavaScript 引擎内部访问。super 始终会定义为[[HomeObject]]的原型。</p><p>在使用super 时要注意几个问题：<br> super 只能在派生类构造函数和静态方法中使用。<br> 不能单独引用super 关键字，要么用它调用构造函数，要么用它引用静态方法。<br> 调用super()会调用父类构造函数，并将返回的实例赋值给this。<br> super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。<br> 如果没有定义类构造函数，在实例化派生类时会调用super()，而且会传入所有传给派生类的参数。<br> 在类构造函数中，不能在调用super()之前引用this。<br> 如果在派生类中显式定义了构造函数，则要么必须在其中调用super()，要么必须在其中返回一个对象。</p><p>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然ECMAScript 没有专门支持这种类的语法 ，但通过<strong>new.target</strong> 也很容易实现。new.target 保存通过new 关键字调用的类或函数。通过在实例化时检测new.target 是不是抽象基类，可以阻止对抽象基类的实例化：（这部分略写）</p><p>&#x2F;&#x2F; 抽象基类<br>class Vehicle {<br>    constructor() {<br>        console.log(new.target);<br>        if (new.target &#x3D;&#x3D;&#x3D; Vehicle) {<br>            throw new Error(‘Vehicle cannot be directly instantiated’);<br>        }<br>    }<br>}<br>&#x2F;&#x2F; 派生类<br>class Bus extends Vehicle {}<br>new Bus(); &#x2F;&#x2F; class Bus {}<br>new Vehicle(); &#x2F;&#x2F; class Vehicle {}<br>&#x2F;&#x2F; Error: Vehicle cannot be directly instantiated</p><h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>代理是ECMAScript 6 新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的JavaScript 元编程及抽象的新天地。</p><p>从宏观上看，代理是真实JavaScript 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是<strong>遵从捕获器不变式。</strong></p><p>与代理如影随形的反射API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射API看作一套基本操作，这些操作是绝大部分JavaScript 对象API 的基础。</p><p>代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。</p><p>ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，<strong>可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。</strong></p><h2 id="Proxy的基本概念"><a href="#Proxy的基本概念" class="headerlink" title="Proxy的基本概念"></a>Proxy的基本概念</h2><p>来自知乎：<a href="https://zhuanlan.zhihu.com/p/674933571">JavaScript之Proxy详解 - 知乎</a></p><h2 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h2><p>代理是目标对象的抽象。从很多方面看，<strong>代理类似C++指针</strong>，因为它<strong>可以</strong><br><strong>用作目标对象的替身，但又完全独立于目标对象</strong>。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。<br>(但是实际上：ECMAScript 代理与C++指针有重大区别)</p><h3 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h3><p>代理是使用<strong>Proxy 构造函数</strong>创建的。这个构造函数接收<strong>两个参数：目标对象和处理程序对象</strong>。缺少其中任何一个参数都会抛出TypeError。</p><p>如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。<br>const target &#x3D; {<br>    id: ‘target’<br>};<br>const handler &#x3D; {};<br><strong>const proxy &#x3D; new Proxy(target, handler);</strong></p><p><strong>&#x2F;&#x2F; id 属性会访问同一个值</strong><br>console.log(target.id); &#x2F;&#x2F; target<br>console.log(proxy.id); &#x2F;&#x2F; target</p><p><strong>&#x2F;&#x2F; 给目标属性赋值会反映在两个对象上</strong><br><strong>&#x2F;&#x2F; 因为两个对象访问的是同一个值</strong><br>target.id &#x3D; ‘foo’;<br>console.log(target.id); &#x2F;&#x2F; foo<br>console.log(proxy.id); &#x2F;&#x2F; foo</p><p><strong>&#x2F;&#x2F; 给代理属性赋值会反映在两个对象上</strong><br><strong>&#x2F;&#x2F; 因为这个赋值会转移到目标对象</strong><br>proxy.id &#x3D; ‘bar’;<br>console.log(target.id); &#x2F;&#x2F; bar<br>console.log(proxy.id); &#x2F;&#x2F; bar</p><p><strong>&#x2F;&#x2F; hasOwnProperty()方法在两个地方</strong><br><strong>&#x2F;&#x2F; 都会应用到目标对象</strong><br>console.log(target.hasOwnProperty(‘id’)); &#x2F;&#x2F; true<br>console.log(proxy.hasOwnProperty(‘id’)); &#x2F;&#x2F; true</p><p><strong>&#x2F;&#x2F; Proxy.prototype 是undefined</strong><br><strong>&#x2F;&#x2F; 因此不能使用instanceof 操作符</strong><br>console.log(target instanceof Proxy); &#x2F;&#x2F; TypeError: Function has non-object prototype ‘undefined’ in instanceof check<br>console.log(proxy instanceof Proxy); &#x2F;&#x2F; TypeError: Function has non-object prototype ‘undefined’ in instanceof check</p><p><strong>&#x2F;&#x2F; 严格相等可以用来区分代理和目标</strong><br>console.log(target &#x3D;&#x3D;&#x3D; proxy); &#x2F;&#x2F; false</p><h3 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h3><p>使用代理的<strong>主要目的是可以定义捕获器（trap）</strong>。<strong>捕获器就是在处理程序对象中定义的“基本操作的拦截器”。</strong>每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。<strong>每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</strong></p><p>例如，可以<strong>定义一个get()捕获器</strong>，在ECMAScript 操作以某种形式调用get()时触发。下面的例子定义了一个get()捕获器：<br>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    &#x2F;&#x2F; 捕获器在处理程序对象中以方法名为键<br>    <strong>get() {</strong><br>        <strong>return ‘handler override’;</strong><br>    <strong>}</strong><br>};<br>const proxy &#x3D; new Proxy(target, handler);</p><p>这样，当通过代理对象执行get()操作时，就会触发定义的get()捕获器。get()不是<br>ECMAScript 对象可以调用的方法。这个操作在JavaScript 代码中可以通过多种形式触发并被get()捕获器拦截到。proxy[property]、proxy.property 或Object.create(proxy)[property]等操作都会触发基本的get()操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发get()捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。</p><h3 id="捕获器参数和反射API（捕获器-get-反射API-Reflect）"><a href="#捕获器参数和反射API（捕获器-get-反射API-Reflect）" class="headerlink" title="捕获器参数和反射API（捕获器:get(),反射API:Reflect）"></a>捕获器参数和反射API（捕获器:get(),反射API:Reflect）</h3><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到<strong>目标对象</strong>、<strong>要查询的属性</strong>和<strong>代理对象</strong>三个参数。</p><p>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    get(trapTarget, property, receiver) {<br>        console.log(trapTarget &#x3D;&#x3D;&#x3D; target);<br>        console.log(property);<br>        console.log(receiver &#x3D;&#x3D;&#x3D; proxy);<br>    }<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>proxy.foo;<br>&#x2F;&#x2F; true<br>&#x2F;&#x2F; foo<br>&#x2F;&#x2F; true</p><p><strong>有了这些参数，就可以重建被捕获方法的原始行为：</strong></p><p>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    get(trapTarget, property, receiver) {<br>        return trapTarget[property];<br>    }<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>console.log(proxy.foo); &#x2F;&#x2F; bar<br>console.log(target.foo); &#x2F;&#x2F; bar</p><p>处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。使用反射API 也可以像下面这样定义出空代理对象：</p><p>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    get() {<br>        <strong>return Reflect.get(…arguments);</strong><br>    }<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>console.log(proxy.foo); &#x2F;&#x2F; bar<br>console.log(target.foo); &#x2F;&#x2F; bar</p><p>甚至还可以写得更简洁一些：<br>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    get: Reflect.get<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>console.log(proxy.foo); &#x2F;&#x2F; bar<br>console.log(target.foo); &#x2F;&#x2F; bar</p><p>事实上，<strong>如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射API 的空代理，那么甚至不需要定义处理程序对象</strong>：</p><p>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const proxy &#x3D; new Proxy(target, Reflect);<br>console.log(proxy.foo); &#x2F;&#x2F; bar<br>console.log(target.foo); &#x2F;&#x2F; bar</p><p>反射API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。</p><h3 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h3><p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。<br>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出TypeError：</p><p>const target &#x3D; {};<br>Object.defineProperty(target, ‘foo’, {<br>    configurable: false,<br>    writable: false,<br>    value: ‘bar’<br>});<br>const handler &#x3D; {<br>    get() {<br>        return ‘qux’;<br>    }<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>console.log(proxy.foo);<br>&#x2F;&#x2F; TypeError</p><h3 id="可撤销代理（revocable-方法）"><a href="#可撤销代理（revocable-方法）" class="headerlink" title="可撤销代理（revocable()方法）"></a>可撤销代理（revocable()方法）</h3><p>有时候可能需要中断代理对象与目标对象之间的联系。Proxy 暴露了<strong>revocable()方法</strong>，这个方法支持<strong>撤销代理对象与目标对象的关联</strong>。撤销代理的<br>操作是<strong>不可逆</strong>的。而且，<strong>撤销函数（revoke()）是幂等的</strong>，调用多少次的结果都一样。撤销代理之后再调用代理会抛出TypeError。</p><p><strong>撤销函数和代理对象是在实例化时同时生成</strong>的：<br>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const handler &#x3D; {<br>    get() {<br>        return ‘intercepted’;<br>    }<br>};<br>const { proxy, revoke } &#x3D; Proxy.revocable(target, handler);<br>console.log(proxy.foo); &#x2F;&#x2F; intercepted<br>console.log(target.foo); &#x2F;&#x2F; bar<br>revoke();<br>console.log(proxy.foo); &#x2F;&#x2F; TypeError</p><h3 id="实用反射API"><a href="#实用反射API" class="headerlink" title="实用反射API"></a>实用反射API</h3><p>某些情况下应该优先使用反射API。</p><h5 id="1-反射API-与对象API"><a href="#1-反射API-与对象API" class="headerlink" title="1  反射API 与对象API"></a>1  反射API 与对象API</h5><p>在使用反射API 时，要记住：<br>(1) 反射API 并不限于捕获处理程序；<br>(2) 大多数反射API 方法在Object 类型上有对应的方法。<br>通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。</p><h5 id="2-状态标记"><a href="#2-状态标记" class="headerlink" title="2  状态标记"></a>2  状态标记</h5><p>很多反射方法返回称作“<strong>状态标记</strong>”的布尔值，表示意图执行的操作是否成功。有时候，<strong>状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射API 方法更有用</strong>。例如，可以使用反射API 对下面的代码进行重构：</p><p>&#x2F;&#x2F; 初始代码<br>const o &#x3D; {};<br>try {<br>    Object.defineProperty(o, ‘foo’, ‘bar’);<br>    console.log(‘success’);<br>} catch(e) {<br>    console.log(‘failure’);<br>}</p><p>在定义新属性时如果发生问题，Reflect.defineProperty()会返回false，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：<br>&#x2F;&#x2F; 重构后的代码<br>const o &#x3D; {};<br>if(Reflect.defineProperty(o, ‘foo’, {value: ‘bar’})) {<br>    console.log(‘success’);<br>} else {<br>    console.log(‘failure’);<br>}</p><p>以下反射方法都会提供状态标记：<br><strong> Reflect.defineProperty()</strong><br><strong> Reflect.preventExtensions()</strong><br><strong> Reflect.setPrototypeOf()</strong><br><strong> Reflect.set()</strong><br><strong> Reflect.deleteProperty()</strong></p><h5 id="3-用一等函数替代操作符"><a href="#3-用一等函数替代操作符" class="headerlink" title="3  用一等函数替代操作符"></a>3  用一等函数替代操作符</h5><p>以下反射方法提供只有<strong>通过操作符才能完成</strong>的操作。<br><strong> Reflect.get()：可以替代对象属性访问操作符。</strong><br><strong> Reflect.set()：可以替代&#x3D;赋值操作符。</strong><br><strong> Reflect.has()：可以替代in 操作符或with()。</strong><br><strong> Reflect.deleteProperty()：可以替代delete 操作符。</strong><br><strong> Reflect.construct()：可以替代new 操作符。</strong></p><h5 id="4-安全地应用函数"><a href="#4-安全地应用函数" class="headerlink" title="4  安全地应用函数"></a>4  安全地应用函数</h5><p>在通过apply 方法调用函数时，被调用的函数可能也定义了自己的apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在Function 原型上的apply 方法：</p><p><strong>Function.prototype.apply.call(myFunc, thisVal, argumentList);</strong></p><p>可怕的代码完全可以<strong>使用Reflect.apply 来避免</strong>：<br><strong>Reflect.apply(myFunc, thisVal, argumentsList);</strong></p><h3 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h3><p>代理可以拦截反射API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：</p><p>const target &#x3D; {<br>    foo: ‘bar’<br>};<br>const firstProxy &#x3D; new Proxy(<strong>target</strong>, {<br>    get() {<br>        console.log(‘first proxy’);<br>        <strong>return Reflect.get(…arguments);</strong><br>    }<br>});<br>const secondProxy &#x3D; new Proxy(<strong>firstProxy</strong>, {<br>    get() {<br>        console.log(‘second proxy’);<br>        <strong>return Reflect.get(…arguments);</strong><br>    }<br>});<br>console.log(secondProxy.foo);<br>&#x2F;&#x2F; second proxy<br>&#x2F;&#x2F; first proxy<br>&#x2F;&#x2F; bar</p><h3 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h3><p>代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的ECMAScript机制很好地协同。</p><p>1  代理中的this<br>代理潜在的一个问题来源是this 值。我们知道，方法中的this 通常指向调用这个方法的对象。</p><p>2  代理与内部槽位<br>代理与内置引用类型（比如Array）的实例通常可以很好地协同，但有些ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。</p><h3 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h3><p>代理可以捕获13 种不同的基本操作。只要在代理上调用，所有捕获器都会拦截它们对应的反射API 操作。</p><table><thead><tr><th align="left">方法名称</th><th>作用</th><th align="left">反射API方法</th></tr></thead><tbody><tr><td align="left">get()</td><td>获取属性值的操作中被调用</td><td align="left">Reflect.get()</td></tr><tr><td align="left">set()</td><td>设置属性值的操作中被调用</td><td align="left">Reflect.set()</td></tr><tr><td align="left">has()</td><td>在in 操作符中被调用</td><td align="left">Reflect.has()</td></tr><tr><td align="left">defineProperty()</td><td>在Object.defineProperty()中被调用</td><td align="left">Reflect.defineProperty()</td></tr><tr><td align="left">getOwnPropertyDescriptor()</td><td>在Object.getOwnPropertyDescriptor()中被调用</td><td align="left">Reflect.getOwnPropertyDescriptor()</td></tr><tr><td align="left">deleteProperty()</td><td>在delete 操作符中被调用</td><td align="left">Reflect.deleteProperty()</td></tr><tr><td align="left">ownKeys()</td><td>在Object.keys()及类似方法中被调用</td><td align="left">Reflect.ownKeys()</td></tr><tr><td align="left">getPrototypeOf()</td><td>在Object.getPrototypeOf()中被调用</td><td align="left">Reflect.getPrototypeOf()</td></tr><tr><td align="left">setPrototypeOf()</td><td>在Object.setPrototypeOf()中被调用</td><td align="left">Reflect.setPrototypeOf()</td></tr><tr><td align="left">isExtensible()</td><td>在Object.isExtensible()中被调用</td><td align="left">Reflect.isExtensible()</td></tr><tr><td align="left">preventExtensions()</td><td>在Object.preventExtensions()中被调用</td><td align="left">Reflect.preventExtensions()</td></tr><tr><td align="left">apply()</td><td>调用函数时中被调用</td><td align="left">Reflect.apply()</td></tr><tr><td align="left">construct()</td><td>new 操作符中被调用</td><td align="left">Reflect.construct()</td></tr></tbody></table><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>使用代理可以在代码中实现一些有用的编程模式。</p><table><thead><tr><th align="left">代理模式名称</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">跟踪属性访问</td><td align="left">知道对象属性什么时候被访问、被查询</td></tr><tr><td align="left">隐藏属性</td><td align="left">隐藏目标对象上的属性</td></tr><tr><td align="left">属性验证</td><td align="left">赋值操作都会触发set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值</td></tr><tr><td align="left">函数与构造函数参数验证</td><td align="left">可以让函数只接收某种类型的值</td></tr><tr><td align="left">数据绑定与可观察对象</td><td align="left">通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。</td></tr></tbody></table><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是JavaScript 编程中最有用也最通用的工具。ECMAScript 6 新增了更加强大的语法特性，从而让开发者可以更有效地使用函数。<br> 函数表达式与函数声明是不一样的。函数声明要求写出函数名称，而函数表达式并不需要。没有名称的函数表达式也被称为匿名函数。<br> ES6 新增了类似于函数表达式的箭头函数语法，但两者也有一些重要区别。<br> JavaScript 中函数定义与调用时的参数极其灵活。arguments 对象，以及ES6 新增的扩展操作符，可以实现函数定义和调用的完全动态化。<br> 函数内部也暴露了很多对象和引用，涵盖了函数被谁调用、使用什么调用，以及调用时传入了什么参数等信息。<br> JavaScript 引擎可以优化符合尾调用条件的函数，以节省栈空间。<br> 闭包的作用域链中包含自己的一个变量对象，然后是包含函数的变量对象，直到全局上下文的变量对象。<br> 通常，函数作用域及其中的所有变量在函数执行完毕后都会被销毁。<br> 闭包在被函数返回之后，其作用域会一直保存在内存中，直到闭包被销毁。<br> 函数可以在创建之后立即调用，执行其中代码之后却不留下对函数的引用。<br> 立即调用的函数表达式如果不在包含作用域中将返回值赋给一个变量，则其包含的所有变量都会被销毁。<br> 虽然JavaScript 没有私有对象属性的概念，但可以使用闭包实现公共方法，访问位于包含作用域中定义的变量。<br> 可以访问私有变量的公共方法叫作特权方法。<br> 特权方法可以使用构造函数或原型模式通过自定义类型中实现，也可以使用模块模式或模块增强模式在单例对象上实现。</p><h2 id="10-9-函数内部（arguments-callee，this，caller-new-target）"><a href="#10-9-函数内部（arguments-callee，this，caller-new-target）" class="headerlink" title="10.9 函数内部（arguments,callee，this，caller,new.target）"></a>10.9 函数内部（arguments,callee，this，caller,new.target）</h2><p>在ECMAScript 5 中，函数内部存在两个特殊的对象：<strong>arguments</strong> 和<strong>this</strong>。ECMAScript 6 又新增了new.target 属性。</p><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>它是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但arguments 对象其实还有一个<strong>callee</strong> 属性，是一个指向arguments 对象所在函数的指针。</p><p>来看下面这个经典的阶乘函数：<br>function factorial(num) {<br>    if (num &lt;&#x3D; 1) {<br>        return 1;<br>    } else {<br>        return num * factorial(num - 1);<br>    }<br>}<br>阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是factorial，从而导致了紧密耦合。使用arguments.callee 就可以让函数逻辑与函数名解耦：<br>function factorial(num) {<br>    if (num &lt;&#x3D; 1) {<br>        return 1;<br>    } else {<br>        return num * arguments.callee(num - 1);<br>    }<br>}</p><p>这个重写之后的factorial()函数已经用arguments.callee 代替了之前硬编码的factorial。<br>这意味着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况：</p><p>let trueFactorial &#x3D; factorial;<br>factorial &#x3D; function() {<br>    return 0;<br>};<br>console.log(trueFactorial(5)); &#x2F;&#x2F; 120<br>console.log(factorial(5)); &#x2F;&#x2F; 0</p><p>这里，trueFactorial 变量被赋值为factorial，实际上把同一个函数的指针又保存到了另一个位置。然后，factorial 函数又被重写为一个返回0 的函数。如果像factorial()最初的版本那样不使用arguments.callee，那么像上面这样调用trueFactorial()就会返回0。不过，通过将函数与名称解耦，trueFactorial()就可以正确计算阶乘，而factorial()则只能返回0。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>另一个特殊的对象是this，它在标准函数和箭头函数中有不同的行为。</p><ol><li>在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为this 值（在网页的全局上下文中调用函数时，this 指向windows）。</li><li><strong>在箭头函数中，this 引用的是定义箭头函数的上下文。</strong></li></ol><h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><p>这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为null。</p><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6 新增了<strong>检测函数是否使用new 关键字调用的new.target 属性</strong>。如果<strong>函数是正常调用的，则new.target 的值是undefined</strong>；<strong>如果是使用new 关键字调用的，则new.target 将引用被调用的构造函数</strong>。</p><h2 id="函数属性与方法（length，prototype，apply-，call-，bind-）"><a href="#函数属性与方法（length，prototype，apply-，call-，bind-）" class="headerlink" title="函数属性与方法（length，prototype，apply()，call()，bind()）"></a>函数属性与方法（length，prototype，apply()，call()，bind()）</h2><p>前面提到过，ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：length和prototype。其中，length 属性保存函数定义的命名参数的个数。例如：</p><p>function sayName(name) {<br>    console.log(name);<br>}<br>function sum(num1, num2) {<br>    return num1 + num2;<br>}<br>function sayHi() {<br>    console.log(“hi”);<br>}<br>console.log(sayName.length); &#x2F;&#x2F; 1<br>console.log(sum.length); &#x2F;&#x2F; 2<br>console.log(sayHi.length); &#x2F;&#x2F; 0</p><p>prototype 是<strong>保存引用类型所有实例方法的地方</strong>，这意味着toString()、valueOf()等方法实际上都保存在prototype 上，进而由所有实例共享。这个属性在自定义类型时特别重要。在ECMAScript 5中，<strong>prototype 属性是不可枚举的</strong>，<strong>因此使用for-in 循环不会返回这个属性</strong>。</p><p>函数还有3个方法：<strong>apply()和call()<strong>。这两个方法都会以指定的this 值来调用函数，即会设置调用函数时函数体内this 对象的值。还有</strong>bind()方法</strong>会创建一个新的函数实例，其this 值会被绑定到传给bind()的对象。</p><h1 id="期约与异步函数"><a href="#期约与异步函数" class="headerlink" title="期约与异步函数"></a>期约与异步函数</h1><p>期以来，掌握单线程JavaScript 运行时的异步行为一直都是个艰巨的任务。随着ES6 新增了期约和ES8 新增了<strong>异步函数</strong>，ECMAScript 的异步编程特性有了长足的进步。通过<strong>期约</strong>和<strong>async&#x2F;await</strong>，不仅可以实现之前难以实现或不可能实现的任务，而且也能写出更清晰、简洁，并且容易理解、调试的代码。</p><p>期约的主要功能是为异步代码提供了清晰的抽象。可以用期约表示异步执行的代码块，也可以用期约表示异步计算的值。在需要串行异步代码时，期约的价值最为突出。作为可塑性极强的一种结构，期约可以被序列化、连锁使用、复合、扩展和重组。</p><p>异步函数是将期约应用于JavaScript 函数的结果。<strong>异步函数可以暂停执行，而不阻塞主线程</strong>。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。异步函数可以说是现代JavaScript 工具箱中最重要的工具之一。</p><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p><strong>同步行为</strong>对应内存中<strong>顺序执行</strong>的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。</p><p><strong>异步行为</strong>类似于<strong>系统中断</strong>，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。</p><h3 id="以往的异步编程模式"><a href="#以往的异步编程模式" class="headerlink" title="以往的异步编程模式"></a>以往的异步编程模式</h3><p>早期的JavaScript 中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。</p><p>随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。嵌套回调的代码维护起来就是噩梦。</p><h2 id="期约（promise）"><a href="#期约（promise）" class="headerlink" title="期约（promise）"></a>期约（promise）</h2><h3 id="期约基础"><a href="#期约基础" class="headerlink" title="期约基础"></a>期约基础</h3><p>ECMAScript 6 新增的引用类型Promise，可以通过new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数，下面的例子使用了一个空函数对象来应付一下解释器：</p><p>let p &#x3D; new Promise(() &#x3D;&gt; {});<br>setTimeout(console.log, 0, p); &#x2F;&#x2F; Promise <pending></p><p>之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出SyntaxError。</p><p>期约是一个有状态的对象，可能处于如下3 种状态之一：</p><ol><li>待定（pending）</li><li>兑现（fulfilled，有时候也称为“解决”，resolved）</li><li>拒绝（rejected）</li></ol><p>期约的状态是<strong>私有</strong>的，不能直接通过JavaScript 检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也<strong>不能被外部JavaScript 代码修改</strong>。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。</p><p>由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：<strong>初始化期约的异步行为</strong>和<strong>控制状态的最终转换</strong>。</p><h4 id="解决值、拒绝理由及期约用例"><a href="#解决值、拒绝理由及期约用例" class="headerlink" title="解决值、拒绝理由及期约用例"></a>解决值、拒绝理由及期约用例</h4><table><thead><tr><th>方法</th><th>接受参数</th><th>作用</th></tr></thead><tbody><tr><td>new Promise((resolve, reject)&#x3D;&gt;{函数})</td><td>(resolve, reject)</td><td>创建一个期约</td></tr><tr><td>Promise.resolve()</td><td>任意：解决resolve期约的原因</td><td>可以实例化一个解决的期约。</td></tr><tr><td>Promise.reject()</td><td>任意：解决reject期约的原因</td><td>实例化一个拒绝的期约并抛出一个异步错误</td></tr></tbody></table><h4 id="期约的实例方法"><a href="#期约的实例方法" class="headerlink" title="期约的实例方法"></a>期约的实例方法</h4><p>每个期约实例的方法<strong>（then()、catch()和finally()）</strong>都会返回一个<strong>新的期约对象</strong>。</p><table><thead><tr><th>方法</th><th>接受参数</th><th>作用</th></tr></thead><tbody><tr><td>Promise.prototype.then()</td><td>onResolved 和onRejected 处理程序</td><td>为期约实例添加处理程序</td></tr><tr><td>Promise.prototype.catch()</td><td>onRejected 处理程序</td><td>用于给期约添加拒绝处理程序</td></tr><tr><td>Promise.prototype.finally()</td><td>onFinally处理程序</td><td>用于给期约添加onFinally 处理程序</td></tr></tbody></table><h4 id="Promise-类的静态方法"><a href="#Promise-类的静态方法" class="headerlink" title="Promise 类的静态方法"></a>Promise 类的静态方法</h4><table><thead><tr><th>方法</th><th>接受参数</th><th>作用</th></tr></thead><tbody><tr><td>Promise.all()</td><td>接收一个可迭代对象，返回一个新期约</td><td>在一组期约全部解决之后再解决</td></tr><tr><td>Promise.race()</td><td>接收一个可迭代对象，返回一个新期约</td><td>一组集合中最先解决或拒绝的期约的镜像</td></tr></tbody></table><h2 id="异步函数（async-await）"><a href="#异步函数（async-await）" class="headerlink" title="异步函数（async&#x2F;await）"></a>异步函数（async&#x2F;await）</h2><p>这个特性从行为和语法上都增强了JavaScript，让以同步方式写的代码能够异步执行。（我认为这相当于promise的语法糖）</p><p>&#x2F;&#x2F; 返回一个原始值<br>async function foo() {<br>    return ‘foo’;<br>}<br>foo().then(console.log);</p><p>异步函数<strong>（async）</strong>如果使用return 关键字返回了值（如果没有return 则会返回undefined），这个值会被Promise.resolve()包装成一个期约对象。</p><p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使<strong>await关键字</strong>可以暂停异步函数代码的执行，等待期约解决。</p><p>let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; setTimeout(resolve, 1000, 3));<br>p.then((x) &#x3D;&gt; console.log(x)); &#x2F;&#x2F; 3<br><strong>使用async&#x2F;await 可以写成这样：</strong><br>async function foo() {<br>    let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; setTimeout(resolve, 1000, 3));<br>    console.log(await p);<br>}<br>foo();<br>&#x2F;&#x2F; 3</p><p><strong>await 关键字</strong>会<strong>暂停执行异步函数后面的代码</strong>，让出JavaScript 运行时的执行线程。这个行为与生成器函数中的<strong>yield 关键字</strong>是一样的。await 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。</p><p><strong>await 关键字必须在异步函数中使用</strong></p><h3 id="异步函数策略"><a href="#异步函数策略" class="headerlink" title="异步函数策略"></a>异步函数策略</h3><ol><li><p>实现sleep()</p></li><li><p>利用平行执行</p></li><li><p>串行执行期约</p></li><li><p>栈追踪与内存管理</p></li></ol><h1 id="第12-章-BOM"><a href="#第12-章-BOM" class="headerlink" title="第12 章  BOM"></a>第12 章  BOM</h1><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>浏览器对象模型（BOM，Browser Object Model）是以<strong>window 对象为基础的，这个对象代表了浏览器窗口和页面可见的区域</strong>。<strong>window 对象也被复用为ECMAScript 的Global 对象</strong>，因此所有全局变量和函数都是它的属性，而且所有原生类型的构造函数和普通函数也都从一开始就存在于这个对象之上。本章讨论了BOM 的以下内容。<br> 要引用其他window 对象，可以使用几个不同的窗口指针。<br> 通过<strong>location 对象</strong>可以以编程方式操纵浏览器的导航系统。通过设置这个对象上的属性，可<br>以改变浏览器URL 中的某一部分或全部。<br> 使用<strong>replace()方法</strong>可以替换浏览器历史记录中当前显示的页面，并导航到新URL。<br> <strong>navigator 对象</strong>提供关于浏览器的信息。提供的信息类型取决于浏览器，不过有些属性如userAgent 是所有浏览器都支持的。<br>BOM 中的另外两个对象也提供了一些功能。screen 对象中保存着客户端显示器的信息。这些信息通常用于评估浏览网站的设备信息。history 对象提供了操纵浏览器历史记录的能力，开发者可以确定历史记录中包含多少个条目，并以编程方式实现在历史记录中导航，而且也可以修改历史记录。</p><h2 id="12-1-window-对象"><a href="#12-1-window-对象" class="headerlink" title="12.1 window 对象"></a>12.1 window 对象</h2><p>BOM 的核心是window 对象，表示浏览器的实例。window 对象在浏览器中有两重身份，一个是<br>ECMAScript 中的Global 对象，另一个就是浏览器窗口的JavaScript 接口</p><p>网页中定义的<strong>所有对象、变量和函数</strong>都以window 作为其Global 对象，都可以访问其上定义的<strong>parseInt()等全局方法</strong>。</p><h3 id="12-1-1-Global-作用域"><a href="#12-1-1-Global-作用域" class="headerlink" title="12.1.1 Global 作用域"></a>12.1.1 Global 作用域</h3><p>因为window 对象被复用为ECMAScript 的Global 对象，所以<strong>通过<u>var 声明</u>的所有全局变量和函数都会变成window 对象的属性和方法</strong>。</p><h3 id="12-1-2-窗口关系"><a href="#12-1-2-窗口关系" class="headerlink" title="12.1.2 窗口关系"></a>12.1.2 窗口关系</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>window.top</td><td>始终指向最上层（最外层）窗口，即浏览器窗口本身</td></tr><tr><td>window.parent</td><td>而parent 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则parent 等于top（都等于window）</td></tr><tr><td>window.self</td><td>它是终极window 属性，始终会指向window。self 和window 就是同一个对象。之所以还要暴露self，就是为了和top、parent 保持一致</td></tr></tbody></table><p>这些属性都是window 对象的属性，因此访问window.parent、window.top 和window.self<br>都可以。这意味着可以把访问多个窗口的window 对象串联起来，比如window.parent.parent。</p><h3 id="12-1-3-窗口位置与像素比"><a href="#12-1-3-窗口位置与像素比" class="headerlink" title="12.1.3 窗口位置与像素比"></a>12.1.3 窗口位置与像素比</h3><p>window 对象的位置可以通过不同的属性和方法来确定</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>window.screenLeft</td><td>表示窗口相对于屏幕左侧的位置，返回值的单位是CSS 像素。</td></tr><tr><td>window.screenTop</td><td>表示窗口相对于屏幕顶部的位置，返回值的单位是CSS 像素。</td></tr><tr><td>window.moveTo()</td><td>移动窗口，接收两个参数，接收要移动到的新位置的<strong>绝对坐标x 和y</strong></td></tr><tr><td>window.moveBy()</td><td>移动窗口，接收两个参数，接收<strong>相对当前位置</strong>在<strong>两个方向上移动的像素数</strong></td></tr></tbody></table><h3 id="12-1-4-窗口大小"><a href="#12-1-4-窗口大小" class="headerlink" title="12.1.4 窗口大小"></a>12.1.4 窗口大小</h3><p>不同浏览器中确定浏览器窗口大小没有想象中那么容易。所有现代浏览器都支持<strong>4 个属性</strong>：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>window.innerWidth</td><td>返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）</td></tr><tr><td>window.innerHeight</td><td>返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）</td></tr><tr><td>window.outerWidth</td><td>返回浏览器窗口自身的大小（不管是在最外层window 上使用，还是在窗格中使用）</td></tr><tr><td>window.outerHeight</td><td>返回浏览器窗口自身的大小（不管是在最外层window 上使用，还是在窗格中使用）</td></tr><tr><td>document.documentElement.clientWidth</td><td>返回页面视口的宽度</td></tr><tr><td>document.documentElement.clientHeight</td><td>返回页面视口的高度</td></tr><tr><td>resizeTo()</td><td>接收两个参数，resizeTo()接收新的宽度和高度值</td></tr><tr><td>resizeBy()</td><td>接收两个参数，resizeBy()接收宽度和高度各要缩放多少</td></tr></tbody></table><p>与移动窗口的方法一样，缩放窗口的方法(resizeTo(),resizeBy())可能会被浏览器禁用，而且在某些浏览器中默认是禁用的。同样，缩放窗口的方法<strong>只能应用到最上层的window 对象</strong>。</p><h3 id="12-1-5-视口位置"><a href="#12-1-5-视口位置" class="headerlink" title="12.1.5 视口位置"></a>12.1.5 视口位置</h3><p>度量文档相对于视口滚动距离的属性有两对，返回相等的值:可以使用scroll()、scrollTo()和scrollBy()方法滚动页面。这3 个方法都接收表示相对视口距离的x 和y 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>window.pageXoffset&#x2F;window.scrollX</td><td>度量文档相对于视口滚动距离的属性</td></tr><tr><td>window.pageYoffset&#x2F;window.scrollY</td><td>度量文档相对于视口滚动距离的属性</td></tr></tbody></table><h3 id="12-1-6-导航与打开新窗口"><a href="#12-1-6-导航与打开新窗口" class="headerlink" title="12.1.6 导航与打开新窗口"></a>12.1.6 导航与打开新窗口</h3><p>**window.open()**方法可以用于导航到指定URL，也可以用于打开新浏览器窗口。这个方法接收4<br>个参数：要加载的URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页<br>面的布尔值。通常，调用这个方法时只传前3 个参数，最后一个参数只有在不打开新窗口时才会使用。</p><h3 id="12-1-7-定时器"><a href="#12-1-7-定时器" class="headerlink" title="12.1.7 定时器"></a>12.1.7 定时器</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>setTimeout()</td><td>指定在一定时间后执行某些代码</td></tr><tr><td>setInterval()</td><td>指定每隔一段时间执行某些代码</td></tr></tbody></table><h3 id="12-1-8-系统对话框"><a href="#12-1-8-系统对话框" class="headerlink" title="12.1.8 系统对话框"></a>12.1.8 系统对话框</h3><p>使用alert()、confirm()和prompt()方法，可以让浏览器调用系统对话框向用户显示消息</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>alert()</td><td>传入的字符串会显示在一个系统对话框中</td></tr><tr><td>confirm()</td><td>确认框，通过调用confirm()来显示。确认框跟警告框类似，都会向用户显示消息。比alert()多一个OK 和Cancel 按钮</td></tr><tr><td>prompt()</td><td>提示框，提示框的用途是提示用户输入消息。除了OK 和Cancel 按钮，提示框还会显示一个文本框，让用户输入内容</td></tr></tbody></table><h2 id="12-2-location-对象"><a href="#12-2-location-对象" class="headerlink" title="12.2 location 对象"></a>12.2 location 对象</h2><p>location 是最有用的BOM 对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。它<strong>既是window 的属性， 也是document 的属性</strong>。也就是说，<strong>window.location 和document.location 指向同一个对象</strong></p><p>假设浏览器当前加载的URL 是<a href="http://foouser:barpassword@www.wrox.com/WileyCDA/?q=">http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=</a><br>javascript#contents，location 对象的内容如下表所示。</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241028103634325.png" alt="image-20241028103634325"></p><h2 id="12-4-screen-对象"><a href="#12-4-screen-对象" class="headerlink" title="12.4 screen 对象"></a>12.4 screen 对象</h2><p>window 的另一个属性screen 对象，是为数不多的几个在编程中很少用的JavaScript 对象。这个对<br>象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像<br>素高度。每个浏览器都会在screen 对象上暴露不同的属性。下表总结了这些属性。</p><p><img src="C:\Users\26283\AppData\Roaming\Typora\typora-user-images\image-20241028104106884.png" alt="image-20241028104106884"></p><h2 id="12-5-history-对象"><a href="#12-5-history-对象" class="headerlink" title="12.5 history 对象"></a>12.5 history 对象</h2><p>history 对象表示当前窗口首次使用以来用户的导航历史记录。因为history 是window 的属性，<br>所以每个window 都有自己的history 对象。出于安全考虑，这个对象<strong>不会暴露用户访问过的URL</strong>，<br>但可以通过它在不知道实际URL 的情况下前进和后退。</p><h3 id="12-5-1-导航"><a href="#12-5-1-导航" class="headerlink" title="12.5.1 导航"></a>12.5.1 导航</h3><p><strong>go()方法</strong>可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法<strong>只接收一个参数</strong>，<br><strong>这个参数可以是一个整数，表示前进或后退多少步。</strong></p><p>go()有两个简写方法：back()和forward()。顾名思义，这两个方法模拟了浏览器的后退按钮和<br>前进按钮。</p><p>history 对象还有一个<strong>length 属性</strong>，表示历史记录中有多个条目。这个属性反映了历史记录的数<br>量，包括可以前进和后退的页面。对于窗口或标签页中加载的第一个页面，history.length 等于1。<br>通过以下方法测试这个值，可以确定用户浏览器的起点是不是你的页面。</p><h3 id="12-5-2-历史状态管理（略）"><a href="#12-5-2-历史状态管理（略）" class="headerlink" title="12.5.2 历史状态管理（略）"></a>12.5.2 历史状态管理（略）</h3><h1 id="第13-章-客户端检测"><a href="#第13-章-客户端检测" class="headerlink" title="第13 章  客户端检测"></a>第13 章  客户端检测</h1><p>而现实当中，浏览器之间的差异和莫名其妙的行为，让客户端检测变成一种补救措施，而且也成为了开发策略的重要一环。</p><h2 id="13-1-能力检测"><a href="#13-1-能力检测" class="headerlink" title="13.1 能力检测"></a>13.1 能力检测</h2><p><strong>能力检测（又称特性检测）</strong>即在JavaScript 运行时中使用一套简单的检测逻辑，测试浏览器是否支持某种特性。这种方式不要求事先知道特定浏览器的信息，只需检测自己关心的能力是否存在即可。</p><h3 id="13-1-1-安全能力检测"><a href="#13-1-1-安全能力检测" class="headerlink" title="13.1.1 安全能力检测"></a>13.1.1 安全能力检测</h3><p>能力检测最有效的场景是检测能力是否存在的同时，验证其是否能够展现出预期的行为。</p>]]></content>
    
    
    
    <tags>
      
      <tag>来自 -- JavaScript高级程序设计（第4版）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/01/hello-world/"/>
    <url>/2024/07/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
